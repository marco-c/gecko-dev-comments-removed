

"use strict";

















const SHORT_BG_IDLE_TIMEOUT = 500;

const { MockFilePicker } = ChromeUtils.importESModule(
  "resource://testing-common/MockFilePicker.sys.mjs"
);

let downloadDir;

add_setup(() => {
  
  do_get_profile();
  Services.fog.initializeFOG();
  Services.fog.testResetFOG();
});

add_setup(async function setup_MockFilePicker() {
  
  const browser = Services.appShell.createWindowlessBrowser(true);
  MockFilePicker.init(browser.browsingContext);
  registerCleanupFunction(() => {
    MockFilePicker.cleanup();
    browser.close();
  });

  downloadDir = await IOUtils.createUniqueDirectory(PathUtils.tempDir, "dldir");
  registerCleanupFunction(async () => {
    try {
      await IOUtils.remove(downloadDir);
    } catch (e) {
      info(`Failed to remove ${downloadDir} because: ${e}`);
      
      
      let children = await IOUtils.getChildren(downloadDir).catch(e => e);
      ok(false, `Unexpected files in downloadDir: ${children}`);
      await IOUtils.remove(downloadDir, { recursive: true });
    }
  });
});

add_task(
  { pref_set: [["extensions.background.idle.timeout", SHORT_BG_IDLE_TIMEOUT]] },
  async function test_download_blob_with_slow_file_picker() {
    Services.fog.testResetFOG();

    let pickerShownCount = 0;
    const pickedFile = await IOUtils.getFile(downloadDir, "result.txt");
    MockFilePicker.showCallback = async () => {
      
      equal(++pickerShownCount, 1, "File picker should show once");
      info(`Delaying file picker completion past background idle timeout`);
      
      await new Promise(r => setTimeout(r, 2 * SHORT_BG_IDLE_TIMEOUT));
      info("Returning from file picker after background idle timeout passed");
      MockFilePicker.setFiles([pickedFile]);
      return MockFilePicker.returnOK;
    };
    const promisePickerAfterShown = new Promise(resolve => {
      MockFilePicker.afterOpenCallback = resolve;
    });

    let extension = ExtensionTestUtils.loadExtension({
      manifest: {
        manifest_version: 3,
        permissions: ["downloads"],
      },
      async background() {
        const blobUrl = URL.createObjectURL(new Blob(["1234567890123"]));
        browser.test.log(`Calling downloads.download with URL ${blobUrl}`);
        await browser.downloads.download({ url: blobUrl, saveAs: true });
        
        
        
        
        
        
        
        browser.test.sendMessage("download_done");
      },
    });

    await extension.startup();

    info("Waiting for file picker to have been shown.");
    await promisePickerAfterShown;

    equal(pickerShownCount, 1, "File picker was shown once");

    info(`Waiting until blob was saved to chosen file at ${pickedFile.path}`);
    await TestUtils.waitForCondition(
      async () => pickedFile.exists(),
      `downloads.download() should have saved blob to file: ${pickedFile.path}`
    );

    info(`Waiting until file was fully written`);
    
    
    await TestUtils.waitForCondition(() => pickedFile.clone().fileSize === 13);

    equal(
      await IOUtils.readUTF8(pickedFile.path),
      "1234567890123",
      "Content of blob was fully written"
    );

    
    
    
    
    
    info("Confirming that background stayed alive whilst showing file picker");
    await extension.awaitMessage("download_done");

    await extension.unload();

    MockFilePicker.reset();
    pickedFile.remove(false);

    Assert.greater(
      Glean.extensionsCounters.eventPageIdleResult.downloads_saveAs.testGetValue(),
      0,
      "Postponed background idle timeout due to downloads.download() call"
    );
  }
);
