



use super::*;
use crate::Config;
use std::collections::{HashMap, HashSet};

pub fn pass(mut config_map: HashMap<String, Config>) -> impl FnMut(&mut Namespace) -> Result<()> {
    move |namespace: &mut Namespace| {
        namespace.config = config_map.remove(&namespace.crate_name).unwrap_or_default();
        
        
        
        
        
        if namespace.name.starts_with("uniffi_bindings_tests") {
            namespace.fixture = true;
        }

        
        namespace.string_type_node = TypeNode {
            ty: Type::String,
            canonical_name: "String".to_string(),
            ..TypeNode::default()
        };

        
        let config = namespace.config.clone();
        let mut all_imports = HashSet::new();

        
        namespace.try_visit_mut(|custom: &mut CustomType| {
            if let Some(custom_config) = config.custom_types.get(&custom.name) {
                custom.type_name = custom_config.type_name.clone();
                custom.lift_expr = Some(custom_config.lift.clone());
                custom.lower_expr = Some(custom_config.lower.clone());

                
                custom.lift_expr = Some(custom_config.lift.replace("{}", "builtinVal"));
                custom.lower_expr = Some(custom_config.lower.replace("{}", "value"));

                
                all_imports.extend(custom_config.imports.iter().cloned());
            }
            Ok(())
        })?;

        let mut imports_vec: Vec<String> = all_imports.into_iter().collect();
        imports_vec.sort(); 
        namespace.imports = imports_vec;

        let mut saw_callback_interface = false;
        namespace.visit(|_: &VTable| saw_callback_interface = true);
        namespace.has_callback_interface = saw_callback_interface;
        Ok(())
    }
}
