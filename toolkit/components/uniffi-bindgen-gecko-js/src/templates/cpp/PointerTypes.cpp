






{%- for (preprocessor_condition, pointer_types, preprocessor_condition_end) in pointer_types.iter() %}
{{ preprocessor_condition }}
{%- for pointer_type in pointer_types %}
const static mozilla::uniffi::UniFFIPointerType {{ pointer_type.name }} {
  "{{ pointer_type.label }}"_ns,
  {{ pointer_type.ffi_func_clone.0 }},
  {{ pointer_type.ffi_func_free.0 }},
};

{%- match pointer_type.trait_interface_info %}
{%- when None %}
class {{ pointer_type.ffi_value_class }} {
 private:
  uint64_t mValue = 0;

 public:
  {{ pointer_type.ffi_value_class }}() = default;
  explicit {{ pointer_type.ffi_value_class }}(uint64_t aValue) : mValue(aValue) {}

  
  {{ pointer_type.ffi_value_class }}(const {{ pointer_type.ffi_value_class }}&) = delete;
  {{ pointer_type.ffi_value_class }}& operator=(const {{ pointer_type.ffi_value_class }}&) = delete;

  {{ pointer_type.ffi_value_class }}& operator=({{ pointer_type.ffi_value_class }}&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&{{ pointer_type.name }})) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  
  
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &{{ pointer_type.name }});
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static {{ pointer_type.ffi_value_class }} FromRust(uint64_t aValue) {
    return {{ pointer_type.ffi_value_class }}(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      ({{ pointer_type.ffi_func_free.0 }})(mValue, &callStatus);
      
      
    }
  }

  ~{{ pointer_type.ffi_value_class }}() {
    
    
    
    FreeHandle();
  }
};
{%- when Some(trait_interface_info) %}

extern "C" void {{ trait_interface_info.free_fn }}(uint64_t uniffiHandle);
extern "C" uint64_t {{ trait_interface_info.clone_fn }}(uint64_t uniffiHandle);



class {{ pointer_type.ffi_value_class }} {
 private:
  
  
  
  
  uint64_t mValue = 0;

 public:
  {{ pointer_type.ffi_value_class }}() = default;
  explicit {{ pointer_type.ffi_value_class }}(uint64_t aValue) : mValue(aValue) {}

  
  {{ pointer_type.ffi_value_class }}(const {{ pointer_type.ffi_value_class }}&) = delete;
  {{ pointer_type.ffi_value_class }}& operator=(const {{ pointer_type.ffi_value_class }}&) = delete;

  {{ pointer_type.ffi_value_class }}& operator=({{ pointer_type.ffi_value_class }}&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  
  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    FreeHandle();
    if (aValue.IsUniFFIPointer()) {
      
      dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
      if (!value.IsSamePtrType(&{{ pointer_type.name }})) {
        aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
        return;
      }
      mValue = value.ClonePtr();
    } else if (aValue.IsDouble()) {
      
      
      double floatValue = aValue.GetAsDouble();
      uint64_t intValue = static_cast<uint64_t>(floatValue);
      if (intValue != floatValue) {
        aError.ThrowTypeError("Not an integer"_ns);
        return;
      }
      mValue = intValue;
    } else {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
  }

  
  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    if ((mValue & 1) == 0) {
      
      aDest->SetAsUniFFIPointer() =
          dom::UniFFIPointer::Create(mValue, &{{ pointer_type.name }});
    } else {
      
      aDest->SetAsDouble() = mValue;
    }
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static {{ pointer_type.ffi_value_class }} FromRust(uint64_t aValue) {
    return {{ pointer_type.ffi_value_class }}(aValue);
  }

  void FreeHandle() {
    
    
    
    if (mValue == 0) {
      
    } else if ((mValue & 1) == 0) {
      
      RustCallStatus callStatus{};
      ({{ pointer_type.ffi_func_free.0 }})(mValue, &callStatus);
      
      
    } else {
      
      {{ trait_interface_info.free_fn }}(mValue);
    }
    mValue = 0;
  }

  ~{{ pointer_type.ffi_value_class }}() {
    
    
    
    FreeHandle();
  }
};
{%- endmatch %}

{%- endfor %}
{{ preprocessor_condition_end }}
{%- endfor %}

Maybe<already_AddRefed<UniFFIPointer>> ReadPointer(const GlobalObject& aGlobal, uint64_t aId, const ArrayBuffer& aArrayBuff, long aPosition, ErrorResult& aError) {
  const UniFFIPointerType* type;
  switch (aId) {
    {%- for (preprocessor_condition, pointer_types, preprocessor_condition_end) in pointer_types.iter() %}
{{ preprocessor_condition }}
    {%- for pointer_type in pointer_types %}
    case {{ pointer_type.id }}: {
      type = &{{ pointer_type.name }};
      break;
    }
    {%- endfor %}
{{ preprocessor_condition_end }}
    {%- endfor %}
    default:
      return Nothing();
  }
  return Some(UniFFIPointer::Read(aArrayBuff, aPosition, type, aError));
}

bool WritePointer(const GlobalObject& aGlobal, uint64_t aId, const UniFFIPointer& aPtr, const ArrayBuffer& aArrayBuff, long aPosition, ErrorResult& aError) {
  const UniFFIPointerType* type;
  switch (aId) {
    {%- for (preprocessor_condition, pointer_types, preprocessor_condition_end) in pointer_types.iter() %}
{{ preprocessor_condition }}
    {%- for pointer_type in pointer_types %}
    case {{ pointer_type.id }}: {
      type = &{{ pointer_type.name }};
      break;
    }
    {%- endfor %}
{{ preprocessor_condition_end }}
    {%- endfor %}
    default:
      return false;
  }
  aPtr.Write(aArrayBuff, aPosition, type, aError);
  return true;
}
