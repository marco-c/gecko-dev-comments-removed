





#include "gtest/gtest.h"
#include "mozilla/gtest/nsUserCharacteristics.h"

#include "mozilla/glean/GleanPings.h"
#include "mozilla/glean/ResistfingerprintingMetrics.h"
#include "mozilla/Preferences.h"

using namespace mozilla;


static const struct {
  const char* pref;
  const char* shortName;
} kMathMLPrefs[] = {
    {"mathml.disabled", "dis"},
    {"mathml.scale_stretchy_operators.enabled", "str"},
    {"mathml.mathspace_names.disabled", "spc"},
    {"mathml.rtl_operator_mirroring.enabled", "rtl"},
    {"mathml.mathvariant_styling_fallback.disabled", "var"},
    {"mathml.math_shift.enabled", "shf"},
    {"mathml.operator_dictionary_accent.disabled", "acc"},
    {"mathml.legacy_mathvariant_attribute.disabled", "leg"},
    {"mathml.font_family_math.enabled", "fnt"},
};

static void ClearAllMathMLPrefs() {
  for (const auto& p : kMathMLPrefs) {
    Preferences::ClearUser(p.pref);
  }
}

TEST(ResistFingerprinting, UserCharacteristics_MathMLPrefs_Default)
{
  ClearAllMathMLPrefs();

  ASSERT_TRUE(mozilla::glean_pings::UserCharacteristics.TestSubmission(
      [](const nsACString& aReason) {
        auto result =
            mozilla::glean::characteristics::mathml_diag_prefs_modified
                .TestGetValue()
                .unwrap();
        
        ASSERT_TRUE(result.isNothing() || result.value().IsEmpty());
      },
      []() {
        testing::PopulateMathMLPrefs();
        mozilla::glean_pings::UserCharacteristics.Submit();
      }));
}

TEST(ResistFingerprinting, UserCharacteristics_MathMLPrefs_SingleTrue)
{
  ClearAllMathMLPrefs();

  
  Preferences::SetBool(kMathMLPrefs[0].pref, true);

  ASSERT_TRUE(mozilla::glean_pings::UserCharacteristics.TestSubmission(
      [](const nsACString& aReason) {
        auto result =
            mozilla::glean::characteristics::mathml_diag_prefs_modified
                .TestGetValue()
                .unwrap()
                .value();
        ASSERT_STREQ("dis=1", result.get());
      },
      []() {
        testing::PopulateMathMLPrefs();
        mozilla::glean_pings::UserCharacteristics.Submit();
      }));

  ClearAllMathMLPrefs();
}

TEST(ResistFingerprinting, UserCharacteristics_MathMLPrefs_TwoPrefs)
{
  ClearAllMathMLPrefs();

  
  
  
  Preferences::SetBool(kMathMLPrefs[0].pref, true);   
  Preferences::SetBool(kMathMLPrefs[1].pref, false);  

  ASSERT_TRUE(mozilla::glean_pings::UserCharacteristics.TestSubmission(
      [](const nsACString& aReason) {
        auto result =
            mozilla::glean::characteristics::mathml_diag_prefs_modified
                .TestGetValue()
                .unwrap()
                .value();
        
        ASSERT_STREQ("dis=1,str=0", result.get());
      },
      []() {
        testing::PopulateMathMLPrefs();
        mozilla::glean_pings::UserCharacteristics.Submit();
      }));

  ClearAllMathMLPrefs();
}

TEST(ResistFingerprinting, UserCharacteristics_MathMLPrefs_NonAdjacent)
{
  ClearAllMathMLPrefs();

  
  Preferences::SetBool(kMathMLPrefs[0].pref, true);   
  Preferences::SetBool(kMathMLPrefs[3].pref, false);  

  ASSERT_TRUE(mozilla::glean_pings::UserCharacteristics.TestSubmission(
      [](const nsACString& aReason) {
        auto result =
            mozilla::glean::characteristics::mathml_diag_prefs_modified
                .TestGetValue()
                .unwrap()
                .value();
        ASSERT_STREQ("dis=1,rtl=0", result.get());
      },
      []() {
        testing::PopulateMathMLPrefs();
        mozilla::glean_pings::UserCharacteristics.Submit();
      }));

  ClearAllMathMLPrefs();
}

TEST(ResistFingerprinting, UserCharacteristics_MathMLPrefs_Format)
{
  ClearAllMathMLPrefs();

  
  Preferences::SetBool(kMathMLPrefs[0].pref, true);
  Preferences::SetBool(kMathMLPrefs[1].pref, false);
  Preferences::SetBool(kMathMLPrefs[2].pref, true);

  ASSERT_TRUE(mozilla::glean_pings::UserCharacteristics.TestSubmission(
      [](const nsACString& aReason) {
        auto result =
            mozilla::glean::characteristics::mathml_diag_prefs_modified
                .TestGetValue()
                .unwrap()
                .value();

        
        nsCString str(result);

        
        ASSERT_TRUE(str.Find(",") != kNotFound);

        
        
        int32_t start = 0;
        int32_t pos;
        while ((pos = str.Find(",", start)) != kNotFound ||
               start < (int32_t)str.Length()) {
          int32_t end = (pos != kNotFound) ? pos : str.Length();
          nsCString part;
          str.Mid(part, start, end - start);

          
          ASSERT_EQ(1, std::count(part.BeginReading(), part.EndReading(), '='));

          
          int32_t eqPos = part.Find("=");
          ASSERT_TRUE(eqPos != kNotFound);
          char value = part.CharAt(eqPos + 1);
          ASSERT_TRUE(value == '0' || value == '1');

          start = end + 1;
          if (pos == kNotFound) break;
        }
      },
      []() {
        testing::PopulateMathMLPrefs();
        mozilla::glean_pings::UserCharacteristics.Submit();
      }));

  ClearAllMathMLPrefs();
}
