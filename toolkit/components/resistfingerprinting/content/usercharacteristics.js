












var debugMsgs = [];
function debug(...args) {
  let msg = "";
  if (!args.length) {
    debugMsgs.push("");
    return;
  }

  const stringify = o => {
    if (typeof o == "string") {
      return o;
    }
    return JSON.stringify(o);
  };

  const stringifiedArgs = args.map(stringify);
  msg += stringifiedArgs.join(" ");
  debugMsgs.push(msg);

  
  
  console.log(msg);
}

function sha1(message) {
  const msgUint8 = new TextEncoder().encode(message);
  return sha1Uint8Array(msgUint8);
}

async function sha1Uint8Array(bytes) {
  const hashBuffer = await crypto.subtle.digest("SHA-1", bytes);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}

async function stringifyError(error) {
  if (error instanceof Error) {
    const stack = (error.stack ?? "").replaceAll(
      /@chrome.+?usercharacteristics.js:/g,
      ""
    );
    return `${error.toString()} ${stack}`;
  }
  
  const errStr = await (async () => {
    const asStr = await (async () => error.toString())().catch(() => "");
    const asJson = await (async () => JSON.stringify(error))().catch(() => "");
    return asStr.length > asJson.len ? asStr : asJson;
  })();
  return errStr;
}

function sample(array, count) {
  const range = array.length - 1;
  if (range <= count) {
    return array;
  }

  const samples = [];
  const step = Math.floor(range / count);
  for (let i = 0; i < range; i += step) {
    samples.push(array[i]);
  }
  return samples;
}

function mean(array) {
  if (array.length === 0) {
    return 0;
  }
  return array.reduce((a, b) => a + b) / array.length;
}

function standardDeviation(array) {
  const m = mean(array);
  return Math.sqrt(mean(array.map(x => Math.pow(x - m, 2))));
}



function decimalPlaces(num) {
  
  const str = num >= 0 ? num.toString() : num.toString().substr(1);
  
  const dashI = str.indexOf("-");
  if (dashI !== -1) {
    return +str.substr(dashI + 1);
  }

  
  const dotI = str.indexOf(".");
  if (dotI !== -1) {
    return str.length - dotI - 1;
  }

  
  const commaI = str.indexOf(",");
  if (commaI !== -1) {
    return str.length - commaI - 1;
  }

  return 0;
}

function timeoutPromise(promise, ms) {
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      reject(new Error("TIMEOUT"));
    }, ms);

    promise.then(
      value => {
        clearTimeout(timeoutId);
        resolve(value);
      },
      error => {
        clearTimeout(timeoutId);
        reject(error);
      }
    );
  });
}




function populateWebGLCanvases(contextOptions = {}) {
  
  

  const data = {};
  const suffix = contextOptions.forceSoftwareRendering ? "Software" : "";

  
  
  
  
  
  
  function initBuffers(gl) {
    

    const positionBuffer = gl.createBuffer();

    
    

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    

    const positions = [1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0];

    
    
    

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    

    var colors = [
      1.0,
      1.0,
      1.0,
      1.0, 
      1.0,
      0.0,
      0.0,
      1.0, 
      0.0,
      1.0,
      0.0,
      1.0, 
      0.0,
      0.0,
      1.0,
      1.0, 
    ];

    const colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

    return {
      position: positionBuffer,
      color: colorBuffer,
    };
  }

  
  
  function drawScene(gl, programInfo, buffers) {
    gl.clearColor(0.0, 0.0, 0.0, 1.0); 
    gl.clearDepth(1.0); 
    gl.enable(gl.DEPTH_TEST); 
    gl.depthFunc(gl.LEQUAL); 

    

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    
    
    
    
    
    

    const fieldOfView = (45 * Math.PI) / 180; 
    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
    const zNear = 0.1;
    const zFar = 100.0;
    const projectionMatrix = mat4.create();

    
    
    mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

    
    
    const modelViewMatrix = mat4.create();

    var squareRotation = 1.0;

    
    

    mat4.translate(
      modelViewMatrix, 
      modelViewMatrix, 
      [-0.0, 0.0, -6.0]
    ); 
    mat4.rotate(
      modelViewMatrix, 
      modelViewMatrix, 
      squareRotation, 
      [0, 0, 1]
    ); 

    
    
    {
      const numComponents = 2;
      const type = gl.FLOAT;
      const normalize = false;
      const stride = 0;
      const offset = 0;
      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
      gl.vertexAttribPointer(
        programInfo.attribLocations.vertexPosition,
        numComponents,
        type,
        normalize,
        stride,
        offset
      );
      gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
    }

    
    
    {
      const numComponents = 4;
      const type = gl.FLOAT;
      const normalize = false;
      const stride = 0;
      const offset = 0;
      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
      gl.vertexAttribPointer(
        programInfo.attribLocations.vertexColor,
        numComponents,
        type,
        normalize,
        stride,
        offset
      );
      gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);
    }

    

    gl.useProgram(programInfo.program);

    

    gl.uniformMatrix4fv(
      programInfo.uniformLocations.projectionMatrix,
      false,
      projectionMatrix
    );
    gl.uniformMatrix4fv(
      programInfo.uniformLocations.modelViewMatrix,
      false,
      modelViewMatrix
    );

    {
      const offset = 0;
      const vertexCount = 4;
      gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);
    }
  }

  
  
  function initShaderProgram(gl, vsSource, fsSource) {
    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

    

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert(
        "Unable to initialize the shader program: " +
          gl.getProgramInfoLog(shaderProgram)
      );
      return null;
    }

    return shaderProgram;
  }

  
  
  
  
  
  function loadShader(gl, type, source) {
    const shader = gl.createShader(type);

    
    gl.shaderSource(shader, source);

    
    gl.compileShader(shader);

    
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      alert(
        "An error occurred compiling the shaders: " +
          gl.getShaderInfoLog(shader)
      );
      gl.deleteShader(shader);
      return null;
    }

    return shader;
  }

  
  const canvas = document.getElementById("glcanvas" + suffix);
  const gl = canvas.getContext("webgl", contextOptions);

  

  if (!gl) {
    alert(
      "Unable to initialize WebGL. Your browser or machine may not support it."
    );
    return {};
  }

  

  const vsSource = `
    attribute vec4 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    varying lowp vec4 vColor;

    void main(void) {
      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
      vColor = aVertexColor;
    }
  `;

  

  const fsSource = `
    varying lowp vec4 vColor;

    void main(void) {
      gl_FragColor = vColor;
    }
  `;

  
  
  const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

  
  
  
  
  const programInfo = {
    program: shaderProgram,
    attribLocations: {
      vertexPosition: gl.getAttribLocation(shaderProgram, "aVertexPosition"),
      vertexColor: gl.getAttribLocation(shaderProgram, "aVertexColor"),
    },
    uniformLocations: {
      projectionMatrix: gl.getUniformLocation(
        shaderProgram,
        "uProjectionMatrix"
      ),
      modelViewMatrix: gl.getUniformLocation(shaderProgram, "uModelViewMatrix"),
    },
  };

  
  
  const buffers = initBuffers(gl);

  
  drawScene(gl, programInfo, buffers);

  
  const pixels = new Uint8Array(
    gl.drawingBufferWidth * gl.drawingBufferHeight * 4
  );
  gl.readPixels(
    0,
    0,
    gl.drawingBufferWidth,
    gl.drawingBufferHeight,
    gl.RGBA,
    gl.UNSIGNED_BYTE,
    pixels
  );
  data["canvasdata11Webgl" + suffix] = sha1Uint8Array(pixels);
  data["canvasdata11Webgl" + suffix + "Raw"] = btoa(
    String.fromCharCode.apply(null, pixels)
  );

  return data;
}



async function populateVoiceList() {
  
  const uriPrefixes = [
    [/(?:urn:)?moz-tts:.*?:/, "#m:"],
    [/com\.apple\.speech\.synthesis\.voice\./, "#as:"],
    [/com\.apple\.voice\.compact./, "#ac:"],
    [/com\.apple\.eloquence\./, "#ap:"],
    
  ];

  function trimVoiceURI(uri) {
    for (const [re, replacement] of uriPrefixes) {
      uri = uri.replace(re, replacement);
    }
    return uri;
  }

  async function processVoices(voices) {
    voices = voices
      .map(voice => ({
        voiceURI: trimVoiceURI(voice.voiceURI),
        default: voice.default,
        localService: voice.localService,
      }))
      .sort((a, b) => a.voiceURI.localeCompare(b.voiceURI));

    const [localServices, nonLocalServices] = voices.reduce(
      (acc, voice) => {
        if (voice.localService) {
          acc[0].push(voice.voiceURI);
        } else {
          acc[1].push(voice.voiceURI);
        }
        return acc;
      },
      [[], []]
    );
    const defaultVoice = voices.find(voice => voice.default);

    voices = voices.map(voice => voice.voiceURI).sort();

    return {
      voicesCount: voices.length,
      voicesLocalCount: localServices.length,
      voicesDefault: defaultVoice ? defaultVoice.voiceURI : null,
      voicesSample: sample(voices, 5).join(","),
      voicesSha1: await sha1(voices.join("|")),
      voicesAllSsdeep: ssdeep.digest(voices.join("|")),
      voicesLocalSsdeep: ssdeep.digest(localServices.join("|")),
      voicesNonlocalSsdeep: ssdeep.digest(nonLocalServices.join("|")),
    };
  }

  function fetchVoices() {
    const promise = new Promise(resolve => {
      speechSynthesis.addEventListener("voiceschanged", function () {
        resolve(speechSynthesis.getVoices());
      });

      if (speechSynthesis.getVoices().length !== 0) {
        resolve(speechSynthesis.getVoices());
      }
    });

    const timeout = new Promise(resolve => {
      setTimeout(() => {
        resolve([]);
      }, 5000);
    });

    return Promise.race([promise, timeout]);
  }

  return fetchVoices().then(processVoices);
}

async function populateMediaCapabilities() {
  
  
  
  
  const mimeTypes = [
    
    "video/webm; codecs=vp9",
    "video/webm; codecs=vp8",
    "video/webm; codecs=av1",
    
    "video/mp4; codecs=vp9",
    "video/mp4; codecs=vp8",
    "video/mp4; codecs=hev1.1.0.L30.b0",
    "video/mp4; codecs=avc1.42000A",
  ];

  const videoConfig = {
    type: "file",
    video: {
      width: 1280,
      height: 720,
      bitrate: 10000,
      framerate: 30,
    },
  };

  
  
  async function h264CodecsSupported() {
    
    const levels = [...Array(3).keys()]
      .map(i => [
        ((i + 4) * 10).toString(16),
        ((i + 4) * 10 + 1).toString(16),
        ((i + 4) * 10 + 2).toString(16),
      ])
      .flat();

    
    
    const profiles = ["avc1.4200", "avc1.4d00", "avc1.6e00", "avc1.7a00"];

    const supportLevels = {};
    for (const profile of profiles) {
      for (const level of levels) {
        const mimeType = `video/mp4; codecs=${profile}${level}`;
        videoConfig.video.contentType = mimeType;
        const capability =
          await navigator.mediaCapabilities.decodingInfo(videoConfig);

        if (capability.supported) {
          supportLevels[profile] = level;
        }
      }
    }

    return supportLevels;
  }

  async function getCapabilities() {
    const capabilities = {
      unsupported: [],
      notSmooth: [],
      notPowerEfficient: [],
      h264: await h264CodecsSupported(),
    };

    for (const mime of mimeTypes) {
      videoConfig.video.contentType = mime;
      const capability =
        await navigator.mediaCapabilities.decodingInfo(videoConfig);
      const shortMime = mime.split("=")[1];
      if (!capability.supported) {
        capabilities.unsupported.push(shortMime);
      } else {
        if (!capability.smooth) {
          capabilities.notSmooth.push(shortMime);
        }
        if (!capability.powerEfficient) {
          capabilities.notPowerEfficient.push(shortMime);
        }
      }
    }

    return capabilities;
  }

  const capabilities = await getCapabilities();

  return {
    mediaCapabilitiesUnsupported: JSON.stringify(capabilities.unsupported),
    mediaCapabilitiesNotSmooth: JSON.stringify(capabilities.notSmooth),
    mediaCapabilitiesNotEfficient: JSON.stringify(
      capabilities.notPowerEfficient
    ),
    mediaCapabilitiesH264: JSON.stringify(capabilities.h264),
  };
}

async function populateAudioFingerprint() {
  
  
  
  const hashFromIndex = 4500;
  const hashToIndex = 5000;
  const context = new window.OfflineAudioContext(1, hashToIndex, 44100);

  const oscillator = context.createOscillator();
  oscillator.type = "triangle";
  oscillator.frequency.value = 10000;

  const compressor = context.createDynamicsCompressor();
  compressor.threshold.value = -50;
  compressor.knee.value = 40;
  compressor.ratio.value = 12;
  compressor.attack.value = 0;
  compressor.release.value = 0.25;

  
  const analyser = context.createAnalyser();

  
  oscillator.connect(compressor);
  compressor.connect(analyser);
  compressor.connect(context.destination);
  oscillator.start(0);

  const [renderPromise, finishRendering] = startRenderingAudio(context);
  const fingerprintPromise = renderPromise.then(
    buffer => getHash(buffer.getChannelData(0).subarray(hashFromIndex)),
    error => {
      if (error === "TIMEOUT" || error.name === "SUSPENDED") {
        return "TIMEOUT";
      }
      throw error;
    }
  );

  
  const detailedMetricsPromise = renderPromise.then(
    buffer => {
      const bins = buffer.getChannelData(0);

      
      const compressorGainReduction = String(
        compressor.reduction?.value ?? compressor.reduction ?? 0
      );

      
      const floatFrequencyData = new Float32Array(analyser.frequencyBinCount);
      analyser.getFloatFrequencyData(floatFrequencyData);
      const floatFrequencySum = String(
        [...floatFrequencyData].reduce((acc, n) => acc + Math.abs(n), 0)
      );

      
      let floatTimeDomainSum = "0";
      if ("getFloatTimeDomainData" in analyser) {
        const floatTimeDomainData = new Float32Array(analyser.fftSize);
        analyser.getFloatTimeDomainData(floatTimeDomainData);
        floatTimeDomainSum = String(
          [...floatTimeDomainData].reduce((acc, n) => acc + Math.abs(n), 0)
        );
      }

      
      const sampleSnapshot = [...bins].slice(4500, 4600);
      const sampleHash = hashAudioSamples(sampleSnapshot);

      
      const uniqueSamples = new Set(bins).size;

      return {
        audioCompressorGainReduction: compressorGainReduction,
        audioFloatFrequencySum: floatFrequencySum,
        audioFloatTimeDomainSum: floatTimeDomainSum,
        audioFingerprint2: sampleHash,
        audioUniqueSamples: uniqueSamples,
      };
    },
    _error => {
      
      return {
        audioCompressorGainReduction: "0",
        audioFloatFrequencySum: "0",
        audioFloatTimeDomainSum: "0",
        audioFingerprint2: "00000000",
        audioUniqueSamples: 0,
      };
    }
  );

  



  function startRenderingAudio(context) {
    const renderTryMaxCount = 3;
    const renderRetryDelay = 500;
    const runningMaxAwaitTime = 500;
    const runningSufficientTime = 5000;
    let finalize = () => undefined;

    const resultPromise = new Promise((resolve, reject) => {
      let isFinalized = false;
      let renderTryCount = 0;
      let startedRunningAt = 0;

      context.oncomplete = event => resolve(event.renderedBuffer);

      const startRunningTimeout = () => {
        setTimeout(
          () => reject("TIMEMOUT"),
          Math.min(
            runningMaxAwaitTime,
            startedRunningAt + runningSufficientTime - Date.now()
          )
        );
      };

      const tryRender = () => {
        try {
          context.startRendering();

          switch (context.state) {
            case "running":
              startedRunningAt = Date.now();
              if (isFinalized) {
                startRunningTimeout();
              }
              break;

            
            
            
            case "suspended":
              
              
              
              
              if (!document.hidden) {
                renderTryCount++;
              }
              if (isFinalized && renderTryCount >= renderTryMaxCount) {
                reject("SUSPENDED");
              } else {
                setTimeout(tryRender, renderRetryDelay);
              }
              break;
          }
        } catch (error) {
          reject(error);
        }
      };

      tryRender();

      finalize = () => {
        if (!isFinalized) {
          isFinalized = true;
          if (startedRunningAt > 0) {
            startRunningTimeout();
          }
        }
      };
    });

    return [resultPromise, finalize];
  }

  function getHash(signal) {
    let hash = 0;
    for (let i = 0; i < signal.length; ++i) {
      hash += Math.abs(signal[i]);
    }
    
    
    
    
    return hash * 10e13;
  }

  function hashAudioSamples(samples) {
    
    const sum = samples.reduce((acc, n) => acc + Math.abs(n), 0);
    const hash = Math.floor(sum * 1000000)
      .toString(16)
      .substring(0, 8);
    return hash;
  }

  finishRendering();

  
  const combinedPromise = Promise.all([
    fingerprintPromise,
    detailedMetricsPromise,
  ]).then(([fingerprint, detailedMetrics]) => ({
    audioFingerprint: fingerprint,
    ...detailedMetrics,
  }));

  return combinedPromise;
}

async function populateCSSQueries() {
  return {
    monochrome: matchMedia("(monochrome)").matches,
  };
}

async function populateCSSSystemColors() {
  const systemColors = [
    "Canvas",
    "CanvasText",
    "LinkText",
    "VisitedText",
    "ActiveText",
    "ButtonFace",
    "ButtonText",
    "ButtonBorder",
    "Field",
    "FieldText",
    "Highlight",
    "HighlightText",
    "SelectedItem",
    "SelectedItemText",
    "AccentColor",
    "AccentColorText",
    "Mark",
    "MarkText",
    "GrayText",
    "ActiveBorder",
    "ActiveCaption",
    "AppWorkspace",
    "Background",
    "ButtonShadow",
    "InactiveBorder",
    "InactiveCaption",
    "InactiveCaptionText",
    "InfoBackground",
    "InfoText",
    "Menu",
    "MenuText",
    "Scrollbar",
    "ThreeDDarkShadow",
    "ThreeDFace",
    "ThreeDHighlight",
    "ThreeDLightShadow",
    "ThreeDShadow",
    "Window",
    "WindowFrame",
    "WindowText",
  ];

  const rgbToHex = rgb => {
    const match = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    if (!match) {
      return rgb;
    }
    const [, r, g, b] = match;
    return [r, g, b]
      .map(x => parseInt(x, 10).toString(16).padStart(2, "0"))
      .join("")
      .toUpperCase();
  };

  const div = document.createElement("div");
  document.body.appendChild(div);

  const results = [];
  for (const colorName of systemColors) {
    div.style.backgroundColor = colorName;
    const computed = getComputedStyle(div).backgroundColor;
    results.push({ [colorName]: rgbToHex(computed) });
  }

  document.body.removeChild(div);

  return {
    cssSystemColors: JSON.stringify(results),
  };
}

async function populateCSSSystemFonts() {
  const systemFonts = [
    "caption",
    "icon",
    "menu",
    "message-box",
    "small-caption",
    "status-bar",
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
    "Arial",
    "Helvetica",
    "Times New Roman",
    "Courier New",
    "Verdana",
    "Georgia",
  ];

  const div = document.createElement("div");
  div.textContent = "Test";
  document.body.appendChild(div);

  const results = [];
  for (const fontName of systemFonts) {
    div.style.fontFamily = fontName;
    const computed = getComputedStyle(div);
    const value = computed.fontSize + " " + computed.fontFamily;
    results.push({ [fontName]: value });
  }

  document.body.removeChild(div);

  return {
    cssSystemFonts: JSON.stringify(results),
  };
}

async function populateClientRects() {
  function serializeDOMRect(rect) {
    if (!rect) {
      return null;
    }
    return {
      b: rect.bottom,
      h: rect.height,
      l: rect.left,
      r: rect.right,
      t: rect.top,
      w: rect.width,
      x: rect.x,
      y: rect.y,
    };
  }

  const container = document.createElement("div");
  container.style.cssText = "position: absolute; left: -9999px; width: 100px;";
  document.body.appendChild(container);

  const testElements = [
    { border: "2.715px", padding: "3.98px", marginLeft: "12.12px" },
    { border: "5px", padding: "10px", marginLeft: "20px" },
    { border: "1.5px", padding: "2.5px", marginLeft: "5.5px" },
    { border: "3px", padding: "7px", marginLeft: "15px" },
    { border: "4.25px", padding: "6.75px", marginLeft: "10.5px" },
    { border: "2px", padding: "5px", marginLeft: "8px" },
    { border: "6px", padding: "12px", marginLeft: "25px" },
    { border: "1px", padding: "1px", marginLeft: "3px" },
    { border: "3.5px", padding: "8.5px", marginLeft: "18.5px" },
    { border: "4px", padding: "9px", marginLeft: "22px" },
    { border: "2.25px", padding: "4.25px", marginLeft: "7.25px" },
    { border: "5.5px", padding: "11.5px", marginLeft: "28.5px" },
  ];

  const elementMeasurements = [];
  for (let i = 0; i < testElements.length; i++) {
    const elem = document.createElement("div");
    const style = testElements[i];
    elem.style.cssText = `
      border: ${style.border} solid red;
      padding: ${style.padding};
      margin-left: ${style.marginLeft};
      width: 50px;
      height: 20px;
    `;
    elem.textContent = "test";
    container.appendChild(elem);
    elementMeasurements.push(elem);
  }

  const results = {};

  for (let i = 0; i < elementMeasurements.length; i++) {
    const elem = elementMeasurements[i];
    const metricNum = String(i + 1).padStart(2, "0");

    const elemGCR = elem.getClientRects()[0];
    results[`clientrectsElementGcr${metricNum}`] = JSON.stringify(
      serializeDOMRect(elemGCR)
    );

    const elemGBCR = elem.getBoundingClientRect();
    results[`clientrectsElementGbcr${metricNum}`] = JSON.stringify(
      serializeDOMRect(elemGBCR)
    );

    const range = document.createRange();
    range.selectNodeContents(elem);
    const rangeGCR = range.getClientRects()[0];
    results[`clientrectsRangeGcr${metricNum}`] = JSON.stringify(
      serializeDOMRect(rangeGCR)
    );

    const rangeNode = document.createRange();
    rangeNode.selectNode(elem);
    const rangeNodeGBCR = rangeNode.getBoundingClientRect();
    results[`clientrectsRangeGbcr${metricNum}`] = JSON.stringify(
      serializeDOMRect(rangeNodeGBCR)
    );
  }

  const knownElement = document.createElement("div");
  knownElement.style.cssText =
    "width: 100px; height: 100px; border: 10px solid red;";
  knownElement.textContent = "known";
  container.appendChild(knownElement);
  const knownRect = knownElement.getBoundingClientRect();
  results.clientrectsKnownDimensions = JSON.stringify(
    serializeDOMRect(knownRect)
  );

  const ghostElement = document.createElement("div");
  ghostElement.style.cssText = "width: 0; height: 0;";
  container.appendChild(ghostElement);
  const ghostRect = ghostElement.getBoundingClientRect();
  results.clientrectsGhostDimensions = JSON.stringify(
    serializeDOMRect(ghostRect)
  );

  results.clientrectsTextFontFamily = getComputedStyle(knownElement).fontFamily;

  const emojiDiv = document.createElement("div");
  emojiDiv.style.cssText = "font-size: 200px;";
  container.appendChild(emojiDiv);

  const emojis = ["ðŸ‘¾", "ðŸ¤–", "ðŸ¦„", "ðŸŽƒ", "ðŸŽ¨", "ðŸŒˆ"];

  for (let i = 0; i < emojis.length; i++) {
    emojiDiv.textContent = emojis[i];
    const rect = emojiDiv.getBoundingClientRect();
    const metricNum = String(i + 1).padStart(2, "0");
    results[`clientrectsEmoji${metricNum}`] = JSON.stringify(
      serializeDOMRect(rect)
    );
  }
  results.clientrectsEmojiFontFamily = getComputedStyle(emojiDiv).fontFamily;

  document.body.removeChild(container);

  return results;
}

async function populateNavigatorProperties() {
  return {
    oscpu: navigator.oscpu,
    pdfViewer: navigator.pdfViewerEnabled,
    platform: navigator.platform,
  };
}

async function populatePointerInfo() {
  const capabilities = {
    None: 0,
    Coarse: 1 << 0,
    Fine: 1 << 1,
  };

  const q = {
    isCoarse: matchMedia("(pointer: coarse)").matches,
    isFine: matchMedia("(pointer: fine)").matches,
    isAnyCoarse: matchMedia("(any-pointer: coarse)").matches,
    isAnyFine: matchMedia("(any-pointer: fine)").matches,
  };

  
  
  let pointerType;
  if (q.isCoarse) {
    pointerType = capabilities.Coarse;
  } else {
    pointerType = q.isFine ? capabilities.Fine : capabilities.None;
  }

  
  
  const anyPointerType =
    (q.isAnyCoarse && capabilities.Coarse) | (q.isAnyFine && capabilities.Fine);

  return {
    pointerType,
    anyPointerType,
  };
}

async function populateICEFoundations() {
  
  if (window.location.hash === "#automation") {
    debug("Skipping ICE Foundations for automation");
    return {};
  }

  function getFoundationsAndLatencies() {
    const { promise, resolve, reject } = Promise.withResolvers();

    
    
    
    
    const result = {
      latencies: [],
      foundations: [],
    };

    let lastTime;
    function calculateLatency() {
      const now = window.performance.now();
      const latency = window.performance.now() - lastTime;
      lastTime = now;
      return latency;
    }

    const pc = new RTCPeerConnection();
    pc.onicecandidate = e => {
      const latency = calculateLatency();
      if (e.candidate && e.candidate.candidate !== "") {
        result.latencies.push(latency);
        result.foundations.push(e.candidate.foundation);
      }
    };
    pc.onicegatheringstatechange = () => {
      if (pc.iceGatheringState !== "complete") {
        return;
      }
      pc.close();
      resolve(result);
    };

    pc.createOffer({ offerToReceiveAudio: 1 })
      .then(desc => {
        pc.setLocalDescription(desc);
        lastTime = window.performance.now();
      })
      .catch(reject);

    
    const timeout = setTimeout(() => {
      pc.close();
      resolve(result);
    }, 5000);

    return promise.then(res => {
      clearTimeout(timeout);
      return res;
    });
  }

  
  
  const latencies = [];
  const foundations = {};
  for (let i = 0; i < 10; i++) {
    const result = await getFoundationsAndLatencies();

    latencies.push(result.latencies);

    const hostFoundations = result.foundations.join("");
    if (hostFoundations) {
      foundations[hostFoundations] = (foundations[hostFoundations] ?? 0) + 1;
    }
  }

  const sdLatencies = [];
  for (let i = 0; i < (latencies?.[0]?.length ?? 0); i++) {
    sdLatencies.push(standardDeviation(latencies.map(a => a[i])));
  }

  const sd =
    sdLatencies.length > 1
      ? (sdLatencies.reduce((acc, val) => acc + val, 0) / sdLatencies.length) *
        1000
      : 0;

  return {
    iceSd: sd,
    iceOrder: Object.keys(foundations).length,
  };
}

async function populateSensorInfo() {
  const { promise, resolve } = Promise.withResolvers();

  const events = {
    devicemotion: 0,
    deviceorientation: 0,
    deviceorientationabsolute: 0,
  };
  const results = {
    frequency: { ...events },
    decPlaces: { ...events },
  };

  const eventCounter = { ...events };
  const eventDecPlaces = { ...events };
  const eventStarts = { ...events };

  const processEvent = eventName => e => {
    eventCounter[eventName] += 1;

    
    
    const property =
      e.acceleration?.x || e.alpha || e.accelerationIncludingGravity?.x;
    if (!property) {
      return;
    }
    const decPlaces = decimalPlaces(property);
    eventDecPlaces[eventName] =
      eventDecPlaces[eventName] > decPlaces
        ? eventDecPlaces[eventName]
        : decPlaces;
  };
  const processResult = eventName => {
    const elapsed = (window.performance.now() - eventStarts[eventName]) / 1000;
    results.frequency[eventName] = Math.round(
      eventCounter[eventName] / elapsed
    );
    results.decPlaces[eventName] = eventDecPlaces[eventName];
  };

  const listeners = [];
  for (const eventName in events) {
    eventStarts[eventName] = window.performance.now();
    const listener = processEvent(eventName);
    window.addEventListener(eventName, listener);
    listeners.push([eventName, listener]);
    setTimeout(() => processResult(eventName), 10 * 1000);
  }

  
  setTimeout(() => {
    for (const [eventName, listener] of listeners) {
      window.removeEventListener(eventName, listener);
    }
    resolve({
      motionDecimals: results.decPlaces.devicemotion,
      orientationDecimals: results.decPlaces.deviceorientation,
      orientationabsDecimals: results.decPlaces.deviceorientationabsolute,
      motionFreq: results.frequency.devicemotion,
      orientationFreq: results.frequency.deviceorientation,
      orientationabsFreq: results.frequency.deviceorientationabsolute,
    });
  }, 11 * 1000);

  return promise;
}

async function populateMathML() {
  
  
  
  

  
  const oldMathElements = [...document.querySelectorAll("math[id]")].filter(
    el => /^\d+$/.test(el.id)
  );
  const oldMetrics = oldMathElements.reduce((acc, el) => {
    acc["mathml" + el.id] = el.getBoundingClientRect().width.toString();
    return acc;
  }, {});

  
  const newMathElements = [...document.querySelectorAll("math[id^='new-']")];
  const mathmlValues = newMathElements.map(
    el => el.getBoundingClientRect().width
  );

  
  const firstMathElement = document.querySelector("math");
  const mathmlFontFamily = firstMathElement
    ? getComputedStyle(firstMathElement).fontFamily
    : "";

  return {
    ...oldMetrics,
    mathmlDiagValues: mathmlValues,
    mathmlDiagFontFamily: mathmlFontFamily,
  };
}

async function populateAudioDeviceProperties() {
  const ctx = new AudioContext();

  try {
    
    await Promise.race([
      ctx.resume(),
      new Promise((_, reject) =>
        setTimeout(
          () => reject(new Error("AudioContext.resume() timeout")),
          5000
        )
      ),
    ]);
  } catch (e) {
    throw new Error(
      "AudioContext.resume error, probably a timeout, user may not have audio hardware"
    );
  }

  
  await new Promise(resolve => setTimeout(resolve, 2000));

  
  
  const result = {
    audioFrames: ctx.outputLatency * ctx.sampleRate,
    audioRate: ctx.sampleRate,
    audioChannels: ctx.destination.maxChannelCount,
  };
  return result;
}

async function populateTimezoneWeb() {
  try {
    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const offset = new Date().getTimezoneOffset();
    return {
      timezoneWeb: timezone || "",
      timezoneOffsetWeb: offset,
    };
  } catch (e) {
    return {
      timezoneWeb: "",
      timezoneOffsetWeb: 0,
    };
  }
}



function getCanvasSources() {
  const canvasSources = [populateWebGLCanvases];

  
  return canvasSources
    .map(source => {
      const functions = [
        async () => source({ forceSoftwareRendering: true }),
        async () => source({ forceSoftwareRendering: false }),
      ];

      
      
      Object.defineProperty(functions[0], "name", {
        value: source.name + "Software",
      });
      Object.defineProperty(functions[1], "name", {
        value: source.name,
      });
      return functions;
    })
    .flat();
}





const LocalFiraSans = new FontFace(
  "LocalFiraSans",
  "url('chrome://global/content/usercharacteristics/usercharacteristics.woff') format('woff')"
);

if (document.readyState === "loading") {
  window.addEventListener("load", startPopulating);
} else {
  startPopulating();
}

async function startPopulating() {
  const errors = [];

  await LocalFiraSans.load()
    .then(font => document.fonts.add(font))
    .catch(async e => {
      
      errors.push(`LocalFiraSans: ${await stringifyError(e)}`);
    });

  
  
  
  const data = {};
  const sources = [
    ...getCanvasSources(),
    populateVoiceList,
    populateMediaCapabilities,
    populateAudioFingerprint,
    populatePointerInfo,
    populateICEFoundations,
    populateSensorInfo,
    populateMathML,
    populateCSSQueries,
    populateCSSSystemColors,
    populateCSSSystemFonts,
    populateClientRects,
    populateNavigatorProperties,
    populateAudioDeviceProperties,
    populateTimezoneWeb,
  ];
  
  
  
  for (const source of sources) {
    try {
      Object.assign(data, await timeoutPromise(source(), 5 * 60 * 1000));
    } catch (error) {
      errors.push(`${source.name}: ${await stringifyError(error)}`);
    }
  }

  debug("Awaiting", Object.keys(data).length, "data promises.");
  await Promise.allSettled(Object.values(data));

  debug("Sizes of extractions:");
  const output = new Map();
  for (const key in data) {
    try {
      let outputValue = await data[key];
      output.set(key, outputValue);
      debug(key, output.get(key) ? output.get(key).length : "null");
    } catch (e) {
      debug("Promise rejected for", key, "Error:", e);
      errors.push(`${key}: ${await stringifyError(e)}`);
    }
  }
  output.jsErrors = JSON.stringify(errors);

  document.dispatchEvent(
    new CustomEvent("UserCharacteristicsDataDone", {
      bubbles: true,
      detail: {
        debug: debugMsgs,
        output,
      },
    })
  );
}
