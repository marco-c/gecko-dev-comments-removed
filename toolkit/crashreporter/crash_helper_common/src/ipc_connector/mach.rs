



use std::{
    ffi::{CStr, CString},
    thread,
};

use mach2::{
    bootstrap::{bootstrap_port, name_t, BOOTSTRAP_SUCCESS},
    kern_return::kern_return_t,
    message::{
        mach_msg_port_descriptor_t, MACH_MSGH_BITS, MACH_MSGH_BITS_REMOTE_MASK,
        MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND, MACH_MSG_TYPE_MOVE_RECEIVE,
        MACH_MSG_TYPE_MOVE_SEND,
    },
    port::{mach_port_t, MACH_PORT_NULL},
};

use crate::{
    errors::IPCError,
    mach_msg_recv,
    messages::{self, Message, MessageError},
    platform::{
        mach::{mach_msg_send, AsRawPort, MachMessageWrapper, ReceiveRight, SendRight},
        OwnedRight, PlatformError,
    },
    ProcessHandle,
};

unsafe extern "C" {
    fn bootstrap_register(
        bp: mach_port_t,
        service_name: *const i8,
        sp: mach_port_t,
    ) -> kern_return_t;
    fn bootstrap_look_up(
        bp: mach_port_t,
        service_name: *const i8,
        sp: *mut mach_port_t,
    ) -> kern_return_t;
}

pub type AncillaryData = OwnedRight;
pub const CONNECTOR_ANCILLARY_DATA_LEN: usize = 2;

#[repr(C)]
pub struct RawIPCConnector {
    pub send: mach_port_t,
    pub recv: mach_port_t,
}

pub type IPCConnectorKey = mach_port_t;

pub struct IPCConnector {
    send: SendRight,
    recv: ReceiveRight,
}

impl IPCConnector {
    pub(crate) fn from_rights(send: SendRight, recv: ReceiveRight) -> IPCConnector {
        IPCConnector { send, recv }
    }

    pub fn from_ancillary(
        ancillary_data: [AncillaryData; CONNECTOR_ANCILLARY_DATA_LEN],
    ) -> Result<IPCConnector, IPCError> {
        let mut iter = ancillary_data.into_iter();
        let OwnedRight::Send(send) = iter.next().unwrap() else {
            return Err(IPCError::InvalidAncillary);
        };
        let OwnedRight::Receive(recv) = iter.next().unwrap() else {
            return Err(IPCError::InvalidAncillary);
        };

        Ok(IPCConnector { send, recv })
    }

    
    
    
    
    
    
    
    
    pub unsafe fn from_raw_connector(connector: RawIPCConnector) -> Result<IPCConnector, IPCError> {
        let send = SendRight::from_raw_port(connector.send);
        let recv = ReceiveRight::from_raw_port(connector.recv);
        Ok(IPCConnector::from_rights(send, recv))
    }

    pub fn set_process(&mut self, _process: ProcessHandle) {}

    
    
    
    
    
    
    
    
    pub fn serialize(self) -> Result<CString, IPCError> {
        let send_right = self.send;
        let recv_right = self.recv;
        let service_receive_right = ReceiveRight::new().map_err(IPCError::Serialize)?;

        const ATTEMPTS: u32 = 5;

        
        
        

        let mut i = ATTEMPTS;
        loop {
            
            
            
            let random_id =
                getrandom::u64().map_err(|e| IPCError::Serialize(PlatformError::GetRandom(e)))?;
            let name = format!("org.mozilla.crashhelper.{}", random_id);

            
            
            assert!(name.len() < size_of::<name_t>());

            
            let cname = unsafe { CString::from_vec_unchecked(name.clone().into_bytes()) };
            
            
            let rv = unsafe {
                bootstrap_register(
                    bootstrap_port,
                    cname.as_ptr(),
                    service_receive_right.as_raw_port(),
                )
            };

            if rv as u32 != BOOTSTRAP_SUCCESS {
                if i == 0 {
                    return Err(IPCError::Serialize(PlatformError::BootstrapRegister(rv)));
                } else {
                    i -= 1;
                    continue;
                }
            }

            
            
            let _ = thread::spawn(move || {
                let msg = match mach_msg_recv(&service_receive_right, 0, 0) {
                    Ok(msg) => msg,
                    Err(err) => {
                        log::error!(
                            "No reply from crash helper, mach_msg_recv() failed with = {err}",
                        );
                        return;
                    }
                };

                let header = msg.header();

                if (header.msgh_bits & MACH_MSGH_BITS_REMOTE_MASK) != MACH_MSG_TYPE_MOVE_SEND {
                    log::error!("Wrong or no send rend right received from the crash helper");
                    return;
                }

                
                let reply_port = unsafe { SendRight::from_raw_port(header.msgh_remote_port) };
                let mut msg = MachMessageWrapper::for_send(0, 2);
                let descriptors = msg.descriptors_mut();
                descriptors[0] = mach_msg_port_descriptor_t::new(
                    send_right.into_raw_port(),
                    MACH_MSG_TYPE_MOVE_SEND,
                );
                descriptors[1] = mach_msg_port_descriptor_t::new(
                    recv_right.into_raw_port(),
                    MACH_MSG_TYPE_MOVE_RECEIVE,
                );

                if let Err(err) = mach_msg_send(&reply_port, &mut msg) {
                    log::error!(
                            "Could not send right to the crash helper, mach_msg_recv() failed with = {err}",
                        );
                }
            });

            return Ok(cname);
        }
    }

    
    
    pub fn deserialize(string: &CStr) -> Result<IPCConnector, IPCError> {
        let mut service_port = MACH_PORT_NULL;
        let rv = unsafe { bootstrap_look_up(bootstrap_port, string.as_ptr(), &mut service_port) };

        if rv as u32 != BOOTSTRAP_SUCCESS {
            return Err(IPCError::Deserialize(PlatformError::BootstrapLookUp(rv)));
        }

        
        let service_port = unsafe { SendRight::from_raw_port(service_port) };
        let reply_port = ReceiveRight::new().map_err(IPCError::Deserialize)?;

        
        
        let mut msg = MachMessageWrapper::for_send(0, 0);
        let header = msg.header_mut();
        header.msgh_bits |= MACH_MSGH_BITS(0, MACH_MSG_TYPE_MAKE_SEND);
        header.msgh_local_port = reply_port.as_raw_port();
        mach_msg_send(&service_port, &mut msg).map_err(IPCError::CreationFailure)?;

        
        let res = mach_msg_recv(&reply_port, 0, 2).map_err(IPCError::CreationFailure)?;
        let descriptors = res.descriptors();
        veryify_descriptors(descriptors)?;

        
        let send_right = unsafe { SendRight::from_raw_port(descriptors[0].name) };
        
        let recv_right = unsafe { ReceiveRight::from_raw_port(descriptors[1].name) };
        Ok(IPCConnector::from_rights(send_right, recv_right))
    }

    pub fn into_ancillary(self) -> [AncillaryData; CONNECTOR_ANCILLARY_DATA_LEN] {
        [OwnedRight::Send(self.send), OwnedRight::Receive(self.recv)]
    }

    pub fn into_raw_connector(self) -> RawIPCConnector {
        RawIPCConnector {
            send: self.send.into_raw_port(),
            recv: self.recv.into_raw_port(),
        }
    }

    pub fn key(&self) -> IPCConnectorKey {
        self.raw_recv_right()
    }

    
    
    pub(crate) fn raw_recv_right(&self) -> mach_port_t {
        self.recv.as_raw_port()
    }

    pub fn send_message<T>(&self, message: T) -> Result<(), IPCError>
    where
        T: Message,
    {
        let expected_payload_len = message.payload_size();
        let expected_ancillary_len = message.ancillary_data_len();
        self.send(&message.header(), vec![])
            .map_err(IPCError::TransmissionFailure)?;
        let (payload, ancillary_data) = message.into_payload();
        assert!(payload.len() == expected_payload_len);
        assert!(ancillary_data.len() == expected_ancillary_len);
        self.send(&payload, ancillary_data)
            .map_err(IPCError::TransmissionFailure)
    }

    pub fn recv_reply<T>(&self) -> Result<T, IPCError>
    where
        T: Message,
    {
        let header = self.recv_header()?;

        if header.kind != T::kind() {
            return Err(IPCError::UnexpectedMessage(header.kind));
        }

        let (data, ancillary_data) = self.recv(header.size)?;
        T::decode(&data, ancillary_data).map_err(IPCError::from)
    }

    
    fn send(&self, buff: &[u8], rights: Vec<AncillaryData>) -> Result<(), PlatformError> {
        let mut msg = MachMessageWrapper::for_send(
            buff.len(),
            rights
                .len()
                .try_into()
                .map_err(|_| PlatformError::ValueTooLarge)?,
        );

        
        
        msg.data_mut()[0..buff.len()].copy_from_slice(buff);

        let descriptors = msg.descriptors_mut();

        for (i, right) in rights.into_iter().enumerate() {
            descriptors[i] = match right {
                OwnedRight::Receive(recv) => mach_msg_port_descriptor_t::new(
                    recv.into_raw_port(),
                    MACH_MSG_TYPE_MOVE_RECEIVE,
                ),
                OwnedRight::Send(send) => {
                    mach_msg_port_descriptor_t::new(send.into_raw_port(), MACH_MSG_TYPE_MOVE_SEND)
                }
            };
        }

        mach_msg_send(&self.send, &mut msg)
    }

    pub(crate) fn recv_header(&self) -> Result<messages::Header, IPCError> {
        let (header, _) = self.recv(messages::HEADER_SIZE)?;
        messages::Header::decode(&header).map_err(IPCError::BadMessage)
    }

    
    pub(crate) fn recv(
        &self,
        expected_size: usize,
    ) -> Result<(Vec<u8>, Vec<AncillaryData>), IPCError> {
        let msg = mach_msg_recv(
            &self.recv,
            expected_size,
            CONNECTOR_ANCILLARY_DATA_LEN as u32,
        )
        .map_err(IPCError::ReceptionFailure)?;

        let data = &msg.data()[0..expected_size];
        let mut ancillary_data = vec![];
        for descriptor in msg.descriptors() {
            let name = descriptor.name;
            let right = match descriptor.disposition as u32 {
                MACH_MSG_TYPE_MOVE_RECEIVE => {
                    
                    OwnedRight::Receive(unsafe { ReceiveRight::from_raw_port(name) })
                }
                MACH_MSG_TYPE_MOVE_SEND => {
                    
                    OwnedRight::Send(unsafe { SendRight::from_raw_port(name) })
                }
                MACH_MSG_TYPE_COPY_SEND => {
                    
                    OwnedRight::Send(unsafe { SendRight::from_raw_port(name) })
                }
                _ => return Err(IPCError::InvalidAncillary),
            };

            ancillary_data.push(right);
        }

        Ok((Vec::from(data), ancillary_data))
    }
}

fn veryify_descriptors(descriptors: &[mach_msg_port_descriptor_t]) -> Result<(), MessageError> {
    if (descriptors[0].disposition == MACH_MSG_TYPE_MOVE_SEND as u8)
        && (descriptors[1].disposition == MACH_MSG_TYPE_MOVE_RECEIVE as u8)
    {
        Ok(())
    } else {
        Err(MessageError::InvalidData)
    }
}
