





import {
  firstValueFrom,
  from,
  merge,
  raceWith,
} from '../../third_party/rxjs/rxjs.js';
import type {
  Cookie,
  CookieData,
  DeleteCookiesRequest,
} from '../common/Cookie.js';
import {EventEmitter, type EventType} from '../common/EventEmitter.js';
import {
  debugError,
  fromEmitterEvent,
  filterAsync,
  timeout,
} from '../common/util.js';
import {asyncDisposeSymbol, disposeSymbol} from '../util/disposable.js';
import {Mutex} from '../util/Mutex.js';

import type {
  Browser,
  CreatePageOptions,
  Permission,
  WaitForTargetOptions,
} from './Browser.js';
import type {Page} from './Page.js';
import type {Target} from './Target.js';




export const enum BrowserContextEvent {
  



  TargetChanged = 'targetchanged',

  







  TargetCreated = 'targetcreated',
  



  TargetDestroyed = 'targetdestroyed',
}




export interface BrowserContextEvents extends Record<EventType, unknown> {
  [BrowserContextEvent.TargetChanged]: Target;
  [BrowserContextEvent.TargetCreated]: Target;
  [BrowserContextEvent.TargetDestroyed]: Target;
}








































export abstract class BrowserContext extends EventEmitter<BrowserContextEvents> {
  


  constructor() {
    super();
  }

  



  abstract targets(): Target[];

  


  #pageScreenshotMutex?: Mutex;
  #screenshotOperationsCount = 0;

  


  startScreenshot(): Promise<InstanceType<typeof Mutex.Guard>> {
    const mutex = this.#pageScreenshotMutex || new Mutex();
    this.#pageScreenshotMutex = mutex;
    this.#screenshotOperationsCount++;
    return mutex.acquire(() => {
      this.#screenshotOperationsCount--;
      if (this.#screenshotOperationsCount === 0) {
        
        this.#pageScreenshotMutex = undefined;
      }
    });
  }

  


  waitForScreenshotOperations():
    | Promise<InstanceType<typeof Mutex.Guard>>
    | undefined {
    return this.#pageScreenshotMutex?.acquire();
  }

  














  async waitForTarget(
    predicate: (x: Target) => boolean | Promise<boolean>,
    options: WaitForTargetOptions = {},
  ): Promise<Target> {
    const {timeout: ms = 30000} = options;
    return await firstValueFrom(
      merge(
        fromEmitterEvent(this, BrowserContextEvent.TargetCreated),
        fromEmitterEvent(this, BrowserContextEvent.TargetChanged),
        from(this.targets()),
      ).pipe(filterAsync(predicate), raceWith(timeout(ms))),
    );
  }

  








  abstract pages(includeAll?: boolean): Promise<Page[]>;

  


















  abstract overridePermissions(
    origin: string,
    permissions: Permission[],
  ): Promise<void>;

  













  abstract clearPermissionOverrides(): Promise<void>;

  



  abstract newPage(options?: CreatePageOptions): Promise<Page>;

  



  abstract browser(): Browser;

  







  abstract close(): Promise<void>;

  


  abstract cookies(): Promise<Cookie[]>;

  


  abstract setCookie(...cookies: CookieData[]): Promise<void>;

  




  async deleteCookie(...cookies: Cookie[]): Promise<void> {
    return await this.setCookie(
      ...cookies.map(cookie => {
        return {
          ...cookie,
          expires: 1,
        };
      }),
    );
  }

  




  async deleteMatchingCookies(
    ...filters: DeleteCookiesRequest[]
  ): Promise<void> {
    const cookies = await this.cookies();
    const cookiesToDelete = cookies.filter(cookie => {
      return filters.some(filter => {
        if (filter.name === cookie.name) {
          if (filter.domain !== undefined && filter.domain === cookie.domain) {
            return true;
          }

          if (filter.path !== undefined && filter.path === cookie.path) {
            return true;
          }
          if (
            filter.partitionKey !== undefined &&
            cookie.partitionKey !== undefined
          ) {
            if (typeof cookie.partitionKey !== 'object') {
              throw new Error('Unexpected string partition key');
            }
            if (typeof filter.partitionKey === 'string') {
              if (filter.partitionKey === cookie.partitionKey?.sourceOrigin) {
                return true;
              }
            } else {
              if (
                filter.partitionKey.sourceOrigin ===
                cookie.partitionKey?.sourceOrigin
              ) {
                return true;
              }
            }
          }
          if (filter.url !== undefined) {
            const url = new URL(filter.url);
            if (
              url.hostname === cookie.domain &&
              url.pathname === cookie.path
            ) {
              return true;
            }
          }
          return true;
        }
        return false;
      });
    });
    await this.deleteCookie(...cookiesToDelete);
  }

  


  get closed(): boolean {
    return !this.browser().browserContexts().includes(this);
  }

  


  get id(): string | undefined {
    return undefined;
  }

  
  override [disposeSymbol](): void {
    return void this.close().catch(debugError);
  }

  
  [asyncDisposeSymbol](): Promise<void> {
    return this.close();
  }
}
