





declare global {
  interface SymbolConstructor {
    



    readonly dispose: unique symbol;

    



    readonly asyncDispose: unique symbol;
  }

  interface Disposable {
    [Symbol.dispose](): void;
  }

  interface AsyncDisposable {
    [Symbol.asyncDispose](): PromiseLike<void>;
  }
}

(Symbol as any).dispose ??= Symbol('dispose');
(Symbol as any).asyncDispose ??= Symbol('asyncDispose');




export const disposeSymbol: typeof Symbol.dispose = Symbol.dispose;




export const asyncDisposeSymbol: typeof Symbol.asyncDispose =
  Symbol.asyncDispose;




export class DisposableStackPolyfill {
  #disposed = false;
  #stack: Disposable[] = [];

  


  get disposed(): boolean {
    return this.#disposed;
  }

  


  dispose(): void {
    this[disposeSymbol]();
  }

  







  use<T extends Disposable | null | undefined>(value: T): T {
    if (value && typeof value[disposeSymbol] === 'function') {
      this.#stack.push(value);
    }
    return value;
  }

  







  adopt<T>(value: T, onDispose: (value: T) => void): T {
    this.#stack.push({
      [disposeSymbol]() {
        onDispose(value);
      },
    });
    return value;
  }

  



  defer(onDispose: () => void): void {
    this.#stack.push({
      [disposeSymbol]() {
        onDispose();
      },
    });
  }

  
































  move(): DisposableStackPolyfill {
    if (this.#disposed) {
      throw new ReferenceError('A disposed stack can not use anything new');
    }
    const stack = new DisposableStackPolyfill();
    stack.#stack = this.#stack;
    this.#stack = [];
    this.#disposed = true;
    return stack;
  }

  


  [disposeSymbol](): void {
    if (this.#disposed) {
      return;
    }
    this.#disposed = true;
    const errors: unknown[] = [];
    for (const resource of this.#stack.reverse()) {
      try {
        resource[disposeSymbol]();
      } catch (e) {
        errors.push(e);
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    } else if (errors.length > 1) {
      let suppressed = null;
      for (const error of errors) {
        if (suppressed === null) {
          suppressed = error;
        } else {
          suppressed = new SuppressedErrorPolyfill(error, suppressed);
        }
      }
      throw suppressed;
    }
  }

  readonly [Symbol.toStringTag] = 'DisposableStack';
}




export const DisposableStack: typeof DisposableStackPolyfill =
  (globalThis.DisposableStack as any) ?? DisposableStackPolyfill;




export class AsyncDisposableStackPolyfill {
  #disposed = false;
  #stack: AsyncDisposable[] = [];

  


  get disposed(): boolean {
    return this.#disposed;
  }

  


  async disposeAsync(): Promise<void> {
    await this[asyncDisposeSymbol]();
  }

  







  use<T extends AsyncDisposable | Disposable | null | undefined>(value: T): T {
    if (value) {
      const asyncDispose = (value as AsyncDisposable)[asyncDisposeSymbol];
      const dispose = (value as Disposable)[disposeSymbol];

      if (typeof asyncDispose === 'function') {
        this.#stack.push(value as AsyncDisposable);
      } else if (typeof dispose === 'function') {
        this.#stack.push({
          [asyncDisposeSymbol]: async () => {
            (value as Disposable)[disposeSymbol]();
          },
        });
      }
    }

    return value;
  }

  







  adopt<T>(value: T, onDispose: (value: T) => Promise<void>): T {
    this.#stack.push({
      [asyncDisposeSymbol]() {
        return onDispose(value);
      },
    });
    return value;
  }

  



  defer(onDispose: () => Promise<void>): void {
    this.#stack.push({
      [asyncDisposeSymbol]() {
        return onDispose();
      },
    });
  }

  
































  move(): AsyncDisposableStackPolyfill {
    if (this.#disposed) {
      throw new ReferenceError('A disposed stack can not use anything new');
    }
    const stack = new AsyncDisposableStackPolyfill();
    stack.#stack = this.#stack;
    this.#stack = [];
    this.#disposed = true;
    return stack;
  }

  


  async [asyncDisposeSymbol](): Promise<void> {
    if (this.#disposed) {
      return;
    }
    this.#disposed = true;
    const errors: unknown[] = [];
    for (const resource of this.#stack.reverse()) {
      try {
        await resource[asyncDisposeSymbol]();
      } catch (e) {
        errors.push(e);
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    } else if (errors.length > 1) {
      let suppressed = null;
      for (const error of errors) {
        if (suppressed === null) {
          suppressed = error;
        } else {
          suppressed = new SuppressedErrorPolyfill(error, suppressed);
        }
      }
      throw suppressed;
    }
  }

  readonly [Symbol.toStringTag] = 'AsyncDisposableStack';
}




export const AsyncDisposableStack: typeof AsyncDisposableStackPolyfill =
  (globalThis.AsyncDisposableStack as any) ?? AsyncDisposableStackPolyfill;







class SuppressedErrorPolyfill extends Error {
  #error: unknown;
  #suppressed: unknown;

  constructor(
    error: unknown,
    suppressed: unknown,
    message = 'An error was suppressed during disposal',
  ) {
    super(message);
    this.name = 'SuppressedError';
    this.#error = error;
    this.#suppressed = suppressed;
  }

  


  get error(): unknown {
    return this.#error;
  }

  



  get suppressed(): unknown {
    return this.#suppressed;
  }
}




export const SuppressedError: typeof SuppressedErrorPolyfill =
  (globalThis.SuppressedError as any) ?? SuppressedErrorPolyfill;
