




const createdFunctions = new Map<string, (...args: unknown[]) => unknown>();






export const createFunction = (
  functionValue: string,
): ((...args: unknown[]) => unknown) => {
  let fn = createdFunctions.get(functionValue);
  if (fn) {
    return fn;
  }
  fn = new Function(`return ${functionValue}`)() as (
    ...args: unknown[]
  ) => unknown;
  createdFunctions.set(functionValue, fn);
  return fn;
};




export function stringifyFunction(fn: (...args: never) => unknown): string {
  let value = fn.toString();
  if (
    value.match(/^(async )*function(\(|\s)/) ||
    value.match(/^(async )*function\s*\*\s*/)
  ) {
    return value;
  }
  const isArrow =
    value.startsWith('(') ||
    value.match(/^async\s*\(/) ||
    value.match(
      /^(async)*\s*(?:[$_\p{ID_Start}])(?:[$\u200C\u200D\p{ID_Continue}])*\s*=>/u,
    );
  if (isArrow) {
    return value;
  }
  
  
  let prefix = 'function ';
  if (value.startsWith('async ')) {
    prefix = `async ${prefix}`;
    value = value.substring('async '.length);
  }
  return `${prefix}${value}`;
}















export const interpolateFunction = <T extends (...args: never[]) => unknown>(
  fn: T,
  replacements: Record<string, string>,
): T => {
  let value = stringifyFunction(fn);
  for (const [name, jsValue] of Object.entries(replacements)) {
    value = value.replace(
      new RegExp(`PLACEHOLDER\\(\\s*(?:'${name}'|"${name}")\\s*\\)`, 'g'),
      
      
      
      `(${jsValue})`,
    );
  }
  return createFunction(value) as unknown as T;
};

declare global {
  




  function PLACEHOLDER<T>(name: string): T;
}
