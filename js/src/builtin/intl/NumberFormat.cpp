







#include "builtin/intl/NumberFormat.h"

#include "mozilla/Assertions.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/intl/Locale.h"
#include "mozilla/intl/MeasureUnit.h"
#include "mozilla/intl/MeasureUnitGenerated.h"
#include "mozilla/intl/NumberFormat.h"
#include "mozilla/intl/NumberingSystem.h"
#include "mozilla/intl/NumberRangeFormat.h"
#include "mozilla/intl/PluralRules.h"
#include "mozilla/Span.h"
#include "mozilla/TextUtils.h"

#include <algorithm>
#include <stddef.h>
#include <stdint.h>
#include <string>
#include <string_view>
#include <type_traits>

#include "builtin/Array.h"
#include "builtin/intl/CommonFunctions.h"
#include "builtin/intl/CurrencyDataGenerated.h"
#include "builtin/intl/FormatBuffer.h"
#include "builtin/intl/LanguageTag.h"
#include "builtin/intl/LocaleNegotiation.h"
#include "builtin/intl/ParameterNegotiation.h"
#include "builtin/intl/PluralRules.h"
#include "builtin/intl/RelativeTimeFormat.h"
#include "builtin/intl/UsingEnum.h"
#include "builtin/Number.h"
#include "gc/GCContext.h"
#include "js/CharacterEncoding.h"
#include "js/PropertySpec.h"
#include "js/RootingAPI.h"
#include "js/TypeDecls.h"
#include "util/Text.h"
#include "vm/BigIntType.h"
#include "vm/GlobalObject.h"
#include "vm/JSContext.h"
#include "vm/PlainObject.h"  
#include "vm/StringType.h"

#include "vm/GeckoProfiler-inl.h"
#include "vm/JSObject-inl.h"
#include "vm/NativeObject-inl.h"

using namespace js;
using namespace js::intl;

const JSClassOps NumberFormatObject::classOps_ = {
    nullptr,                       
    nullptr,                       
    nullptr,                       
    nullptr,                       
    nullptr,                       
    nullptr,                       
    NumberFormatObject::finalize,  
    nullptr,                       
    nullptr,                       
    nullptr,                       
};

const JSClass NumberFormatObject::class_ = {
    "Intl.NumberFormat",
    JSCLASS_HAS_RESERVED_SLOTS(NumberFormatObject::SLOT_COUNT) |
        JSCLASS_HAS_CACHED_PROTO(JSProto_NumberFormat) |
        JSCLASS_BACKGROUND_FINALIZE,
    &NumberFormatObject::classOps_,
    &NumberFormatObject::classSpec_,
};

const JSClass& NumberFormatObject::protoClass_ = PlainObject::class_;

static bool numberFormat_supportedLocalesOf(JSContext* cx, unsigned argc,
                                            Value* vp);

static bool numberFormat_format(JSContext* cx, unsigned argc, Value* vp);

static bool numberFormat_formatToParts(JSContext* cx, unsigned argc, Value* vp);

static bool numberFormat_formatRange(JSContext* cx, unsigned argc, Value* vp);

static bool numberFormat_formatRangeToParts(JSContext* cx, unsigned argc,
                                            Value* vp);

static bool numberFormat_resolvedOptions(JSContext* cx, unsigned argc,
                                         Value* vp);

static bool numberFormat_toSource(JSContext* cx, unsigned argc, Value* vp) {
  CallArgs args = CallArgsFromVp(argc, vp);
  args.rval().setString(cx->names().NumberFormat);
  return true;
}

static const JSFunctionSpec numberFormat_static_methods[] = {
    JS_FN("supportedLocalesOf", numberFormat_supportedLocalesOf, 1, 0),
    JS_FS_END,
};

static const JSFunctionSpec numberFormat_methods[] = {
    JS_FN("resolvedOptions", numberFormat_resolvedOptions, 0, 0),
    JS_FN("formatToParts", numberFormat_formatToParts, 1, 0),
    JS_FN("formatRange", numberFormat_formatRange, 2, 0),
    JS_FN("formatRangeToParts", numberFormat_formatRangeToParts, 2, 0),
    JS_FN("toSource", numberFormat_toSource, 0, 0),
    JS_FS_END,
};

static const JSPropertySpec numberFormat_properties[] = {
    JS_PSG("format", numberFormat_format, 0),
    JS_STRING_SYM_PS(toStringTag, "Intl.NumberFormat", JSPROP_READONLY),
    JS_PS_END,
};

static bool NumberFormat(JSContext* cx, unsigned argc, Value* vp);

const ClassSpec NumberFormatObject::classSpec_ = {
    GenericCreateConstructor<NumberFormat, 0, gc::AllocKind::FUNCTION>,
    GenericCreatePrototype<NumberFormatObject>,
    numberFormat_static_methods,
    nullptr,
    numberFormat_methods,
    numberFormat_properties,
    nullptr,
    ClassSpec::DontDefineConstructor,
};







static constexpr bool IsWellFormedNormalizedCurrencyCode(
    std::string_view currency) {
  return currency.length() == 3 &&
         std::all_of(currency.begin(), currency.end(),
                     mozilla::IsAsciiUppercaseAlpha<char>);
}

#ifdef DEBUG






static constexpr bool IsWellFormedNormalizedCurrencyCode(
    const NumberFormatUnitOptions::Currency& currency) {
  return IsWellFormedNormalizedCurrencyCode(
      std::string_view{currency.code, std::size(currency.code)});
}
#endif




static constexpr int32_t CurrencyHash(std::string_view currency) {
  MOZ_ASSERT(IsWellFormedNormalizedCurrencyCode(currency));

  
  
  
  
  
  
  
  return ((currency[0] - 'A') << 10) | ((currency[1] - 'A') << 5) |
         ((currency[2] - 'A') << 0);
}

constexpr auto operator""_curr(const char* code, size_t n) {
  return CurrencyHash({code, n});
}






static int32_t CurrencyDigits(
    const NumberFormatUnitOptions::Currency& currency) {
  
  MOZ_ASSERT(IsWellFormedNormalizedCurrencyCode(currency));

  
  switch (CurrencyHash(currency.code)) {
#define CURRENCY(currency, digits) \
  case #currency##_curr:           \
    return digits;
    CURRENCIES_WITH_NON_DEFAULT_DIGITS(CURRENCY)
#undef CURRENCY
    default:
      break;
  }

  
  return 2;
}






static bool ToWellFormedCurrencyCode(
    JSContext* cx, Handle<JSString*> currency,
    NumberFormatUnitOptions::Currency* result) {
  static constexpr size_t CurrencyLength = 3;

  static_assert(std::extent_v<decltype(result->code)> == CurrencyLength);

  
  if (currency->length() == CurrencyLength) {
    auto* linear = currency->ensureLinear(cx);
    if (!linear) {
      return false;
    }

    if (StringIsAscii(linear)) {
      
      char chars[CurrencyLength] = {};
      CopyChars(reinterpret_cast<JS::Latin1Char*>(chars), *linear);

      
      auto toAsciiUpperCase = [](auto ch) -> char {
        if (mozilla::IsAsciiLowercaseAlpha(ch)) {
          return ch - 0x20;
        }
        return ch;
      };
      std::transform(std::begin(chars), std::end(chars), std::begin(chars),
                     toAsciiUpperCase);

      
      std::string_view code{chars, CurrencyLength};

      
      
      
      if (IsWellFormedNormalizedCurrencyCode(code)) {
        std::copy_n(chars, CurrencyLength, result->code);
        return true;
      }
    }
  }

  if (auto chars = QuoteString(cx, currency)) {
    JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                              JSMSG_INVALID_CURRENCY_CODE, chars.get());
  }
  return false;
}




static constexpr size_t MaxUnitLength() {
  size_t length = 0;
  for (const auto& unit : mozilla::intl::simpleMeasureUnits) {
    length = std::max(length, std::char_traits<char>::length(unit.name));
  }
  return length * 2 + std::char_traits<char>::length("-per-");
}








static bool IsSanctionedSingleUnitIdentifier(std::string_view unitIdentifier) {
  return std::ranges::binary_search(
      std::begin(mozilla::intl::simpleMeasureUnits),
      std::end(mozilla::intl::simpleMeasureUnits), unitIdentifier,
      [](const auto& a, const auto& b) { return a < b; },
      [](const auto& unit) { return std::string_view{unit.name}; });
}










static bool IsWellFormedUnitIdentifier(std::string_view unitIdentifier) {
  
  if (IsSanctionedSingleUnitIdentifier(unitIdentifier)) {
    return true;
  }

  
  constexpr std::string_view separator = "-per-";
  auto pos = unitIdentifier.find(separator);

  
  if (pos == std::string_view::npos) {
    return false;
  }

  
  
  
  

  
  auto numerator = unitIdentifier.substr(0, pos);

  
  auto denominator = unitIdentifier.substr(pos + separator.length());

  
  return IsSanctionedSingleUnitIdentifier(numerator) &&
         IsSanctionedSingleUnitIdentifier(denominator);
}




static bool IsAvailableUnitIdentifier(JSContext* cx,
                                      std::string_view unitIdentifier,
                                      bool* result) {
  MOZ_ASSERT(IsWellFormedUnitIdentifier(unitIdentifier));

#if DEBUG || MOZ_SYSTEM_ICU
  auto units = mozilla::intl::MeasureUnit::GetAvailable();
  if (units.isErr()) {
    ReportInternalError(cx, units.unwrapErr());
    return false;
  }

  constexpr std::string_view separator = "-per-";

  auto numerator = unitIdentifier;
  auto denominator = unitIdentifier;

  
  auto pos = unitIdentifier.find(separator);
  if (pos != std::string_view::npos) {
    numerator = unitIdentifier.substr(0, pos);
    denominator = unitIdentifier.substr(pos + separator.length());
  }

  bool foundNumerator = false;
  bool foundDenominator = false;
  for (auto unit : units.unwrap()) {
    if (unit.isErr()) {
      ReportInternalError(cx);
      return false;
    }
    auto unitSpan = unit.unwrap();
    auto unitView = std::string_view{unitSpan.data(), unitSpan.size()};

    if (numerator == unitView) {
      foundNumerator = true;
    }
    if (denominator == unitView) {
      foundDenominator = true;
    }

    if (foundNumerator && foundDenominator) {
      *result = true;
      return true;
    }
  }

#  if MOZ_SYSTEM_ICU
  
  
  *result = false;
  return true;
#  else
  
  MOZ_ASSERT(false,
             "unitIdentifier is sanctioned but not supported. Did you forget "
             "to update intl/icu/data_filter.json to include the unit (and any "
             "implicit compound units)? For example 'speed/kilometer-per-hour' "
             "is implied by 'length/kilometer' and 'duration/hour' and must "
             "therefore also be present.");
#  endif
#else
  
  
  *result = true;
  return true;
#endif
}







static bool ToWellFormedUnitIdentifier(JSContext* cx,
                                       Handle<JSString*> unitIdentifier,
                                       NumberFormatUnitOptions::Unit* result) {
  static constexpr size_t UnitLength = MaxUnitLength();

  static_assert(std::extent_v<decltype(result->name)> > UnitLength,
                "large enough to hold the largest unit and a NUL terminator");

  if (unitIdentifier->length() <= UnitLength) {
    auto* linear = unitIdentifier->ensureLinear(cx);
    if (!linear) {
      return false;
    }

    if (StringIsAscii(linear)) {
      
      char chars[UnitLength] = {};
      CopyChars(reinterpret_cast<JS::Latin1Char*>(chars), *linear);

      
      std::string_view unit{chars, unitIdentifier->length()};

      
      if (IsWellFormedUnitIdentifier(unit)) {
        bool isAvailable;
        if (!IsAvailableUnitIdentifier(cx, unit, &isAvailable)) {
          return false;
        }
        if (isAvailable) {
          unit.copy(result->name, std::size(result->name));
          result->name[unit.length()] = '\0';
          return true;
        }
      }
    }
  }

  
  if (auto chars = QuoteString(cx, unitIdentifier)) {
    JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                              JSMSG_INVALID_UNIT_IDENTIFIER, chars.get());
  }
  return false;
}

static constexpr std::string_view RoundingModeToString(
    NumberFormatDigitOptions::RoundingMode roundingMode) {
#ifndef USING_ENUM
  using enum NumberFormatDigitOptions::RoundingMode;
#else
  USING_ENUM(NumberFormatDigitOptions::RoundingMode, Ceil, Floor, Expand, Trunc,
             HalfCeil, HalfFloor, HalfExpand, HalfTrunc, HalfEven);
#endif
  switch (roundingMode) {
    case Ceil:
      return "ceil";
    case Floor:
      return "floor";
    case Expand:
      return "expand";
    case Trunc:
      return "trunc";
    case HalfCeil:
      return "halfCeil";
    case HalfFloor:
      return "halfFloor";
    case HalfExpand:
      return "halfExpand";
    case HalfTrunc:
      return "halfTrunc";
    case HalfEven:
      return "halfEven";
  }
  MOZ_CRASH("invalid number format rounding mode");
}

static constexpr std::string_view RoundingPriorityToString(
    NumberFormatDigitOptions::RoundingPriority roundingPriority) {
#ifndef USING_ENUM
  using enum NumberFormatDigitOptions::RoundingPriority;
#else
  USING_ENUM(NumberFormatDigitOptions::RoundingPriority, Auto, MorePrecision,
             LessPrecision);
#endif
  switch (roundingPriority) {
    case Auto:
      return "auto";
    case MorePrecision:
      return "morePrecision";
    case LessPrecision:
      return "lessPrecision";
  }
  MOZ_CRASH("invalid number format rounding priority");
}

static constexpr std::string_view TrailingZeroDisplayToString(
    NumberFormatDigitOptions::TrailingZeroDisplay trailingZeroDisplay) {
#ifndef USING_ENUM
  using enum NumberFormatDigitOptions::TrailingZeroDisplay;
#else
  USING_ENUM(NumberFormatDigitOptions::TrailingZeroDisplay, Auto,
             StripIfInteger);
#endif
  switch (trailingZeroDisplay) {
    case Auto:
      return "auto";
    case StripIfInteger:
      return "stripIfInteger";
  }
  MOZ_CRASH("invalid number format trailing zero display");
}

static constexpr std::string_view NumberFormatStyleToString(
    NumberFormatUnitOptions::Style style) {
#ifndef USING_ENUM
  using enum NumberFormatUnitOptions::Style;
#else
  USING_ENUM(NumberFormatUnitOptions::Style, Decimal, Percent, Currency, Unit);
#endif
  switch (style) {
    case Decimal:
      return "decimal";
    case Percent:
      return "percent";
    case Currency:
      return "currency";
    case Unit:
      return "unit";
  }
  MOZ_CRASH("invalid number format style");
}

static constexpr std::string_view CurrencyDisplayToString(
    NumberFormatUnitOptions::CurrencyDisplay currencyDisplay) {
#ifndef USING_ENUM
  using enum NumberFormatUnitOptions::CurrencyDisplay;
#else
  USING_ENUM(NumberFormatUnitOptions::CurrencyDisplay, Symbol, NarrowSymbol,
             Code, Name);
#endif
  switch (currencyDisplay) {
    case Symbol:
      return "symbol";
    case NarrowSymbol:
      return "narrowSymbol";
    case Code:
      return "code";
    case Name:
      return "name";
  }
  MOZ_CRASH("invalid number format currency display");
}

static constexpr std::string_view CurrencySignToString(
    NumberFormatUnitOptions::CurrencySign currencySign) {
#ifndef USING_ENUM
  using enum NumberFormatUnitOptions::CurrencySign;
#else
  USING_ENUM(NumberFormatUnitOptions::CurrencySign, Standard, Accounting);
#endif
  switch (currencySign) {
    case Standard:
      return "standard";
    case Accounting:
      return "accounting";
  }
  MOZ_CRASH("invalid number format currency sign");
}

static constexpr std::string_view UnitDisplayToString(
    NumberFormatUnitOptions::UnitDisplay unitDisplay) {
#ifndef USING_ENUM
  using enum NumberFormatUnitOptions::UnitDisplay;
#else
  USING_ENUM(NumberFormatUnitOptions::UnitDisplay, Short, Narrow, Long);
#endif
  switch (unitDisplay) {
    case Short:
      return "short";
    case Narrow:
      return "narrow";
    case Long:
      return "long";
  }
  MOZ_CRASH("invalid number format unit display");
}

static constexpr std::string_view NotationToString(
    NumberFormatOptions::Notation notation) {
#ifndef USING_ENUM
  using enum NumberFormatOptions::Notation;
#else
  USING_ENUM(NumberFormatOptions::Notation, Standard, Scientific, Engineering,
             Compact);
#endif
  switch (notation) {
    case Standard:
      return "standard";
    case Scientific:
      return "scientific";
    case Engineering:
      return "engineering";
    case Compact:
      return "compact";
  }
  MOZ_CRASH("invalid number format notation");
}

static constexpr std::string_view CompactDisplayToString(
    NumberFormatOptions::CompactDisplay compactDisplay) {
#ifndef USING_ENUM
  using enum NumberFormatOptions::CompactDisplay;
#else
  USING_ENUM(NumberFormatOptions::CompactDisplay, Short, Long);
#endif
  switch (compactDisplay) {
    case Short:
      return "short";
    case Long:
      return "long";
  }
  MOZ_CRASH("invalid number format compact display");
}

enum class UseGroupingOption { Auto, Min2, Always, True, False };

static constexpr std::string_view UseGroupingOptionToString(
    UseGroupingOption useGrouping) {
#ifndef USING_ENUM
  using enum UseGroupingOption;
#else
  USING_ENUM(UseGroupingOption, Auto, Min2, Always, True, False);
#endif
  switch (useGrouping) {
    case Auto:
      return "auto";
    case Min2:
      return "min2";
    case Always:
      return "always";
    case True:
      return "true";
    case False:
      return "false";
  }
  MOZ_CRASH("invalid number format use grouping");
}

static constexpr std::string_view UseGroupingToString(
    NumberFormatOptions::UseGrouping useGrouping) {
#ifndef USING_ENUM
  using enum NumberFormatOptions::UseGrouping;
#else
  USING_ENUM(NumberFormatOptions::UseGrouping, Auto, Min2, Always, Never);
#endif
  switch (useGrouping) {
    case Auto:
      return "auto";
    case Min2:
      return "min2";
    case Always:
      return "always";
    case Never:
      return "never";
  }
  MOZ_CRASH("invalid number format use grouping");
}

static constexpr auto ToUseGroupingOption(
    NumberFormatOptions::UseGrouping useGrouping) {
#ifndef USING_ENUM
  using enum UseGroupingOption;
#else
  USING_ENUM(UseGroupingOption, Auto, Min2, Always, False);
#endif
  switch (useGrouping) {
    case NumberFormatOptions::UseGrouping::Auto:
      return Auto;
    case NumberFormatOptions::UseGrouping::Min2:
      return Min2;
    case NumberFormatOptions::UseGrouping::Always:
      return Always;
    case NumberFormatOptions::UseGrouping::Never:
      return False;
  }
  MOZ_CRASH("invalid number format use grouping");
}

static constexpr auto ToUseGrouping(
    UseGroupingOption useGrouping,
    NumberFormatOptions::UseGrouping defaultUseGrouping) {
#ifndef USING_ENUM
  using enum NumberFormatOptions::UseGrouping;
#else
  USING_ENUM(NumberFormatOptions::UseGrouping, Auto, Min2, Always);
#endif
  switch (useGrouping) {
    case UseGroupingOption::Auto:
      return Auto;
    case UseGroupingOption::Min2:
      return Min2;
    case UseGroupingOption::Always:
      return Always;
    case UseGroupingOption::True:
    case UseGroupingOption::False:
      return defaultUseGrouping;
  }
  MOZ_CRASH("invalid number format use grouping");
}

static constexpr std::string_view SignDisplayToString(
    NumberFormatOptions::SignDisplay signDisplay) {
#ifndef USING_ENUM
  using enum NumberFormatOptions::SignDisplay;
#else
  USING_ENUM(NumberFormatOptions::SignDisplay, Auto, Never, Always, ExceptZero,
             Negative);
#endif
  switch (signDisplay) {
    case Auto:
      return "auto";
    case Never:
      return "never";
    case Always:
      return "always";
    case ExceptZero:
      return "exceptZero";
    case Negative:
      return "negative";
  }
  MOZ_CRASH("invalid number format sign display");
}





bool js::intl::SetNumberFormatDigitOptions(
    JSContext* cx, NumberFormatDigitOptions& obj, Handle<JSObject*> options,
    int32_t mnfdDefault, int32_t mxfdDefault,
    NumberFormatOptions::Notation notation) {
  MOZ_ASSERT(0 <= mnfdDefault && mnfdDefault <= mxfdDefault);

  
  int32_t mnid;
  if (!GetNumberOption(cx, options, cx->names().minimumIntegerDigits, 1, 21, 1,
                       &mnid)) {
    return false;
  }

  
  Rooted<JS::Value> mnfd(cx);
  if (!GetProperty(cx, options, options, cx->names().minimumFractionDigits,
                   &mnfd)) {
    return false;
  }

  
  Rooted<JS::Value> mxfd(cx);
  if (!GetProperty(cx, options, options, cx->names().maximumFractionDigits,
                   &mxfd)) {
    return false;
  }

  
  Rooted<JS::Value> mnsd(cx);
  if (!GetProperty(cx, options, options, cx->names().minimumSignificantDigits,
                   &mnsd)) {
    return false;
  }

  
  Rooted<JS::Value> mxsd(cx);
  if (!GetProperty(cx, options, options, cx->names().maximumSignificantDigits,
                   &mxsd)) {
    return false;
  }

  
  obj.minimumIntegerDigits = static_cast<int8_t>(mnid);

  
  int32_t roundingIncrement;
  if (!GetNumberOption(cx, options, cx->names().roundingIncrement, 1, 5000, 1,
                       &roundingIncrement)) {
    return false;
  }

  
  switch (roundingIncrement) {
    case 1:
    case 2:
    case 5:
    case 10:
    case 20:
    case 25:
    case 50:
    case 100:
    case 200:
    case 250:
    case 500:
    case 1000:
    case 2000:
    case 2500:
    case 5000:
      break;
    default: {
      Int32ToCStringBuf cbuf;
      const char* str = Int32ToCString(&cbuf, roundingIncrement);
      MOZ_ASSERT(str);
      JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                JSMSG_INVALID_OPTION_VALUE, "roundingIncrement",
                                str);
      return false;
    }
  }

  
  static constexpr auto roundingModes = MapOptions<RoundingModeToString>(
      NumberFormatDigitOptions::RoundingMode::Ceil,
      NumberFormatDigitOptions::RoundingMode::Floor,
      NumberFormatDigitOptions::RoundingMode::Expand,
      NumberFormatDigitOptions::RoundingMode::Trunc,
      NumberFormatDigitOptions::RoundingMode::HalfCeil,
      NumberFormatDigitOptions::RoundingMode::HalfFloor,
      NumberFormatDigitOptions::RoundingMode::HalfExpand,
      NumberFormatDigitOptions::RoundingMode::HalfTrunc,
      NumberFormatDigitOptions::RoundingMode::HalfEven);
  NumberFormatDigitOptions::RoundingMode roundingMode;
  if (!GetStringOption(cx, options, cx->names().roundingMode, roundingModes,
                       NumberFormatDigitOptions::RoundingMode::HalfExpand,
                       &roundingMode)) {
    return false;
  }

  
  static constexpr auto roundingPriorities =
      MapOptions<RoundingPriorityToString>(
          NumberFormatDigitOptions::RoundingPriority::Auto,
          NumberFormatDigitOptions::RoundingPriority::MorePrecision,
          NumberFormatDigitOptions::RoundingPriority::LessPrecision);
  NumberFormatDigitOptions::RoundingPriority roundingPriority;
  if (!GetStringOption(cx, options, cx->names().roundingPriority,
                       roundingPriorities,
                       NumberFormatDigitOptions::RoundingPriority::Auto,
                       &roundingPriority)) {
    return false;
  }

  
  static constexpr auto trailingZeroDisplays =
      MapOptions<TrailingZeroDisplayToString>(
          NumberFormatDigitOptions::TrailingZeroDisplay::Auto,
          NumberFormatDigitOptions::TrailingZeroDisplay::StripIfInteger);
  NumberFormatDigitOptions::TrailingZeroDisplay trailingZeroDisplay;
  if (!GetStringOption(cx, options, cx->names().trailingZeroDisplay,
                       trailingZeroDisplays,
                       NumberFormatDigitOptions::TrailingZeroDisplay::Auto,
                       &trailingZeroDisplay)) {
    return false;
  }

  

  
  if (roundingIncrement != 1) {
    mxfdDefault = mnfdDefault;
  }

  
  obj.roundingIncrement = static_cast<int16_t>(roundingIncrement);

  
  obj.roundingMode = roundingMode;

  
  obj.trailingZeroDisplay = trailingZeroDisplay;

  
  bool hasSd = !(mnsd.isUndefined() && mxsd.isUndefined());

  
  bool hasFd = !(mnfd.isUndefined() && mxfd.isUndefined());

  
  bool needSd = true;

  
  bool needFd = true;

  
  if (roundingPriority == NumberFormatDigitOptions::RoundingPriority ::Auto) {
    
    needSd = hasSd;

    
    if (needSd ||
        (!hasFd && notation == NumberFormatOptions::Notation::Compact)) {
      needFd = false;
    }
  }

  
  if (needSd) {
    
    if (hasSd) {
      
      int32_t minimumSignificantDigits;
      if (!DefaultNumberOption(cx, mnsd, 1, 21, 1, &minimumSignificantDigits)) {
        return false;
      }
      obj.minimumSignificantDigits =
          static_cast<int8_t>(minimumSignificantDigits);

      
      int32_t maximumSignificantDigits;
      if (!DefaultNumberOption(cx, mxsd, obj.minimumSignificantDigits, 21, 21,
                               &maximumSignificantDigits)) {
        return false;
      }
      obj.maximumSignificantDigits =
          static_cast<int8_t>(maximumSignificantDigits);
    } else {
      
      obj.minimumSignificantDigits = 1;

      
      obj.maximumSignificantDigits = 21;
    }
  }

  
  if (needFd) {
    
    if (hasFd) {
      
      mozilla::Maybe<int32_t> minFracDigits{};
      if (!DefaultNumberOption(cx, mnfd, 0, 100, &minFracDigits)) {
        return false;
      }

      
      mozilla::Maybe<int32_t> maxFracDigits{};
      if (!DefaultNumberOption(cx, mxfd, 0, 100, &maxFracDigits)) {
        return false;
      }

      MOZ_ASSERT(minFracDigits.isSome() || maxFracDigits.isSome(),
                 "mnfd and mxfd can't both be undefined");

      
      if (minFracDigits.isNothing()) {
        minFracDigits = mozilla::Some(std::min(mnfdDefault, *maxFracDigits));
      }

      
      else if (maxFracDigits.isNothing()) {
        maxFracDigits = mozilla::Some(std::max(mxfdDefault, *minFracDigits));
      }

      
      else if (*minFracDigits > *maxFracDigits) {
        Int32ToCStringBuf cbuf;
        const char* str = Int32ToCString(&cbuf, roundingIncrement);
        MOZ_ASSERT(str);
        JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                  JSMSG_INVALID_DIGITS_VALUE, str);
        return false;
      }

      
      obj.minimumFractionDigits = static_cast<int8_t>(*minFracDigits);

      
      obj.maximumFractionDigits = static_cast<int8_t>(*maxFracDigits);
    } else {
      
      obj.minimumFractionDigits = static_cast<int8_t>(mnfdDefault);

      
      obj.maximumFractionDigits = static_cast<int8_t>(mxfdDefault);
    }
  } else {
    
    obj.minimumFractionDigits = -1;
    obj.maximumFractionDigits = -1;
  }

  
  if (!needSd && !needFd) {
    MOZ_ASSERT(!hasSd, "bad significant digits in fallback case");
    MOZ_ASSERT(
        roundingPriority == NumberFormatDigitOptions::RoundingPriority::Auto,
        "bad rounding in fallback case");
    MOZ_ASSERT(notation == NumberFormatOptions::Notation::Compact,
               "bad notation in fallback case");

    
    obj.minimumFractionDigits = 0;
    obj.maximumFractionDigits = 0;
    obj.minimumSignificantDigits = 1;
    obj.maximumSignificantDigits = 2;
    obj.roundingPriority =
        NumberFormatDigitOptions::RoundingPriority::MorePrecision;
  } else {
    
    
    
    
    obj.roundingPriority = roundingPriority;
  }

  
  if (roundingIncrement != 1) {
    
    
    
    
    if (roundingPriority != NumberFormatDigitOptions::RoundingPriority::Auto ||
        hasSd) {
      const char* conflictingOption =
          !mnsd.isUndefined()   ? "minimumSignificantDigits"
          : !mxsd.isUndefined() ? "maximumSignificantDigits"
                                : "roundingPriority";
      JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                JSMSG_INVALID_NUMBER_OPTION,
                                "roundingIncrement", conflictingOption);
      return false;
    }

    
    
    
    if (obj.minimumFractionDigits != obj.maximumFractionDigits) {
      JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                JSMSG_UNEQUAL_FRACTION_DIGITS);
      return false;
    }
  }

  
  return true;
}




static bool SetNumberFormatUnitOptions(JSContext* cx,
                                       NumberFormatUnitOptions& obj,
                                       Handle<JSObject*> options) {
  
  static constexpr auto styles = MapOptions<NumberFormatStyleToString>(
      NumberFormatUnitOptions::Style::Decimal,
      NumberFormatUnitOptions::Style::Percent,
      NumberFormatUnitOptions::Style::Currency,
      NumberFormatUnitOptions::Style::Unit);
  NumberFormatUnitOptions::Style style;
  if (!GetStringOption(cx, options, cx->names().style, styles,
                       NumberFormatUnitOptions::Style::Decimal, &style)) {
    return false;
  }

  
  obj.style = style;

  
  Rooted<JSString*> currency(cx);
  if (!GetStringOption(cx, options, cx->names().currency, &currency)) {
    return false;
  }

  
  if (!currency) {
    
    if (style == NumberFormatUnitOptions::Style::Currency) {
      JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                JSMSG_UNDEFINED_CURRENCY);
      return false;
    }
  } else {
    
    if (!ToWellFormedCurrencyCode(cx, currency, &obj.currency)) {
      return false;
    }
  }

  
  static constexpr auto currencyDisplays = MapOptions<CurrencyDisplayToString>(
      NumberFormatUnitOptions::CurrencyDisplay::Code,
      NumberFormatUnitOptions::CurrencyDisplay::Symbol,
      NumberFormatUnitOptions::CurrencyDisplay::NarrowSymbol,
      NumberFormatUnitOptions::CurrencyDisplay::Name);
  if (!GetStringOption(cx, options, cx->names().currencyDisplay,
                       currencyDisplays,
                       NumberFormatUnitOptions::CurrencyDisplay::Symbol,
                       &obj.currencyDisplay)) {
    return false;
  }

  
  static constexpr auto currencySigns = MapOptions<CurrencySignToString>(
      NumberFormatUnitOptions::CurrencySign::Standard,
      NumberFormatUnitOptions::CurrencySign::Accounting);
  if (!GetStringOption(cx, options, cx->names().currencySign, currencySigns,
                       NumberFormatUnitOptions::CurrencySign::Standard,
                       &obj.currencySign)) {
    return false;
  }

  
  Rooted<JSString*> unit(cx);
  if (!GetStringOption(cx, options, cx->names().unit, &unit)) {
    return false;
  }

  
  if (!unit) {
    
    if (style == NumberFormatUnitOptions::Style::Unit) {
      JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                JSMSG_UNDEFINED_UNIT);
      return false;
    }
  } else {
    
    if (!ToWellFormedUnitIdentifier(cx, unit, &obj.unit)) {
      return false;
    }
  }

  
  static constexpr auto unitDisplays = MapOptions<UnitDisplayToString>(
      NumberFormatUnitOptions::UnitDisplay::Short,
      NumberFormatUnitOptions::UnitDisplay::Narrow,
      NumberFormatUnitOptions::UnitDisplay::Long);
  if (!GetStringOption(cx, options, cx->names().unitDisplay, unitDisplays,
                       NumberFormatUnitOptions::UnitDisplay::Short,
                       &obj.unitDisplay)) {
    return false;
  }

  

  
  return true;
}




static bool InitializeNumberFormat(JSContext* cx,
                                   Handle<NumberFormatObject*> numberFormat,
                                   Handle<JS::Value> locales,
                                   Handle<JS::Value> optionsValue) {
  

  

  
  Rooted<LocalesList> requestedLocales(cx, cx);
  if (!CanonicalizeLocaleList(cx, locales, &requestedLocales)) {
    return false;
  }

  Rooted<ArrayObject*> requestedLocalesArray(
      cx, LocalesListToArray(cx, requestedLocales));
  if (!requestedLocalesArray) {
    return false;
  }
  numberFormat->setRequestedLocales(requestedLocalesArray);

  auto nfOptions = cx->make_unique<NumberFormatOptions>();
  if (!nfOptions) {
    return false;
  }

  if (!optionsValue.isUndefined()) {
    
    Rooted<JSObject*> options(cx, JS::ToObject(cx, optionsValue));
    if (!options) {
      return false;
    }

    
    LocaleMatcher matcher;
    if (!GetLocaleMatcherOption(cx, options, &matcher)) {
      return false;
    }

    
    
    
    

    
    Rooted<JSLinearString*> numberingSystem(cx);
    if (!GetUnicodeExtensionOption(cx, options,
                                   UnicodeExtensionKey::NumberingSystem,
                                   &numberingSystem)) {
      return false;
    }
    if (numberingSystem) {
      numberFormat->setNumberingSystem(numberingSystem);
    }

    

    

    

    

    

    
    if (!SetNumberFormatUnitOptions(cx, nfOptions->unitOptions, options)) {
      return false;
    }

    
    auto style = nfOptions->unitOptions.style;

    
    static constexpr auto notations =
        MapOptions<NotationToString>(NumberFormatOptions::Notation::Standard,
                                     NumberFormatOptions::Notation::Scientific,
                                     NumberFormatOptions::Notation::Engineering,
                                     NumberFormatOptions::Notation::Compact);
    NumberFormatOptions::Notation notation;
    if (!GetStringOption(cx, options, cx->names().notation, notations,
                         NumberFormatOptions::Notation::Standard, &notation)) {
      return false;
    }

    
    nfOptions->notation = notation;

    
    int32_t mnfdDefault;
    int32_t mxfdDefault;
    if (style == NumberFormatUnitOptions::Style::Currency &&
        notation == NumberFormatOptions::Notation::Standard) {
      
      int32_t cDigits = CurrencyDigits(nfOptions->unitOptions.currency);

      
      mnfdDefault = cDigits;

      
      mxfdDefault = cDigits;
    } else {
      
      mnfdDefault = 0;

      
      mxfdDefault = style == NumberFormatUnitOptions::Style::Percent ? 0 : 3;
    }

    
    if (!SetNumberFormatDigitOptions(cx, nfOptions->digitOptions, options,
                                     mnfdDefault, mxfdDefault, notation)) {
      return false;
    }

    
    static constexpr auto compactDisplays = MapOptions<CompactDisplayToString>(
        NumberFormatOptions::CompactDisplay::Short,
        NumberFormatOptions::CompactDisplay::Long);
    if (!GetStringOption(cx, options, cx->names().compactDisplay,
                         compactDisplays,
                         NumberFormatOptions::CompactDisplay::Short,
                         &nfOptions->compactDisplay)) {
      return false;
    }

    
    auto defaultUseGrouping = NumberFormatOptions::UseGrouping::Auto;

    
    if (notation == NumberFormatOptions::Notation::Compact) {
      

      
      defaultUseGrouping = NumberFormatOptions::UseGrouping::Min2;
    }

    
    static constexpr auto useGroupings = MapOptions<UseGroupingOptionToString>(
        UseGroupingOption::Min2, UseGroupingOption::Auto,
        UseGroupingOption::Always, UseGroupingOption::True,
        UseGroupingOption::False);
    mozilla::Variant<bool, UseGroupingOption> useGrouping{false};
    if (!GetBooleanOrStringNumberFormatOption(
            cx, options, cx->names().useGrouping, useGroupings,
            ToUseGroupingOption(defaultUseGrouping), &useGrouping)) {
      return false;
    }

    
    nfOptions->useGrouping = useGrouping.match(
        [](bool grouping) {
          if (grouping) {
            return NumberFormatOptions::UseGrouping::Always;
          }
          return NumberFormatOptions::UseGrouping::Never;
        },
        [&](auto grouping) {
          return ToUseGrouping(grouping, defaultUseGrouping);
        });

    
    static constexpr auto signDisplays = MapOptions<SignDisplayToString>(
        NumberFormatOptions::SignDisplay::Auto,
        NumberFormatOptions::SignDisplay::Never,
        NumberFormatOptions::SignDisplay::Always,
        NumberFormatOptions::SignDisplay::ExceptZero,
        NumberFormatOptions::SignDisplay::Negative);
    if (!GetStringOption(cx, options, cx->names().signDisplay, signDisplays,
                         NumberFormatOptions::SignDisplay::Auto,
                         &nfOptions->signDisplay)) {
      return false;
    }
  } else {
    static constexpr NumberFormatOptions defaultOptions = {
        .digitOptions =
            {
                .roundingIncrement = 1,
                .minimumIntegerDigits = 1,
                .minimumFractionDigits = 0,
                .maximumFractionDigits = 3,
                .minimumSignificantDigits = 0,
                .maximumSignificantDigits = 0,
                .roundingMode =
                    NumberFormatDigitOptions::RoundingMode::HalfExpand,
                .roundingPriority =
                    NumberFormatDigitOptions::RoundingPriority::Auto,
                .trailingZeroDisplay =
                    NumberFormatDigitOptions::TrailingZeroDisplay::Auto,
            },
        .unitOptions =
            {
                .style = NumberFormatUnitOptions::Style::Decimal,
            },
        .notation = NumberFormatOptions::Notation::Standard,
        .useGrouping = NumberFormatOptions::UseGrouping::Auto,
        .signDisplay = NumberFormatOptions::SignDisplay::Auto,
    };

    
    *nfOptions = defaultOptions;
  }
  numberFormat->setOptions(nfOptions.release());
  AddCellMemory(numberFormat, sizeof(NumberFormatOptions),
                MemoryUse::IntlOptions);

  

  
  return true;
}




static bool NumberFormat(JSContext* cx, unsigned argc, Value* vp) {
  AutoJSConstructorProfilerEntry pseudoFrame(cx, "Intl.NumberFormat");
  CallArgs args = CallArgsFromVp(argc, vp);

  

  
  Rooted<JSObject*> proto(cx);
  if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_NumberFormat,
                                          &proto)) {
    return false;
  }

  Rooted<NumberFormatObject*> numberFormat(cx);
  numberFormat = NewObjectWithClassProto<NumberFormatObject>(cx, proto);
  if (!numberFormat) {
    return false;
  }

  
  if (!InitializeNumberFormat(cx, numberFormat, args.get(0), args.get(1))) {
    return false;
  }

  
  return ChainLegacyIntlFormat(cx, JSProto_NumberFormat, args, numberFormat);
}

NumberFormatObject* js::intl::CreateNumberFormat(JSContext* cx,
                                                 Handle<Value> locales,
                                                 Handle<Value> options) {
  Rooted<NumberFormatObject*> numberFormat(
      cx, NewBuiltinClassInstance<NumberFormatObject>(cx));
  if (!numberFormat) {
    return nullptr;
  }

  if (!InitializeNumberFormat(cx, numberFormat, locales, options)) {
    return nullptr;
  }
  return numberFormat;
}

NumberFormatObject* js::intl::GetOrCreateNumberFormat(JSContext* cx,
                                                      Handle<Value> locales,
                                                      Handle<Value> options) {
  
  
  if ((locales.isUndefined() || locales.isString()) && options.isUndefined()) {
    Rooted<JSLinearString*> locale(cx);
    if (locales.isString()) {
      locale = locales.toString()->ensureLinear(cx);
      if (!locale) {
        return nullptr;
      }
    }
    return cx->global()->globalIntlData().getOrCreateNumberFormat(cx, locale);
  }

  
  return CreateNumberFormat(cx, locales, options);
}

void js::intl::NumberFormatObject::finalize(JS::GCContext* gcx, JSObject* obj) {
  auto* numberFormat = &obj->as<NumberFormatObject>();
  auto* nf = numberFormat->getNumberFormatter();
  auto* nrf = numberFormat->getNumberRangeFormatter();

  if (auto* options = numberFormat->getOptions()) {
    gcx->delete_(obj, options, MemoryUse::IntlOptions);
  }

  if (nf) {
    RemoveICUCellMemory(gcx, obj, NumberFormatObject::EstimatedMemoryUse);
    
    
    delete nf;
  }

  if (nrf) {
    RemoveICUCellMemory(gcx, obj, EstimatedRangeFormatterMemoryUse);
    
    
    delete nrf;
  }
}




static bool ResolveLocale(JSContext* cx,
                          Handle<NumberFormatObject*> numberFormat) {
  
  if (numberFormat->isLocaleResolved()) {
    return true;
  }

  Rooted<ArrayObject*> requestedLocales(
      cx, &numberFormat->getRequestedLocales()->as<ArrayObject>());

  
  mozilla::EnumSet<UnicodeExtensionKey> relevantExtensionKeys{
      UnicodeExtensionKey::NumberingSystem,
  };

  
  Rooted<LocaleOptions> localeOptions(cx);
  if (auto* nu = numberFormat->getNumberingSystem()) {
    localeOptions.setUnicodeExtension(UnicodeExtensionKey::NumberingSystem, nu);
  }

  
  auto localeData = LocaleData::Default;

  
  Rooted<ResolvedLocale> resolved(cx);
  if (!ResolveLocale(cx, AvailableLocaleKind::NumberFormat, requestedLocales,
                     localeOptions, relevantExtensionKeys, localeData,
                     &resolved)) {
    return false;
  }

  
  auto* locale = resolved.toLocale(cx);
  if (!locale) {
    return false;
  }
  numberFormat->setLocale(locale);

  auto nu = resolved.extension(UnicodeExtensionKey::NumberingSystem);
  MOZ_ASSERT(nu, "resolved numbering system is non-null");
  numberFormat->setNumberingSystem(nu);

  MOZ_ASSERT(numberFormat->isLocaleResolved(), "locale successfully resolved");
  return true;
}

static UniqueChars NumberFormatLocale(
    JSContext* cx, Handle<NumberFormatObject*> numberFormat) {
  MOZ_ASSERT(numberFormat->isLocaleResolved());

  

  JS::RootedVector<UnicodeExtensionKeyword> keywords(cx);
  if (!keywords.emplaceBack("nu", numberFormat->getNumberingSystem())) {
    return nullptr;
  }

  Rooted<JSLinearString*> locale(cx, numberFormat->getLocale());
  return FormatLocale(cx, locale, keywords);
}

static auto ToCurrencyDisplay(
    NumberFormatUnitOptions::CurrencyDisplay currencyDisplay) {
#ifndef USING_ENUM
  using enum mozilla::intl::NumberFormatOptions::CurrencyDisplay;
#else
  USING_ENUM(mozilla::intl::NumberFormatOptions::CurrencyDisplay, Symbol,
             NarrowSymbol, Code, Name);
#endif
  switch (currencyDisplay) {
    case NumberFormatUnitOptions::CurrencyDisplay::Symbol:
      return Symbol;
    case NumberFormatUnitOptions::CurrencyDisplay::NarrowSymbol:
      return NarrowSymbol;
    case NumberFormatUnitOptions::CurrencyDisplay::Code:
      return Code;
    case NumberFormatUnitOptions::CurrencyDisplay::Name:
      return Name;
  }
  MOZ_CRASH("invalid currency display");
}

static auto ToUnitDisplay(NumberFormatUnitOptions::UnitDisplay unitDisplay) {
#ifndef USING_ENUM
  using enum mozilla::intl::NumberFormatOptions::UnitDisplay;
#else
  USING_ENUM(mozilla::intl::NumberFormatOptions::UnitDisplay, Short, Narrow,
             Long);
#endif
  switch (unitDisplay) {
    case NumberFormatUnitOptions::UnitDisplay::Short:
      return Short;
    case NumberFormatUnitOptions::UnitDisplay::Narrow:
      return Narrow;
    case NumberFormatUnitOptions::UnitDisplay::Long:
      return Long;
  }
  MOZ_CRASH("invalid unit display");
}

static auto ToRoundingMode(
    NumberFormatDigitOptions::RoundingMode roundingMode) {
#ifndef USING_ENUM
  using enum mozilla::intl::NumberFormatOptions::RoundingMode;
#else
  USING_ENUM(mozilla::intl::NumberFormatOptions::RoundingMode, Ceil, Floor,
             Expand, Trunc, HalfCeil, HalfFloor, HalfExpand, HalfTrunc,
             HalfEven);
#endif
  switch (roundingMode) {
    case NumberFormatDigitOptions::RoundingMode::Ceil:
      return Ceil;
    case NumberFormatDigitOptions::RoundingMode::Floor:
      return Floor;
    case NumberFormatDigitOptions::RoundingMode::Expand:
      return Expand;
    case NumberFormatDigitOptions::RoundingMode::Trunc:
      return Trunc;
    case NumberFormatDigitOptions::RoundingMode::HalfCeil:
      return HalfCeil;
    case NumberFormatDigitOptions::RoundingMode::HalfFloor:
      return HalfFloor;
    case NumberFormatDigitOptions::RoundingMode::HalfExpand:
      return HalfExpand;
    case NumberFormatDigitOptions::RoundingMode::HalfTrunc:
      return HalfTrunc;
    case NumberFormatDigitOptions::RoundingMode::HalfEven:
      return HalfEven;
  }
  MOZ_CRASH("invalid rounding mode");
}

static auto ToSignDisplay(NumberFormatOptions::SignDisplay signDisplay) {
#ifndef USING_ENUM
  using enum mozilla::intl::NumberFormatOptions::SignDisplay;
#else
  USING_ENUM(mozilla::intl::NumberFormatOptions::SignDisplay, Auto, Never,
             Always, ExceptZero, Negative);
#endif
  switch (signDisplay) {
    case NumberFormatOptions::SignDisplay::Auto:
      return Auto;
    case NumberFormatOptions::SignDisplay::Never:
      return Never;
    case NumberFormatOptions::SignDisplay::Always:
      return Always;
    case NumberFormatOptions::SignDisplay::ExceptZero:
      return ExceptZero;
    case NumberFormatOptions::SignDisplay::Negative:
      return Negative;
  }
  MOZ_CRASH("invalid sign display");
}

static auto ToAccountingSignDisplay(
    NumberFormatOptions::SignDisplay signDisplay) {
#ifndef USING_ENUM
  using enum mozilla::intl::NumberFormatOptions::SignDisplay;
#else
  USING_ENUM(mozilla::intl::NumberFormatOptions::SignDisplay, Accounting, Never,
             AccountingAlways, AccountingExceptZero, AccountingNegative);
#endif
  switch (signDisplay) {
    case NumberFormatOptions::SignDisplay::Auto:
      return Accounting;
    case NumberFormatOptions::SignDisplay::Never:
      return Never;
    case NumberFormatOptions::SignDisplay::Always:
      return AccountingAlways;
    case NumberFormatOptions::SignDisplay::ExceptZero:
      return AccountingExceptZero;
    case NumberFormatOptions::SignDisplay::Negative:
      return AccountingNegative;
  }
  MOZ_CRASH("invalid sign display");
}

static auto ToNotation(NumberFormatOptions::Notation notation,
                       NumberFormatOptions::CompactDisplay compactDisplay) {
#ifndef USING_ENUM
  using enum mozilla::intl::NumberFormatOptions::Notation;
#else
  USING_ENUM(mozilla::intl::NumberFormatOptions::Notation, Standard, Scientific,
             Engineering, CompactShort, CompactLong);
#endif
  switch (notation) {
    case NumberFormatOptions::Notation::Standard:
      return Standard;
    case NumberFormatOptions::Notation::Scientific:
      return Scientific;
    case NumberFormatOptions::Notation::Engineering:
      return Engineering;
    case NumberFormatOptions::Notation::Compact:
      switch (compactDisplay) {
        case NumberFormatOptions::CompactDisplay::Short:
          return CompactShort;
        case NumberFormatOptions::CompactDisplay::Long:
          return CompactLong;
      }
      MOZ_CRASH("invalid compact display");
  }
  MOZ_CRASH("invalid notation");
}

static auto ToGrouping(NumberFormatOptions::UseGrouping useGrouping) {
#ifndef USING_ENUM
  using enum mozilla::intl::NumberFormatOptions::Grouping;
#else
  USING_ENUM(mozilla::intl::NumberFormatOptions::Grouping, Auto, Min2, Always,
             Never);
#endif
  switch (useGrouping) {
    case NumberFormatOptions::UseGrouping::Auto:
      return Auto;
    case NumberFormatOptions::UseGrouping::Min2:
      return Min2;
    case NumberFormatOptions::UseGrouping::Always:
      return Always;
    case NumberFormatOptions::UseGrouping::Never:
      return Never;
  }
  MOZ_CRASH("invalid grouping");
}

static auto ToRoundingPriority(
    NumberFormatDigitOptions::RoundingPriority roundingPriority) {
#ifndef USING_ENUM
  using enum mozilla::intl::NumberFormatOptions::RoundingPriority;
#else
  USING_ENUM(mozilla::intl::NumberFormatOptions::RoundingPriority, Auto,
             MorePrecision, LessPrecision);
#endif
  switch (roundingPriority) {
    case NumberFormatDigitOptions::RoundingPriority::Auto:
      return Auto;
    case NumberFormatDigitOptions::RoundingPriority::MorePrecision:
      return MorePrecision;
    case NumberFormatDigitOptions::RoundingPriority::LessPrecision:
      return LessPrecision;
  }
  MOZ_CRASH("invalid rounding priority");
}

struct MozNumberFormatOptions : public mozilla::intl::NumberRangeFormatOptions {
  static_assert(std::is_base_of_v<mozilla::intl::NumberFormatOptions,
                                  mozilla::intl::NumberRangeFormatOptions>);

  char currencyChars[3] = {};
  char unitChars[MaxUnitLength() + 1] = {};
};

static void SetNumberFormatUnitOptions(
    const NumberFormatUnitOptions& unitOptions,
    MozNumberFormatOptions& options) {
  switch (unitOptions.style) {
    case NumberFormatUnitOptions::Style::Decimal: {
      return;
    }

    case NumberFormatUnitOptions::Style::Percent: {
      options.mPercent = true;
      return;
    }

    case NumberFormatUnitOptions::Style::Currency: {
      static constexpr size_t CurrencyLength = 3;

      static_assert(std::extent_v<decltype(unitOptions.currency.code)> ==
                    CurrencyLength);
      static_assert(std::extent_v<decltype(options.currencyChars)> ==
                    CurrencyLength);

      std::copy_n(unitOptions.currency.code, CurrencyLength,
                  options.currencyChars);

      auto display = ToCurrencyDisplay(unitOptions.currencyDisplay);

      options.mCurrency = mozilla::Some(std::make_pair(
          std::string_view(options.currencyChars, CurrencyLength), display));
      return;
    }

    case NumberFormatUnitOptions::Style::Unit: {
      static constexpr size_t UnitLength = MaxUnitLength();

      static_assert(
          std::extent_v<decltype(unitOptions.unit.name)> > UnitLength,
          "large enough to hold the largest unit and a NUL terminator");
      static_assert(
          std::extent_v<decltype(options.unitChars)> > UnitLength,
          "large enough to hold the largest unit and a NUL terminator");

      std::copy_n(unitOptions.unit.name, UnitLength, options.unitChars);

      auto display = ToUnitDisplay(unitOptions.unitDisplay);

      options.mUnit = mozilla::Some(
          std::make_pair(std::string_view(options.unitChars), display));
      return;
    }
  }
  MOZ_CRASH("invalid number format style");
}

template <class Options>
static void SetNumberFormatDigitOptions(
    const NumberFormatDigitOptions& digitOptions, Options& options) {
  bool hasSignificantDigits = digitOptions.minimumSignificantDigits > 0;
  if (hasSignificantDigits) {
    MOZ_ASSERT(digitOptions.minimumSignificantDigits <=
                   digitOptions.maximumSignificantDigits,
               "significant digits are consistent");

    options.mSignificantDigits =
        mozilla::Some(std::make_pair(digitOptions.minimumSignificantDigits,
                                     digitOptions.maximumSignificantDigits));
  }

  bool hasFractionDigits = digitOptions.minimumFractionDigits >= 0;
  if (hasFractionDigits) {
    MOZ_ASSERT(digitOptions.minimumFractionDigits <=
                   digitOptions.maximumFractionDigits,
               "fraction digits are consistent");

    options.mFractionDigits =
        mozilla::Some(std::make_pair(digitOptions.minimumFractionDigits,
                                     digitOptions.maximumFractionDigits));
  }

  options.mMinIntegerDigits = mozilla::Some(digitOptions.minimumIntegerDigits);
  options.mRoundingIncrement = digitOptions.roundingIncrement;
  options.mRoundingMode = ToRoundingMode(digitOptions.roundingMode);
  options.mRoundingPriority = ToRoundingPriority(digitOptions.roundingPriority);
  options.mStripTrailingZero =
      digitOptions.trailingZeroDisplay ==
      NumberFormatDigitOptions::TrailingZeroDisplay::StripIfInteger;
}

static void SetNumberFormatOptions(const NumberFormatOptions& nfOptions,
                                   MozNumberFormatOptions& options) {
  SetNumberFormatDigitOptions(nfOptions.digitOptions, options);
  SetNumberFormatUnitOptions(nfOptions.unitOptions, options);

  options.mNotation = ToNotation(nfOptions.notation, nfOptions.compactDisplay);
  options.mGrouping = ToGrouping(nfOptions.useGrouping);
  if (nfOptions.unitOptions.style == NumberFormatUnitOptions::Style::Currency &&
      nfOptions.unitOptions.currencySign ==
          NumberFormatUnitOptions::CurrencySign::Accounting) {
    options.mSignDisplay = ToAccountingSignDisplay(nfOptions.signDisplay);
  } else {
    options.mSignDisplay = ToSignDisplay(nfOptions.signDisplay);
  }

  options.mRangeCollapse =
      mozilla::intl::NumberRangeFormatOptions::RangeCollapse::Auto;
  options.mRangeIdentityFallback = mozilla::intl::NumberRangeFormatOptions::
      RangeIdentityFallback::Approximately;
}

void js::intl::SetPluralRulesOptions(
    const PluralRulesOptions& plOptions,
    mozilla::intl::PluralRulesOptions& options) {
  ::SetNumberFormatDigitOptions(plOptions.digitOptions, options);

  options.mNotation = ToNotation(plOptions.notation, plOptions.compactDisplay);
}






template <class Formatter>
static Formatter* NewNumberFormat(JSContext* cx,
                                  Handle<NumberFormatObject*> numberFormat) {
  if (!ResolveLocale(cx, numberFormat)) {
    return nullptr;
  }
  auto nfOptions = *numberFormat->getOptions();

  auto locale = NumberFormatLocale(cx, numberFormat);
  if (!locale) {
    return nullptr;
  }

  MozNumberFormatOptions options;
  SetNumberFormatOptions(nfOptions, options);

  auto result = Formatter::TryCreate(locale.get(), options);
  if (result.isErr()) {
    ReportInternalError(cx, result.unwrapErr());
    return nullptr;
  }
  return result.unwrap().release();
}

static mozilla::intl::NumberFormat* GetOrCreateNumberFormat(
    JSContext* cx, Handle<NumberFormatObject*> numberFormat) {
  
  if (auto* nf = numberFormat->getNumberFormatter()) {
    return nf;
  }

  auto* nf = NewNumberFormat<mozilla::intl::NumberFormat>(cx, numberFormat);
  if (!nf) {
    return nullptr;
  }
  numberFormat->setNumberFormatter(nf);

  AddICUCellMemory(numberFormat, NumberFormatObject::EstimatedMemoryUse);
  return nf;
}

static mozilla::intl::NumberRangeFormat* GetOrCreateNumberRangeFormat(
    JSContext* cx, Handle<NumberFormatObject*> numberFormat) {
  
  if (auto* nrf = numberFormat->getNumberRangeFormatter()) {
    return nrf;
  }

  auto* nrf =
      NewNumberFormat<mozilla::intl::NumberRangeFormat>(cx, numberFormat);
  if (!nrf) {
    return nullptr;
  }
  numberFormat->setNumberRangeFormatter(nrf);

  AddICUCellMemory(numberFormat,
                   NumberFormatObject::EstimatedRangeFormatterMemoryUse);
  return nrf;
}

using FieldType = js::ImmutableTenuredPtr<PropertyName*> JSAtomState::*;

static FieldType GetFieldTypeForNumberPartType(
    mozilla::intl::NumberPartType type) {
  switch (type) {
    case mozilla::intl::NumberPartType::ApproximatelySign:
      return &JSAtomState::approximatelySign;
    case mozilla::intl::NumberPartType::Compact:
      return &JSAtomState::compact;
    case mozilla::intl::NumberPartType::Currency:
      return &JSAtomState::currency;
    case mozilla::intl::NumberPartType::Decimal:
      return &JSAtomState::decimal;
    case mozilla::intl::NumberPartType::ExponentInteger:
      return &JSAtomState::exponentInteger;
    case mozilla::intl::NumberPartType::ExponentMinusSign:
      return &JSAtomState::exponentMinusSign;
    case mozilla::intl::NumberPartType::ExponentSeparator:
      return &JSAtomState::exponentSeparator;
    case mozilla::intl::NumberPartType::Fraction:
      return &JSAtomState::fraction;
    case mozilla::intl::NumberPartType::Group:
      return &JSAtomState::group;
    case mozilla::intl::NumberPartType::Infinity:
      return &JSAtomState::infinity;
    case mozilla::intl::NumberPartType::Integer:
      return &JSAtomState::integer;
    case mozilla::intl::NumberPartType::Literal:
      return &JSAtomState::literal;
    case mozilla::intl::NumberPartType::MinusSign:
      return &JSAtomState::minusSign;
    case mozilla::intl::NumberPartType::Nan:
      return &JSAtomState::nan;
    case mozilla::intl::NumberPartType::Percent:
      return &JSAtomState::percentSign;
    case mozilla::intl::NumberPartType::PlusSign:
      return &JSAtomState::plusSign;
    case mozilla::intl::NumberPartType::Unit:
      return &JSAtomState::unit;
  }

  MOZ_ASSERT_UNREACHABLE(
      "unenumerated, undocumented format field returned by iterator");
  return nullptr;
}

static FieldType GetFieldTypeForNumberPartSource(
    mozilla::intl::NumberPartSource source) {
  switch (source) {
    case mozilla::intl::NumberPartSource::Shared:
      return &JSAtomState::shared;
    case mozilla::intl::NumberPartSource::Start:
      return &JSAtomState::startRange;
    case mozilla::intl::NumberPartSource::End:
      return &JSAtomState::endRange;
  }

  MOZ_CRASH("unexpected number part source");
}

enum class DisplayNumberPartSource : bool { No, Yes };
enum class DisplayLiteralUnit : bool { No, Yes };







static PlainObject* CreateNumberPart(JSContext* cx,
                                     const mozilla::intl::NumberPart& part,
                                     Handle<JSString*> value,
                                     DisplayNumberPartSource displaySource,
                                     DisplayLiteralUnit displayLiteralUnit,
                                     FieldType unitType) {
  Rooted<IdValueVector> properties(cx, cx);

  FieldType type = GetFieldTypeForNumberPartType(part.type);
  if (!properties.emplaceBack(NameToId(cx->names().type),
                              StringValue(cx->names().*type))) {
    return nullptr;
  }

  if (!properties.emplaceBack(NameToId(cx->names().value),
                              StringValue(value))) {
    return nullptr;
  }

  if (displaySource == DisplayNumberPartSource::Yes) {
    FieldType source = GetFieldTypeForNumberPartSource(part.source);
    if (!properties.emplaceBack(NameToId(cx->names().source),
                                StringValue(cx->names().*source))) {
      return nullptr;
    }
  }

  if (unitType != nullptr && (type != &JSAtomState::literal ||
                              displayLiteralUnit == DisplayLiteralUnit::Yes)) {
    if (!properties.emplaceBack(NameToId(cx->names().unit),
                                StringValue(cx->names().*unitType))) {
      return nullptr;
    }
  }

  return NewPlainObjectWithUniqueNames(cx, properties);
}

static ArrayObject* FormattedNumberToParts(
    JSContext* cx, Handle<JSString*> string,
    const mozilla::intl::NumberPartVector& parts,
    DisplayNumberPartSource displaySource,
    DisplayLiteralUnit displayLiteralUnit, FieldType unitType) {
  Rooted<ArrayObject*> partsArray(
      cx, NewDenseFullyAllocatedArray(cx, parts.length()));
  if (!partsArray) {
    return nullptr;
  }
  partsArray->ensureDenseInitializedLength(0, parts.length());

  Rooted<JSString*> value(cx);

  size_t index = 0;
  size_t beginIndex = 0;
  for (const auto& part : parts) {
    MOZ_ASSERT(part.endIndex > beginIndex);
    value =
        NewDependentString(cx, string, beginIndex, part.endIndex - beginIndex);
    if (!value) {
      return nullptr;
    }
    beginIndex = part.endIndex;

    auto* obj = CreateNumberPart(cx, part, value, displaySource,
                                 displayLiteralUnit, unitType);
    if (!obj) {
      return nullptr;
    }
    partsArray->initDenseElement(index++, ObjectValue(*obj));
  }
  MOZ_ASSERT(index == parts.length());
  MOZ_ASSERT(beginIndex == string->length(),
             "result array must partition the entire string");

  return partsArray;
}

bool js::intl::FormattedRelativeTimeToParts(
    JSContext* cx, Handle<JSString*> str,
    const mozilla::intl::NumberPartVector& parts,
    RelativeTimeFormatUnit relativeTimeUnit, MutableHandle<JS::Value> result) {
  auto* array =
      FormattedNumberToParts(cx, str, parts, DisplayNumberPartSource::No,
                             DisplayLiteralUnit::No, relativeTimeUnit);
  if (!array) {
    return false;
  }

  result.setObject(*array);
  return true;
}



template <typename CharT>
static bool IsNonDecimalNumber(mozilla::Range<const CharT> chars) {
  const CharT* end = chars.begin().get() + chars.length();
  const CharT* start = SkipSpace(chars.begin().get(), end);

  if (end - start >= 2 && start[0] == '0') {
    CharT ch = start[1];
    return ch == 'b' || ch == 'B' || ch == 'o' || ch == 'O' || ch == 'x' ||
           ch == 'X';
  }
  return false;
}

static bool IsNonDecimalNumber(const JSLinearString* str) {
  JS::AutoCheckCannotGC nogc;
  return str->hasLatin1Chars() ? IsNonDecimalNumber(str->latin1Range(nogc))
                               : IsNonDecimalNumber(str->twoByteRange(nogc));
}






static bool ToIntlMathematicalValue(JSContext* cx,
                                    MutableHandle<JS::Value> value) {
  
  if (!ToPrimitive(cx, JSTYPE_NUMBER, value)) {
    return false;
  }

  
  if (value.isBigInt()) {
    return true;
  }

  
  if (!value.isString()) {
    
    return ToNumber(cx, value);
  }

  
  auto* str = value.toString()->ensureLinear(cx);
  if (!str) {
    return false;
  }

  
  double number = LinearStringToNumber(str);

  
  if (std::isnan(number)) {
    
    value.setNaN();
    return true;
  }

  
  if (number == 0.0 || std::isinf(number)) {
    

    
    value.setDouble(number);
    return true;
  }

  
  if (IsNonDecimalNumber(str)) {
    
    

    MOZ_ASSERT(!mozilla::IsNegative(number),
               "non-decimal numbers can't be negative");

    if (number < DOUBLE_INTEGRAL_PRECISION_LIMIT) {
      
      value.setDouble(number);
    } else {
      

      
      
      Rooted<JSString*> rooted(cx, str);
      BigInt* bi;
      JS_TRY_VAR_OR_RETURN_FALSE(cx, bi, StringToBigInt(cx, rooted));
      MOZ_ASSERT(bi);

      value.setBigInt(bi);
    }
  }
  return true;
}



template <typename CharT>
static mozilla::Span<const CharT> NumberPart(const CharT* chars,
                                             size_t length) {
  const CharT* start = chars;
  const CharT* end = chars + length;

  start = SkipSpace(start, end);

  
  
  MOZ_ASSERT(start <= end);
  while (end > start && unicode::IsSpace(end[-1])) {
    end--;
  }

  
  MOZ_ASSERT(start < end);
  MOZ_ASSERT(mozilla::IsAscii(mozilla::Span(start, end)));

  return {start, end};
}

static bool NumberPart(JSContext* cx, JSLinearString* str,
                       const JS::AutoCheckCannotGC& nogc,
                       JS::UniqueChars& latin1, std::string_view& result) {
  if (str->hasLatin1Chars()) {
    auto span = NumberPart(
        reinterpret_cast<const char*>(str->latin1Chars(nogc)), str->length());

    result = {span.data(), span.size()};
    return true;
  }

  auto span = NumberPart(str->twoByteChars(nogc), str->length());

  latin1.reset(JS::LossyTwoByteCharsToNewLatin1CharsZ(cx, span).c_str());
  if (!latin1) {
    return false;
  }

  result = {latin1.get(), span.size()};
  return true;
}

class StringNumberChars {
  JS::AutoCheckCannotGC nogc;

  JSLinearString* string_;
  std::string_view view_;

  
  JS::UniqueChars latin1_;

 public:
  explicit StringNumberChars(JSLinearString* string) : string_(string) {}

  bool init(JSContext* cx) {
    return NumberPart(cx, string_, nogc, latin1_, view_);
  }

  operator std::string_view() const { return view_; }
};

static JSLinearString* FormattedResultToString(
    JSContext* cx,
    mozilla::Result<std::u16string_view, mozilla::intl::ICUError>& result) {
  if (result.isErr()) {
    ReportInternalError(cx, result.unwrapErr());
    return nullptr;
  }
  return NewStringCopy<CanGC>(cx, result.unwrap());
}




static auto FormatNumeric(JSContext* cx, mozilla::intl::NumberFormat* nf,
                          Handle<JS::BigInt*> value)
    -> decltype(nf->format(int64_t(0))) {
  int64_t num;
  if (BigInt::isInt64(value, &num)) {
    return nf->format(num);
  }

  auto* str = BigInt::toString<CanGC>(cx, value, 10);
  if (!str) {
    return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
  }
  MOZ_RELEASE_ASSERT(str->hasLatin1Chars());

  JS::AutoCheckCannotGC nogc;

  const char* chars = reinterpret_cast<const char*>(str->latin1Chars(nogc));
  return nf->format(std::string_view(chars, str->length()));
}




static auto FormatNumeric(JSContext* cx, mozilla::intl::NumberFormat* nf,
                          Handle<JS::Value> value)
    -> decltype(nf->format(0.0)) {
  MOZ_ASSERT(value.isNumeric() || value.isString());

  if (value.isNumber()) {
    return nf->format(value.toNumber());
  }

  if (value.isBigInt()) {
    Rooted<BigInt*> bi(cx, value.toBigInt());
    return FormatNumeric(cx, nf, bi);
  }

  auto* str = value.toString()->ensureLinear(cx);
  if (!str) {
    return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
  }

  StringNumberChars chars(str);
  if (!chars.init(cx)) {
    return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
  }
  return nf->format(chars);
}




static JSString* FormatNumeric(JSContext* cx,
                               Handle<NumberFormatObject*> numberFormat,
                               Handle<JS::Value> value) {
  auto* nf = GetOrCreateNumberFormat(cx, numberFormat);
  if (!nf) {
    return nullptr;
  }

  auto result = FormatNumeric(cx, nf, value);
  return FormattedResultToString(cx, result);
}




static auto FormatNumericToParts(JSContext* cx, mozilla::intl::NumberFormat* nf,
                                 Handle<JS::Value> value,
                                 mozilla::intl::NumberPartVector& parts)
    -> decltype(nf->formatToParts(0.0, parts)) {
  MOZ_ASSERT(value.isNumeric() || value.isString());

  if (value.isNumber()) {
    return nf->formatToParts(value.toNumber(), parts);
  }

  if (value.isBigInt()) {
    Rooted<BigInt*> bi(cx, value.toBigInt());

    int64_t num;
    if (BigInt::isInt64(bi, &num)) {
      return nf->formatToParts(num, parts);
    }

    auto* str = BigInt::toString<CanGC>(cx, bi, 10);
    if (!str) {
      return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
    }
    MOZ_RELEASE_ASSERT(str->hasLatin1Chars());

    JS::AutoCheckCannotGC nogc;

    const char* chars = reinterpret_cast<const char*>(str->latin1Chars(nogc));
    return nf->formatToParts(std::string_view(chars, str->length()), parts);
  }

  auto* str = value.toString()->ensureLinear(cx);
  if (!str) {
    return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
  }

  StringNumberChars chars(str);
  if (!chars.init(cx)) {
    return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
  }
  return nf->formatToParts(chars, parts);
}




static ArrayObject* FormatNumericToParts(
    JSContext* cx, Handle<NumberFormatObject*> numberFormat,
    Handle<JS::Value> value) {
  auto* nf = GetOrCreateNumberFormat(cx, numberFormat);
  if (!nf) {
    return nullptr;
  }

  mozilla::intl::NumberPartVector parts;
  auto result = FormatNumericToParts(cx, nf, value, parts);

  Rooted<JSString*> str(cx, FormattedResultToString(cx, result));
  if (!str) {
    return nullptr;
  }

  return FormattedNumberToParts(cx, str, parts, DisplayNumberPartSource::No,
                                DisplayLiteralUnit::No, nullptr);
}

JSString* js::intl::FormatNumber(JSContext* cx,
                                 Handle<NumberFormatObject*> numberFormat,
                                 double x) {
  auto* nf = GetOrCreateNumberFormat(cx, numberFormat);
  if (!nf) {
    return nullptr;
  }

  auto result = nf->format(x);
  return FormattedResultToString(cx, result);
}

JSString* js::intl::FormatBigInt(JSContext* cx,
                                 Handle<NumberFormatObject*> numberFormat,
                                 Handle<BigInt*> x) {
  auto* nf = GetOrCreateNumberFormat(cx, numberFormat);
  if (!nf) {
    return nullptr;
  }

  auto result = FormatNumeric(cx, nf, x);
  return FormattedResultToString(cx, result);
}

static JSLinearString* ToLinearString(JSContext* cx, Handle<JS::Value> val) {
  
  if (val.isDouble() && mozilla::IsNegativeZero(val.toDouble())) {
    constexpr std::string_view negativeZero = "-0";
    return NewStringCopy<CanGC>(cx, negativeZero);
  }

  auto* str = ToString(cx, val);
  return str ? str->ensureLinear(cx) : nullptr;
};

static bool EnsureNumericRangeHasNoNaN(JSContext* cx, const char* methodName,
                                       Handle<JS::Value> start,
                                       Handle<JS::Value> end) {
  if (start.isDouble() && std::isnan(start.toDouble())) {
    JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                              JSMSG_NAN_NUMBER_RANGE, "start", "NumberFormat",
                              methodName);
    return false;
  }
  if (end.isDouble() && std::isnan(end.toDouble())) {
    JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                              JSMSG_NAN_NUMBER_RANGE, "end", "NumberFormat",
                              methodName);
    return false;
  }
  return true;
}

static bool ValueRepresentableAsDouble(const Value& val, double* result) {
  if (val.isNumber()) {
    *result = val.toNumber();
    return true;
  }
  if (val.isBigInt()) {
    int64_t i64;
    if (BigInt::isInt64(val.toBigInt(), &i64) &&
        i64 < int64_t(DOUBLE_INTEGRAL_PRECISION_LIMIT) &&
        i64 > -int64_t(DOUBLE_INTEGRAL_PRECISION_LIMIT)) {
      *result = double(i64);
      return true;
    }
  }
  return false;
}




static auto FormatNumericRange(JSContext* cx,
                               mozilla::intl::NumberRangeFormat* nf,
                               Handle<JS::Value> start, Handle<JS::Value> end)
    -> decltype(nf->format(0.0, 0.0)) {
  MOZ_ASSERT(start.isNumeric() || start.isString(),
             "start is an Intl mathematical number");
  MOZ_ASSERT(end.isNumeric() || end.isString(),
             "end is an Intl mathematical number");
  MOZ_ASSERT_IF(start.isDouble(), !std::isnan(start.toDouble()));
  MOZ_ASSERT_IF(end.isDouble(), !std::isnan(end.toDouble()));

  double numStart, numEnd;
  if (ValueRepresentableAsDouble(start, &numStart) &&
      ValueRepresentableAsDouble(end, &numEnd)) {
    return nf->format(numStart, numEnd);
  }

  Rooted<JSLinearString*> strStart(cx, ToLinearString(cx, start));
  if (!strStart) {
    return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
  }

  Rooted<JSLinearString*> strEnd(cx, ToLinearString(cx, end));
  if (!strEnd) {
    return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
  }

  StringNumberChars charsStart(strStart);
  if (!charsStart.init(cx)) {
    return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
  }

  StringNumberChars charsEnd(strEnd);
  if (!charsEnd.init(cx)) {
    return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
  }

  return nf->format(charsStart, charsEnd);
}




static JSString* FormatNumericRange(JSContext* cx,
                                    Handle<NumberFormatObject*> numberFormat,
                                    Handle<JS::Value> start,
                                    Handle<JS::Value> end) {
  
  if (!EnsureNumericRangeHasNoNaN(cx, "formatRange", start, end)) {
    return nullptr;
  }

  auto* nf = GetOrCreateNumberRangeFormat(cx, numberFormat);
  if (!nf) {
    return nullptr;
  }

  auto result = FormatNumericRange(cx, nf, start, end);
  return FormattedResultToString(cx, result);
}




static auto FormatNumericRangeToParts(JSContext* cx,
                                      mozilla::intl::NumberRangeFormat* nf,
                                      Handle<JS::Value> start,
                                      Handle<JS::Value> end,
                                      mozilla::intl::NumberPartVector& parts)
    -> decltype(nf->formatToParts(0.0, 0.0, parts)) {
  MOZ_ASSERT(start.isNumeric() || start.isString(),
             "start is an Intl mathematical number");
  MOZ_ASSERT(end.isNumeric() || end.isString(),
             "end is an Intl mathematical number");
  MOZ_ASSERT_IF(start.isDouble(), !std::isnan(start.toDouble()));
  MOZ_ASSERT_IF(end.isDouble(), !std::isnan(end.toDouble()));

  double numStart, numEnd;
  if (ValueRepresentableAsDouble(start, &numStart) &&
      ValueRepresentableAsDouble(end, &numEnd)) {
    return nf->formatToParts(numStart, numEnd, parts);
  }

  Rooted<JSLinearString*> strStart(cx, ToLinearString(cx, start));
  if (!strStart) {
    return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
  }

  Rooted<JSLinearString*> strEnd(cx, ToLinearString(cx, end));
  if (!strEnd) {
    return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
  }

  StringNumberChars charsStart(strStart);
  if (!charsStart.init(cx)) {
    return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
  }

  StringNumberChars charsEnd(strEnd);
  if (!charsEnd.init(cx)) {
    return mozilla::Err(mozilla::intl::ICUError::OutOfMemory);
  }

  return nf->formatToParts(charsStart, charsEnd, parts);
}




static ArrayObject* FormatNumericRangeToParts(
    JSContext* cx, Handle<NumberFormatObject*> numberFormat,
    Handle<JS::Value> start, Handle<JS::Value> end) {
  
  if (!EnsureNumericRangeHasNoNaN(cx, "formatRangeToParts", start, end)) {
    return nullptr;
  }

  auto* nf = GetOrCreateNumberRangeFormat(cx, numberFormat);
  if (!nf) {
    return nullptr;
  }

  mozilla::intl::NumberPartVector parts;
  auto result = FormatNumericRangeToParts(cx, nf, start, end, parts);

  Rooted<JSString*> str(cx, FormattedResultToString(cx, result));
  if (!str) {
    return nullptr;
  }

  return FormattedNumberToParts(cx, str, parts, DisplayNumberPartSource::Yes,
                                DisplayLiteralUnit::No, nullptr);
}

JSLinearString* js::intl::FormatNumber(
    JSContext* cx, mozilla::intl::NumberFormat* numberFormat, double x) {
  auto result = numberFormat->format(x);
  return FormattedResultToString(cx, result);
}

JSLinearString* js::intl::FormatNumber(
    JSContext* cx, mozilla::intl::NumberFormat* numberFormat,
    std::string_view x) {
  auto result = numberFormat->format(x);
  return FormattedResultToString(cx, result);
}

ArrayObject* js::intl::FormatNumberToParts(
    JSContext* cx, mozilla::intl::NumberFormat* numberFormat, double x,
    NumberFormatUnit unit) {
  mozilla::intl::NumberPartVector parts;
  auto result = numberFormat->formatToParts(x, parts);
  Rooted<JSLinearString*> str(cx, FormattedResultToString(cx, result));
  if (!str) {
    return nullptr;
  }
  return FormattedNumberToParts(cx, str, parts, DisplayNumberPartSource::No,
                                DisplayLiteralUnit::Yes, unit);
}

ArrayObject* js::intl::FormatNumberToParts(
    JSContext* cx, mozilla::intl::NumberFormat* numberFormat,
    std::string_view x, NumberFormatUnit unit) {
  mozilla::intl::NumberPartVector parts;
  auto result = numberFormat->formatToParts(x, parts);
  Rooted<JSLinearString*> str(cx, FormattedResultToString(cx, result));
  if (!str) {
    return nullptr;
  }
  return FormattedNumberToParts(cx, str, parts, DisplayNumberPartSource::No,
                                DisplayLiteralUnit::Yes, unit);
}

template <class Options>
static bool ResolveNotationOptions(JSContext* cx, const Options& opts,
                                   JS::MutableHandle<IdValueVector> options) {
  auto* notation = NewStringCopy<CanGC>(cx, NotationToString(opts.notation));
  if (!notation) {
    return false;
  }
  if (!options.emplaceBack(NameToId(cx->names().notation),
                           StringValue(notation))) {
    return false;
  }

  
  if (opts.notation == NumberFormatOptions::Notation::Compact) {
    auto* compactDisplay =
        NewStringCopy<CanGC>(cx, CompactDisplayToString(opts.compactDisplay));
    if (!compactDisplay) {
      return false;
    }
    if (!options.emplaceBack(NameToId(cx->names().compactDisplay),
                             StringValue(compactDisplay))) {
      return false;
    }
  }

  return true;
}

static bool ResolveDigitOptions(JSContext* cx,
                                const NumberFormatDigitOptions& digitOptions,
                                JS::MutableHandle<IdValueVector> options) {
  if (!options.emplaceBack(NameToId(cx->names().minimumIntegerDigits),
                           Int32Value(digitOptions.minimumIntegerDigits))) {
    return false;
  }

  bool hasFractionDigits = digitOptions.minimumFractionDigits >= 0;
  if (hasFractionDigits) {
    MOZ_ASSERT(digitOptions.minimumFractionDigits <=
                   digitOptions.maximumFractionDigits,
               "fraction digits are consistent");

    if (!options.emplaceBack(NameToId(cx->names().minimumFractionDigits),
                             Int32Value(digitOptions.minimumFractionDigits))) {
      return false;
    }

    if (!options.emplaceBack(NameToId(cx->names().maximumFractionDigits),
                             Int32Value(digitOptions.maximumFractionDigits))) {
      return false;
    }
  }

  bool hasSignificantDigits = digitOptions.minimumSignificantDigits > 0;
  if (hasSignificantDigits) {
    MOZ_ASSERT(digitOptions.minimumSignificantDigits <=
                   digitOptions.maximumSignificantDigits,
               "significant digits are consistent");

    if (!options.emplaceBack(
            NameToId(cx->names().minimumSignificantDigits),
            Int32Value(digitOptions.minimumSignificantDigits))) {
      return false;
    }

    if (!options.emplaceBack(
            NameToId(cx->names().maximumSignificantDigits),
            Int32Value(digitOptions.maximumSignificantDigits))) {
      return false;
    }
  }

  return true;
}

static bool ResolveRoundingAndTrailingZeroOptions(
    JSContext* cx, const NumberFormatDigitOptions& digitOptions,
    JS::MutableHandle<IdValueVector> options) {
  if (!options.emplaceBack(NameToId(cx->names().roundingIncrement),
                           Int32Value(digitOptions.roundingIncrement))) {
    return false;
  }

  auto* roundingMode =
      NewStringCopy<CanGC>(cx, RoundingModeToString(digitOptions.roundingMode));
  if (!roundingMode) {
    return false;
  }
  if (!options.emplaceBack(NameToId(cx->names().roundingMode),
                           StringValue(roundingMode))) {
    return false;
  }

  auto* roundingPriority = NewStringCopy<CanGC>(
      cx, RoundingPriorityToString(digitOptions.roundingPriority));
  if (!roundingPriority) {
    return false;
  }
  if (!options.emplaceBack(NameToId(cx->names().roundingPriority),
                           StringValue(roundingPriority))) {
    return false;
  }

  auto* trailingZeroDisplay = NewStringCopy<CanGC>(
      cx, TrailingZeroDisplayToString(digitOptions.trailingZeroDisplay));
  if (!trailingZeroDisplay) {
    return false;
  }
  if (!options.emplaceBack(NameToId(cx->names().trailingZeroDisplay),
                           StringValue(trailingZeroDisplay))) {
    return false;
  }

  return true;
}






bool js::intl::ResolvePluralRulesOptions(
    JSContext* cx, const PluralRulesOptions& plOptions,
    JS::Handle<ArrayObject*> pluralCategories,
    JS::MutableHandle<IdValueVector> options) {
  if (!ResolveNotationOptions(cx, plOptions, options)) {
    return false;
  }

  if (!ResolveDigitOptions(cx, plOptions.digitOptions, options)) {
    return false;
  }

  if (!options.emplaceBack(NameToId(cx->names().pluralCategories),
                           ObjectValue(*pluralCategories))) {
    return false;
  }

  if (!ResolveRoundingAndTrailingZeroOptions(cx, plOptions.digitOptions,
                                             options)) {
    return false;
  }

  return true;
}

static bool IsNumberFormat(Handle<JS::Value> v) {
  return v.isObject() && v.toObject().is<NumberFormatObject>();
}




static bool UnwrapNumberFormat(JSContext* cx, MutableHandle<JS::Value> dtf) {
  
  if (!dtf.isObject()) {
    return true;
  }

  auto* obj = &dtf.toObject();
  if (obj->canUnwrapAs<NumberFormatObject>()) {
    return true;
  }

  Rooted<JSObject*> format(cx, obj);
  return UnwrapLegacyIntlFormat(cx, JSProto_NumberFormat, format, dtf);
}

static constexpr uint32_t NumberFormatFunction_NumberFormat = 0;




static bool NumberFormatFunction(JSContext* cx, unsigned argc, Value* vp) {
  CallArgs args = CallArgsFromVp(argc, vp);

  
  auto* compare = &args.callee().as<JSFunction>();
  auto nfValue = compare->getExtendedSlot(NumberFormatFunction_NumberFormat);
  Rooted<NumberFormatObject*> numberFormat(
      cx, &nfValue.toObject().as<NumberFormatObject>());

  
  Rooted<JS::Value> value(cx, args.get(0));
  if (!ToIntlMathematicalValue(cx, &value)) {
    return false;
  }

  
  auto* result = FormatNumeric(cx, numberFormat, value);
  if (!result) {
    return false;
  }
  args.rval().setString(result);
  return true;
}




static bool numberFormat_format(JSContext* cx, const CallArgs& args) {
  Rooted<NumberFormatObject*> numberFormat(
      cx, &args.thisv().toObject().as<NumberFormatObject>());

  
  auto* boundFormat = numberFormat->getBoundFormat();
  if (!boundFormat) {
    Handle<PropertyName*> funName = cx->names().empty_;
    auto* fn =
        NewNativeFunction(cx, NumberFormatFunction, 1, funName,
                          gc::AllocKind::FUNCTION_EXTENDED, GenericObject);
    if (!fn) {
      return false;
    }
    fn->initExtendedSlot(NumberFormatFunction_NumberFormat,
                         ObjectValue(*numberFormat));

    numberFormat->setBoundFormat(fn);
    boundFormat = fn;
  }

  
  args.rval().setObject(*boundFormat);
  return true;
}




static bool numberFormat_format(JSContext* cx, unsigned argc, Value* vp) {
  
  CallArgs args = CallArgsFromVp(argc, vp);
  if (!UnwrapNumberFormat(cx, args.mutableThisv())) {
    return false;
  }
  return CallNonGenericMethod<IsNumberFormat, numberFormat_format>(cx, args);
}




static bool numberFormat_formatToParts(JSContext* cx, const CallArgs& args) {
  Rooted<NumberFormatObject*> numberFormat(
      cx, &args.thisv().toObject().as<NumberFormatObject>());

  
  Rooted<JS::Value> value(cx, args.get(0));
  if (!ToIntlMathematicalValue(cx, &value)) {
    return false;
  }

  
  auto* result = FormatNumericToParts(cx, numberFormat, value);
  if (!result) {
    return false;
  }
  args.rval().setObject(*result);
  return true;
}




static bool numberFormat_formatToParts(JSContext* cx, unsigned argc,
                                       Value* vp) {
  
  CallArgs args = CallArgsFromVp(argc, vp);
  return CallNonGenericMethod<IsNumberFormat, numberFormat_formatToParts>(cx,
                                                                          args);
}




static bool numberFormat_formatRange(JSContext* cx, const CallArgs& args) {
  Rooted<NumberFormatObject*> numberFormat(
      cx, &args.thisv().toObject().as<NumberFormatObject>());

  
  if (!args.hasDefined(0) || !args.hasDefined(1)) {
    JS_ReportErrorNumberASCII(
        cx, GetErrorMessage, nullptr, JSMSG_UNDEFINED_NUMBER,
        !args.hasDefined(0) ? "start" : "end", "NumberFormat", "formatRange");
    return false;
  }

  
  Rooted<JS::Value> start(cx, args[0]);
  if (!ToIntlMathematicalValue(cx, &start)) {
    return false;
  }

  
  Rooted<JS::Value> end(cx, args[1]);
  if (!ToIntlMathematicalValue(cx, &end)) {
    return false;
  }

  
  auto* result = FormatNumericRange(cx, numberFormat, start, end);
  if (!result) {
    return false;
  }
  args.rval().setString(result);
  return true;
}




static bool numberFormat_formatRange(JSContext* cx, unsigned argc, Value* vp) {
  
  CallArgs args = CallArgsFromVp(argc, vp);
  return CallNonGenericMethod<IsNumberFormat, numberFormat_formatRange>(cx,
                                                                        args);
}




static bool numberFormat_formatRangeToParts(JSContext* cx,
                                            const CallArgs& args) {
  Rooted<NumberFormatObject*> numberFormat(
      cx, &args.thisv().toObject().as<NumberFormatObject>());

  
  if (!args.hasDefined(0) || !args.hasDefined(1)) {
    JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                              JSMSG_UNDEFINED_NUMBER,
                              !args.hasDefined(0) ? "start" : "end",
                              "NumberFormat", "formatRangeToParts");
    return false;
  }

  
  Rooted<JS::Value> start(cx, args[0]);
  if (!ToIntlMathematicalValue(cx, &start)) {
    return false;
  }

  
  Rooted<JS::Value> end(cx, args[1]);
  if (!ToIntlMathematicalValue(cx, &end)) {
    return false;
  }

  
  auto* result = FormatNumericRangeToParts(cx, numberFormat, start, end);
  if (!result) {
    return false;
  }
  args.rval().setObject(*result);
  return true;
}




static bool numberFormat_formatRangeToParts(JSContext* cx, unsigned argc,
                                            Value* vp) {
  
  CallArgs args = CallArgsFromVp(argc, vp);
  return CallNonGenericMethod<IsNumberFormat, numberFormat_formatRangeToParts>(
      cx, args);
}




static bool numberFormat_resolvedOptions(JSContext* cx, const CallArgs& args) {
  Rooted<NumberFormatObject*> numberFormat(
      cx, &args.thisv().toObject().as<NumberFormatObject>());

  if (!ResolveLocale(cx, numberFormat)) {
    return false;
  }
  auto nfOptions = *numberFormat->getOptions();

  
  Rooted<IdValueVector> options(cx, cx);

  
  if (!options.emplaceBack(NameToId(cx->names().locale),
                           StringValue(numberFormat->getLocale()))) {
    return false;
  }

  if (!options.emplaceBack(NameToId(cx->names().numberingSystem),
                           StringValue(numberFormat->getNumberingSystem()))) {
    return false;
  }

  auto* style = NewStringCopy<CanGC>(
      cx, NumberFormatStyleToString(nfOptions.unitOptions.style));
  if (!style) {
    return false;
  }
  if (!options.emplaceBack(NameToId(cx->names().style), StringValue(style))) {
    return false;
  }

#ifndef USING_ENUM
  using enum NumberFormatUnitOptions::Style;
#else
  USING_ENUM(NumberFormatUnitOptions::Style, Decimal, Percent, Currency, Unit);
#endif
  switch (nfOptions.unitOptions.style) {
    case Decimal:
    case Percent:
      break;

    case Currency: {
      
      

      const auto& code = nfOptions.unitOptions.currency.code;
      auto* currency = NewStringCopyN<CanGC>(cx, code, std::size(code));
      if (!currency) {
        return false;
      }
      if (!options.emplaceBack(NameToId(cx->names().currency),
                               StringValue(currency))) {
        return false;
      }

      auto* currencyDisplay = NewStringCopy<CanGC>(
          cx, CurrencyDisplayToString(nfOptions.unitOptions.currencyDisplay));
      if (!currencyDisplay) {
        return false;
      }
      if (!options.emplaceBack(NameToId(cx->names().currencyDisplay),
                               StringValue(currencyDisplay))) {
        return false;
      }

      auto* currencySign = NewStringCopy<CanGC>(
          cx, CurrencySignToString(nfOptions.unitOptions.currencySign));
      if (!currencySign) {
        return false;
      }
      if (!options.emplaceBack(NameToId(cx->names().currencySign),
                               StringValue(currencySign))) {
        return false;
      }

      break;
    }

    case Unit: {
      

      auto name = std::string_view{nfOptions.unitOptions.unit.name};
      auto* unit = NewStringCopy<CanGC>(cx, name);
      if (!unit) {
        return false;
      }
      if (!options.emplaceBack(NameToId(cx->names().unit), StringValue(unit))) {
        return false;
      }

      auto* unitDisplay = NewStringCopy<CanGC>(
          cx, UnitDisplayToString(nfOptions.unitOptions.unitDisplay));
      if (!unitDisplay) {
        return false;
      }
      if (!options.emplaceBack(NameToId(cx->names().unitDisplay),
                               StringValue(unitDisplay))) {
        return false;
      }

      break;
    }
  }

  if (!ResolveDigitOptions(cx, nfOptions.digitOptions, &options)) {
    return false;
  }

  if (nfOptions.useGrouping != NumberFormatOptions::UseGrouping::Never) {
    auto* useGrouping =
        NewStringCopy<CanGC>(cx, UseGroupingToString(nfOptions.useGrouping));
    if (!useGrouping) {
      return false;
    }
    if (!options.emplaceBack(NameToId(cx->names().useGrouping),
                             StringValue(useGrouping))) {
      return false;
    }
  } else {
    if (!options.emplaceBack(NameToId(cx->names().useGrouping),
                             BooleanValue(false))) {
      return false;
    }
  }

  if (!ResolveNotationOptions(cx, nfOptions, &options)) {
    return false;
  }

  auto* signDisplay =
      NewStringCopy<CanGC>(cx, SignDisplayToString(nfOptions.signDisplay));
  if (!signDisplay) {
    return false;
  }
  if (!options.emplaceBack(NameToId(cx->names().signDisplay),
                           StringValue(signDisplay))) {
    return false;
  }

  if (!ResolveRoundingAndTrailingZeroOptions(cx, nfOptions.digitOptions,
                                             &options)) {
    return false;
  }

  
  auto* result = NewPlainObjectWithUniqueNames(cx, options);
  if (!result) {
    return false;
  }
  args.rval().setObject(*result);
  return true;
}




static bool numberFormat_resolvedOptions(JSContext* cx, unsigned argc,
                                         Value* vp) {
  
  CallArgs args = CallArgsFromVp(argc, vp);
  if (!UnwrapNumberFormat(cx, args.mutableThisv())) {
    return false;
  }
  return CallNonGenericMethod<IsNumberFormat, numberFormat_resolvedOptions>(
      cx, args);
}




static bool numberFormat_supportedLocalesOf(JSContext* cx, unsigned argc,
                                            Value* vp) {
  CallArgs args = CallArgsFromVp(argc, vp);

  
  auto* array = SupportedLocalesOf(cx, AvailableLocaleKind::NumberFormat,
                                   args.get(0), args.get(1));
  if (!array) {
    return false;
  }
  args.rval().setObject(*array);
  return true;
}
