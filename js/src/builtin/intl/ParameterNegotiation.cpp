





#include "builtin/intl/ParameterNegotiation.h"

#include "mozilla/Assertions.h"
#include "mozilla/intl/Locale.h"
#include "mozilla/Span.h"
#include "mozilla/TextUtils.h"

#include <algorithm>
#include <stddef.h>

#include "builtin/intl/LocaleNegotiation.h"
#include "builtin/intl/StringAsciiChars.h"
#include "builtin/intl/UsingEnum.h"
#include "builtin/String.h"
#include "js/Conversions.h"
#include "js/ErrorReport.h"
#include "js/Printer.h"
#include "js/Value.h"
#include "vm/StringType.h"

#include "vm/JSObject-inl.h"
#include "vm/ObjectOperations-inl.h"

using namespace js;
using namespace js::intl;

static void ReportInvalidOptionValue(
    JSContext* cx, PropertyName* property, JSLinearString* value,
    JSErrNum errorNumber = JSMSG_INVALID_OPTION_VALUE) {
  if (auto propertyChars = EncodeAscii(cx, property)) {
    if (auto chars = QuoteString(cx, value, '"')) {
      JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr, errorNumber,
                                propertyChars.get(), chars.get());
    }
  }
}

static void ReportInvalidOptionError(JSContext* cx, double number) {
  ToCStringBuf cbuf;
  const char* str = NumberToCString(&cbuf, number);
  MOZ_ASSERT(str);
  JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                            JSMSG_INVALID_DIGITS_VALUE, str);
}




bool js::intl::detail::GetStringOption(
    JSContext* cx, Handle<JSObject*> options, Handle<PropertyName*> property,
    mozilla::Span<const std::string_view> values, JSErrNum errorNumber,
    size_t* result) {
  
  Rooted<JS::Value> value(cx);
  if (!GetProperty(cx, options, options, property, &value)) {
    return false;
  }

  
  if (value.isUndefined()) {
    *result = values.size();
    return true;
  }

  

  
  auto* str = JS::ToString(cx, value);
  if (!str) {
    return false;
  }

  auto* linear = str->ensureLinear(cx);
  if (!linear) {
    return false;
  }

  
  size_t index = 0;
  for (auto allowed : values) {
    if (StringEqualsAscii(linear, allowed.data(), allowed.length())) {
      *result = index;
      return true;
    }
    index++;
  }

  
  ReportInvalidOptionValue(cx, property, linear, errorNumber);
  return false;
}




bool js::intl::GetStringOption(JSContext* cx, JS::Handle<JSObject*> options,
                               JS::Handle<PropertyName*> property,
                               JS::MutableHandle<JSString*> result) {
  
  Rooted<JS::Value> value(cx);
  if (!GetProperty(cx, options, options, property, &value)) {
    return false;
  }

  
  if (value.isUndefined()) {
    result.set(nullptr);
    return true;
  }

  

  
  auto* str = JS::ToString(cx, value);
  if (!str) {
    return false;
  }

  

  
  result.set(str);
  return true;
}




bool js::intl::GetStringOption(JSContext* cx, JS::Handle<JSObject*> options,
                               JS::Handle<PropertyName*> property,
                               JS::MutableHandle<JSLinearString*> result) {
  Rooted<JSString*> string(cx);
  if (!GetStringOption(cx, options, property, &string)) {
    return false;
  }
  if (string) {
    auto* linear = string->ensureLinear(cx);
    if (!linear) {
      return false;
    }
    result.set(linear);
  } else {
    result.set(nullptr);
  }
  return true;
}




bool js::intl::GetBooleanOption(JSContext* cx, Handle<JSObject*> options,
                                Handle<PropertyName*> property,
                                mozilla::Maybe<bool>* result) {
  
  Rooted<JS::Value> value(cx);
  if (!GetProperty(cx, options, options, property, &value)) {
    return false;
  }

  
  if (value.isUndefined()) {
    *result = mozilla::Nothing();
    return true;
  }

  

  
  *result = mozilla::Some(JS::ToBoolean(value));
  return true;
}





bool js::intl::detail::GetBooleanOrStringNumberFormatOption(
    JSContext* cx, Handle<JSObject*> options, Handle<PropertyName*> property,
    mozilla::Span<const std::string_view> stringValues,
    mozilla::Variant<bool, size_t>* result) {
  
  Rooted<JS::Value> value(cx);
  if (!GetProperty(cx, options, options, property, &value)) {
    return false;
  }

  
  if (value.isUndefined()) {
    *result = mozilla::AsVariant(stringValues.size());
    return true;
  }

  
  if (value.isTrue()) {
    
    *result = mozilla::AsVariant(true);
    return true;
  }

  if (!JS::ToBoolean(value)) {
    
    *result = mozilla::AsVariant(false);
    return true;
  }

  
  auto* str = JS::ToString(cx, value);
  if (!str) {
    return false;
  }

  auto* linear = str->ensureLinear(cx);
  if (!linear) {
    return false;
  }

  
  size_t index = 0;
  for (auto stringValue : stringValues) {
    if (StringEqualsAscii(linear, stringValue.data(), stringValue.length())) {
      *result = mozilla::AsVariant(index);
      return true;
    }
    index++;
  }

  
  ReportInvalidOptionValue(cx, property, linear, JSMSG_INVALID_OPTION_VALUE);
  return false;
}




bool js::intl::DefaultNumberOption(JSContext* cx, Handle<JS::Value> value,
                                   int32_t minimum, int32_t maximum,
                                   mozilla::Maybe<int32_t>* result) {
  
  if (value.isUndefined()) {
    *result = mozilla::Nothing();
    return true;
  }

  
  if (value.isInt32()) {
    
    int32_t num = value.toInt32();

    
    if (num < minimum || num > maximum) {
      ReportInvalidOptionError(cx, num);
      return false;
    }

    
    *result = mozilla::Some(num);
    return true;
  }

  
  double num;
  if (!JS::ToNumber(cx, value, &num)) {
    return false;
  }

  
  if (!std::isfinite(num) || num < double(minimum) || num > double(maximum)) {
    ReportInvalidOptionError(cx, num);
    return false;
  }

  
  *result = mozilla::Some(static_cast<int32_t>(std::floor(num)));
  return true;
}




bool js::intl::GetNumberOption(JSContext* cx, Handle<JSObject*> options,
                               Handle<PropertyName*> property, int32_t minimum,
                               int32_t maximum,
                               mozilla::Maybe<int32_t>* result) {
  
  Rooted<JS::Value> value(cx);
  if (!GetProperty(cx, options, options, property, &value)) {
    return false;
  }

  
  return DefaultNumberOption(cx, value, minimum, maximum, result);
}

static constexpr std::string_view LocaleMatcherToString(
    LocaleMatcher localeMatcher) {
#ifndef USING_ENUM
  using enum LocaleMatcher;
#else
  USING_ENUM(LocaleMatcher, BestFit, Lookup);
#endif
  switch (localeMatcher) {
    case BestFit:
      return "best fit";
    case Lookup:
      return "lookup";
  }
  MOZ_CRASH("invalid locale matcher");
}

bool js::intl::GetLocaleMatcherOption(JSContext* cx, Handle<JSObject*> options,
                                      JSErrNum errorNumber,
                                      LocaleMatcher* result) {
  static constexpr auto matchers = MapOptions<LocaleMatcherToString>(
      LocaleMatcher::BestFit, LocaleMatcher::Lookup);
  return GetStringOption(cx, options, cx->names().localeMatcher, matchers,
                         LocaleMatcher::BestFit, errorNumber, result);
}

static auto ToUnicodeKeySpan(UnicodeExtensionKey key) {
#ifndef USING_ENUM
  using enum UnicodeExtensionKey;
#else
  USING_ENUM(UnicodeExtensionKey, Calendar, Collation, CollationCaseFirst,
             CollationNumeric, HourCycle, NumberingSystem);
#endif
  switch (key) {
    case Calendar:
      return mozilla::MakeStringSpan("ca");
    case Collation:
      return mozilla::MakeStringSpan("co");
    case CollationCaseFirst:
      return mozilla::MakeStringSpan("kf");
    case CollationNumeric:
      return mozilla::MakeStringSpan("kn");
    case HourCycle:
      return mozilla::MakeStringSpan("hc");
    case NumberingSystem:
      return mozilla::MakeStringSpan("nu");
  }
  MOZ_CRASH("invalid Unicode extension key");
}

static Handle<PropertyName*> ToPropertyName(JSContext* cx,
                                            UnicodeExtensionKey key) {
#ifndef USING_ENUM
  using enum UnicodeExtensionKey;
#else
  USING_ENUM(UnicodeExtensionKey, Calendar, Collation, CollationCaseFirst,
             CollationNumeric, HourCycle, NumberingSystem);
#endif
  switch (key) {
    case Calendar:
      return cx->names().calendar;
    case Collation:
      return cx->names().collation;
    case CollationCaseFirst:
      return cx->names().caseFirst;
    case CollationNumeric:
      return cx->names().numeric;
    case HourCycle:
      return cx->names().hourCycle;
    case NumberingSystem:
      return cx->names().numberingSystem;
  }
  MOZ_CRASH("invalid Unicode extension key");
}





static JSLinearString* ValidateAndCanonicalizeUnicodeExtensionType(
    JSContext* cx, UnicodeExtensionKey key,
    Handle<JSLinearString*> unicodeType) {
  
  
  if (unicodeType->empty() || !StringIsAscii(unicodeType)) {
    ReportInvalidOptionValue(cx, ToPropertyName(cx, key), unicodeType);
    return nullptr;
  }

  bool isValid = false;
  const char* replacement = nullptr;
  UniqueChars unicodeTypeChars = nullptr;
  do {
    
    
    
    StringAsciiChars chars(unicodeType);
    if (!chars.init(cx)) {
      return nullptr;
    }

    
    
    JS::AutoSuppressGCAnalysis nogc;

    
    isValid =
        mozilla::intl::LocaleParser::CanParseUnicodeExtensionType(chars).isOk();
    if (!isValid) {
      break;
    }

    mozilla::Span<const char> type = chars;

    
    bool hasUpperCase = std::any_of(type.begin(), type.end(), [](auto ch) {
      return mozilla::IsAsciiUppercaseAlpha(ch);
    });

    
    if (hasUpperCase) {
      unicodeTypeChars = cx->make_pod_array<char>(type.size());
      if (!unicodeTypeChars) {
        return nullptr;
      }

      
      mozilla::intl::AsciiToLowerCase(type.data(), type.size(),
                                      unicodeTypeChars.get());
      type = {unicodeTypeChars.get(), type.size()};
    }

    
    auto ukey = ToUnicodeKeySpan(key);
    replacement =
        mozilla::intl::Locale::ReplaceUnicodeExtensionType(ukey, type);
  } while (false);

  if (!isValid) {
    ReportInvalidOptionValue(cx, ToPropertyName(cx, key), unicodeType);
    return nullptr;
  }
  if (replacement) {
    return NewStringCopyZ<CanGC>(cx, replacement);
  }
  if (unicodeTypeChars) {
    return NewStringCopyN<CanGC>(cx, unicodeTypeChars.get(),
                                 unicodeType->length());
  }
  return unicodeType;
}




bool js::intl::GetUnicodeExtensionOption(
    JSContext* cx, JS::Handle<JSObject*> options, UnicodeExtensionKey key,
    JS::MutableHandle<JSLinearString*> result) {
  
  Rooted<JS::Value> value(cx);
  if (!GetProperty(cx, options, options, ToPropertyName(cx, key), &value)) {
    return false;
  }

  
  if (value.isUndefined()) {
    result.set(nullptr);
    return true;
  }

  

  
  auto* str = JS::ToString(cx, value);
  if (!str) {
    return false;
  }

  Rooted<JSLinearString*> linear(cx, str->ensureLinear(cx));
  if (!linear) {
    return false;
  }

  

  
  auto* unicodeType =
      ValidateAndCanonicalizeUnicodeExtensionType(cx, key, linear);
  if (!unicodeType) {
    return false;
  }

  result.set(unicodeType);
  return true;
}
