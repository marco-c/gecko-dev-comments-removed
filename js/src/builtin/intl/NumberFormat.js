













function SetNumberFormatDigitOptions(
  lazyData,
  options,
  mnfdDefault,
  mxfdDefault,
  notation
) {
  assert(IsObject(options), "SetNumberFormatDigitOptions");
  assert(typeof mnfdDefault === "number", "SetNumberFormatDigitOptions");
  assert(typeof mxfdDefault === "number", "SetNumberFormatDigitOptions");
  assert(mnfdDefault <= mxfdDefault, "SetNumberFormatDigitOptions");
  assert(typeof notation === "string", "SetNumberFormatDigitOptions");

  
  var mnid = GetNumberOption(options, "minimumIntegerDigits", 1, 21, 1);
  var mnfd = options.minimumFractionDigits;
  var mxfd = options.maximumFractionDigits;
  var mnsd = options.minimumSignificantDigits;
  var mxsd = options.maximumSignificantDigits;

  
  lazyData.minimumIntegerDigits = mnid;

  
  var roundingIncrement = GetNumberOption(
    options,
    "roundingIncrement",
    1,
    5000,
    1
  );

  
  switch (roundingIncrement) {
    case 1:
    case 2:
    case 5:
    case 10:
    case 20:
    case 25:
    case 50:
    case 100:
    case 200:
    case 250:
    case 500:
    case 1000:
    case 2000:
    case 2500:
    case 5000:
      break;
    default:
      ThrowRangeError(
        JSMSG_INVALID_OPTION_VALUE,
        "roundingIncrement",
        roundingIncrement
      );
  }

  
  var roundingMode = GetOption(
    options,
    "roundingMode",
    "string",
    [
      "ceil",
      "floor",
      "expand",
      "trunc",
      "halfCeil",
      "halfFloor",
      "halfExpand",
      "halfTrunc",
      "halfEven",
    ],
    "halfExpand"
  );

  
  var roundingPriority = GetOption(
    options,
    "roundingPriority",
    "string",
    ["auto", "morePrecision", "lessPrecision"],
    "auto"
  );

  
  var trailingZeroDisplay = GetOption(
    options,
    "trailingZeroDisplay",
    "string",
    ["auto", "stripIfInteger"],
    "auto"
  );

  

  
  if (roundingIncrement !== 1) {
    mxfdDefault = mnfdDefault;
  }

  
  lazyData.roundingIncrement = roundingIncrement;

  
  lazyData.roundingMode = roundingMode;

  
  lazyData.trailingZeroDisplay = trailingZeroDisplay;

  
  var hasSignificantDigits = mnsd !== undefined || mxsd !== undefined;

  
  var hasFractionDigits = mnfd !== undefined || mxfd !== undefined;

  
  var needSignificantDigits =
    roundingPriority !== "auto" || hasSignificantDigits;

  
  var needFractionalDigits =
    roundingPriority !== "auto" ||
    !(hasSignificantDigits || (!hasFractionDigits && notation === "compact"));

  
  if (needSignificantDigits) {
    
    if (hasSignificantDigits) {
      
      mnsd = DefaultNumberOption(mnsd, 1, 21, 1);
      lazyData.minimumSignificantDigits = mnsd;

      
      mxsd = DefaultNumberOption(mxsd, mnsd, 21, 21);
      lazyData.maximumSignificantDigits = mxsd;
    } else {
      
      lazyData.minimumSignificantDigits = 1;

      
      lazyData.maximumSignificantDigits = 21;
    }
  }

  
  if (needFractionalDigits) {
    
    if (hasFractionDigits) {
      
      mnfd = DefaultNumberOption(mnfd, 0, 100, undefined);

      
      mxfd = DefaultNumberOption(mxfd, 0, 100, undefined);

      
      if (mnfd === undefined) {
        assert(
          mxfd !== undefined,
          "mxfd isn't undefined when mnfd is undefined"
        );
        mnfd = std_Math_min(mnfdDefault, mxfd);
      }

      
      else if (mxfd === undefined) {
        mxfd = std_Math_max(mxfdDefault, mnfd);
      }

      
      else if (mnfd > mxfd) {
        ThrowRangeError(JSMSG_INVALID_DIGITS_VALUE, mxfd);
      }

      
      lazyData.minimumFractionDigits = mnfd;

      
      lazyData.maximumFractionDigits = mxfd;
    } else {
      
      lazyData.minimumFractionDigits = mnfdDefault;

      
      lazyData.maximumFractionDigits = mxfdDefault;
    }
  }

  
  if (!needSignificantDigits && !needFractionalDigits) {
    assert(!hasSignificantDigits, "bad significant digits in fallback case");
    assert(
      roundingPriority === "auto",
      `bad rounding in fallback case: ${roundingPriority}`
    );
    assert(
      notation === "compact",
      `bad notation in fallback case: ${notation}`
    );

    
    lazyData.minimumFractionDigits = 0;
    lazyData.maximumFractionDigits = 0;
    lazyData.minimumSignificantDigits = 1;
    lazyData.maximumSignificantDigits = 2;
    lazyData.roundingPriority = "morePrecision";
  } else {
    
    
    
    
    lazyData.roundingPriority = roundingPriority;
  }

  
  if (roundingIncrement !== 1) {
    
    
    
    
    if (roundingPriority !== "auto") {
      ThrowTypeError(
        JSMSG_INVALID_NUMBER_OPTION,
        "roundingIncrement",
        "roundingPriority"
      );
    }
    if (hasSignificantDigits) {
      ThrowTypeError(
        JSMSG_INVALID_NUMBER_OPTION,
        "roundingIncrement",
        "minimumSignificantDigits"
      );
    }

    
    
    
    if (
      lazyData.minimumFractionDigits !==
      lazyData.maximumFractionDigits
    ) {
      ThrowRangeError(JSMSG_UNEQUAL_FRACTION_DIGITS);
    }
  }
}

