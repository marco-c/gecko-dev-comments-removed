





#ifndef builtin_intl_ParameterNegotiation_h
#define builtin_intl_ParameterNegotiation_h

#include "mozilla/Assertions.h"
#include "mozilla/Maybe.h"
#include "mozilla/Span.h"
#include "mozilla/Variant.h"

#include <array>
#include <stddef.h>
#include <stdint.h>
#include <string_view>
#include <utility>

#include "js/friend/ErrorMessages.h"
#include "js/RootingAPI.h"
#include "js/TypeDecls.h"
#include "vm/StringType.h"

namespace js::intl {




template <typename Option, size_t N>
using OptionValues =
    std::pair<std::array<Option, N>, std::array<std::string_view, N>>;





template <auto F>
constexpr auto MapOptions(auto... args) {
  return std::pair{std::array{(args)...}, std::array{F(args)...}};
}

namespace detail {







bool GetStringOption(JSContext* cx, JS::Handle<JSObject*> options,
                     JS::Handle<PropertyName*> property,
                     mozilla::Span<const std::string_view> values,
                     JSErrNum errorNumber, size_t* result);
}  








template <typename Option, size_t N>
inline bool GetStringOption(JSContext* cx, JS::Handle<JSObject*> options,
                            JS::Handle<PropertyName*> property,
                            const OptionValues<Option, N>& values,
                            Option defaultValue, JSErrNum errorNumber,
                            Option* result) {
  size_t index;
  if (!detail::GetStringOption(cx, options, property, values.second,
                               errorNumber, &index)) {
    return false;
  }
  if (index < N) {
    *result = values.first[index];
  } else {
    *result = defaultValue;
  }
  return true;
}








template <typename Option, size_t N>
inline bool GetStringOption(JSContext* cx, JS::Handle<JSObject*> options,
                            JS::Handle<PropertyName*> property,
                            const OptionValues<Option, N>& values,
                            Option defaultValue, Option* result) {
  return GetStringOption(cx, options, property, values, defaultValue,
                         JSMSG_INVALID_OPTION_VALUE, result);
}








template <typename Option, size_t N>
inline bool GetStringOption(JSContext* cx, JS::Handle<JSObject*> options,
                            JS::Handle<PropertyName*> property,
                            const OptionValues<Option, N>& values,
                            mozilla::Maybe<Option>* result) {
  size_t index;
  if (!detail::GetStringOption(cx, options, property, values.second,
                               JSMSG_INVALID_OPTION_VALUE, &index)) {
    return false;
  }
  if (index < N) {
    *result = mozilla::Some(values.first[index]);
  } else {
    *result = mozilla::Nothing();
  }
  return true;
}







bool GetStringOption(JSContext* cx, JS::Handle<JSObject*> options,
                     JS::Handle<PropertyName*> property,
                     JS::MutableHandle<JSString*> result);







bool GetStringOption(JSContext* cx, JS::Handle<JSObject*> options,
                     JS::Handle<PropertyName*> property,
                     JS::MutableHandle<JSLinearString*> result);







bool GetBooleanOption(JSContext* cx, JS::Handle<JSObject*> options,
                      JS::Handle<PropertyName*> property,
                      mozilla::Maybe<bool>* result);

namespace detail {







bool GetBooleanOrStringNumberFormatOption(
    JSContext* cx, JS::Handle<JSObject*> options,
    JS::Handle<PropertyName*> property,
    mozilla::Span<const std::string_view> stringValues,
    mozilla::Variant<bool, size_t>* result);
}  









template <typename Option, size_t N>
inline bool GetBooleanOrStringNumberFormatOption(
    JSContext* cx, JS::Handle<JSObject*> options,
    JS::Handle<PropertyName*> property,
    const OptionValues<Option, N>& stringValues, Option fallback,
    mozilla::Variant<bool, Option>* result) {
  mozilla::Variant<bool, size_t> boolOrIndex{false};
  if (!detail::GetBooleanOrStringNumberFormatOption(
          cx, options, property, stringValues.second, &boolOrIndex)) {
    return false;
  }
  if (boolOrIndex.is<bool>()) {
    *result = mozilla::AsVariant(boolOrIndex.extract<bool>());
  } else {
    size_t index = boolOrIndex.extract<size_t>();
    if (index < N) {
      *result = mozilla::AsVariant(stringValues.first[index]);
    } else {
      *result = mozilla::AsVariant(fallback);
    }
  }
  return true;
}







bool DefaultNumberOption(JSContext* cx, JS::Handle<JS::Value> value,
                         int32_t minimum, int32_t maximum,
                         mozilla::Maybe<int32_t>* result);







inline bool DefaultNumberOption(JSContext* cx, JS::Handle<JS::Value> value,
                                int32_t minimum, int32_t maximum,
                                int32_t fallback, int32_t* result) {
  MOZ_ASSERT(minimum <= fallback && fallback <= maximum);

  mozilla::Maybe<int32_t> r;
  if (!DefaultNumberOption(cx, value, minimum, maximum, &r)) {
    return false;
  }

  *result = r.valueOr(fallback);
  return true;
}







bool GetNumberOption(JSContext* cx, JS::Handle<JSObject*> options,
                     JS::Handle<PropertyName*> property, int32_t minimum,
                     int32_t maximum, mozilla::Maybe<int32_t>* result);







inline bool GetNumberOption(JSContext* cx, JS::Handle<JSObject*> options,
                            JS::Handle<PropertyName*> property, int32_t minimum,
                            int32_t maximum, int32_t fallback,
                            int32_t* result) {
  MOZ_ASSERT(minimum <= fallback && fallback <= maximum);

  mozilla::Maybe<int32_t> r;
  if (!GetNumberOption(cx, options, property, minimum, maximum, &r)) {
    return false;
  }

  *result = r.valueOr(fallback);
  return true;
}

enum class LocaleMatcher { BestFit, Lookup };




bool GetLocaleMatcherOption(JSContext* cx, JS::Handle<JSObject*> options,
                            JSErrNum errorNumber, LocaleMatcher* result);




inline bool GetLocaleMatcherOption(JSContext* cx, JS::Handle<JSObject*> options,
                                   LocaleMatcher* result) {
  return GetLocaleMatcherOption(cx, options, JSMSG_INVALID_OPTION_VALUE,
                                result);
}

enum class UnicodeExtensionKey : uint8_t;





bool GetUnicodeExtensionOption(JSContext* cx, JS::Handle<JSObject*> options,
                               UnicodeExtensionKey key,
                               JS::MutableHandle<JSLinearString*> result);

}  

#endif 
