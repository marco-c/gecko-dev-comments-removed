





#include "builtin/intl/LocaleNegotiation.h"

#include "mozilla/Assertions.h"
#include "mozilla/EnumeratedRange.h"
#include "mozilla/intl/Calendar.h"
#include "mozilla/intl/Collator.h"
#include "mozilla/intl/Locale.h"
#include "mozilla/intl/NumberingSystem.h"
#include "mozilla/Maybe.h"
#include "mozilla/Range.h"

#include <algorithm>
#include <array>
#include <iterator>
#include <stddef.h>
#include <utility>

#include "builtin/Array.h"
#include "builtin/intl/CommonFunctions.h"
#include "builtin/intl/FormatBuffer.h"
#include "builtin/intl/NumberingSystemsGenerated.h"
#include "builtin/intl/SharedIntlData.h"
#include "builtin/intl/StringAsciiChars.h"
#include "js/Conversions.h"
#include "js/Result.h"
#include "util/StringBuilder.h"
#include "vm/ArrayObject.h"
#include "vm/GlobalObject.h"
#include "vm/JSContext.h"
#include "vm/PlainObject.h"
#include "vm/Realm.h"
#include "vm/StringType.h"

#include "vm/NativeObject-inl.h"
#include "vm/ObjectOperations-inl.h"

using namespace js;
using namespace js::intl;

static constexpr auto UnicodeExtensionKeyNames() {
  mozilla::EnumeratedArray<UnicodeExtensionKey, const char*> names;
  names[UnicodeExtensionKey::Calendar] = "ca";
  names[UnicodeExtensionKey::Collation] = "co";
  names[UnicodeExtensionKey::CollationCaseFirst] = "kf";
  names[UnicodeExtensionKey::CollationNumeric] = "kn";
  names[UnicodeExtensionKey::HourCycle] = "hc";
  names[UnicodeExtensionKey::NumberingSystem] = "nu";
  return names;
}

template <typename CharT>
static mozilla::Maybe<UnicodeExtensionKey> ToUnicodeExtensionKey(
    std::basic_string_view<CharT> subtag) {
  MOZ_ASSERT(subtag.length() == 2);

  static constexpr auto names = UnicodeExtensionKeyNames();
  for (auto key : mozilla::MakeInclusiveEnumeratedRange(
           mozilla::MaxEnumValue<UnicodeExtensionKey>::value)) {
    auto name = names[key];
    if (name[0] == subtag[0] && name[1] == subtag[1]) {
      return mozilla::Some(key);
    }
  }
  return mozilla::Nothing();
}

static auto UnicodeExtensionPropertyKey(JSContext* cx,
                                        UnicodeExtensionKey key) {
  static constexpr auto names = UnicodeExtensionKeyNames();
  return JS::PropertyKey::NonIntAtom(cx->staticStrings().lookup(names[key], 2));
}

static bool AssertCanonicalLocaleWithoutUnicodeExtension(
    JSContext* cx, Handle<JSLinearString*> locale) {
#ifdef DEBUG
  MOZ_ASSERT(StringIsAscii(locale), "language tags are ASCII-only");

  
  mozilla::intl::Locale tag;

  using ParserError = mozilla::intl::LocaleParser::ParserError;
  mozilla::Result<mozilla::Ok, ParserError> parse_result = Ok();
  {
    intl::StringAsciiChars chars(locale);
    if (!chars.init(cx)) {
      return false;
    }

    parse_result = mozilla::intl::LocaleParser::TryParse(chars, tag);
  }

  if (parse_result.isErr()) {
    MOZ_ASSERT(parse_result.unwrapErr() == ParserError::OutOfMemory,
               "locale is a structurally valid language tag");

    intl::ReportInternalError(cx);
    return false;
  }

  MOZ_ASSERT(!tag.GetUnicodeExtension(),
             "locale must contain no Unicode extensions");

  if (auto result = tag.Canonicalize(); result.isErr()) {
    MOZ_ASSERT(result.unwrapErr() !=
               mozilla::intl::Locale::CanonicalizationError::DuplicateVariant);
    intl::ReportInternalError(cx);
    return false;
  }

  intl::FormatBuffer<char, intl::INITIAL_CHAR_BUFFER_SIZE> buffer(cx);
  if (auto result = tag.ToString(buffer); result.isErr()) {
    intl::ReportInternalError(cx, result.unwrapErr());
    return false;
  }

  MOZ_ASSERT(StringEqualsAscii(locale, buffer.data(), buffer.length()),
             "locale is a canonicalized language tag");
#endif
  return true;
}

static bool SameOrParentLocale(const JSLinearString* locale,
                               const JSLinearString* otherLocale) {
  
  if (locale->length() == otherLocale->length()) {
    return EqualStrings(locale, otherLocale);
  }

  
  if (locale->length() < otherLocale->length()) {
    return HasSubstringAt(otherLocale, locale, 0) &&
           otherLocale->latin1OrTwoByteChar(locale->length()) == '-';
  }

  return false;
}











static JS::Result<JSLinearString*> BestAvailableLocale(
    JSContext* cx, AvailableLocaleKind availableLocales,
    Handle<JSLinearString*> locale, Handle<JSLinearString*> defaultLocale) {
  
  
  
  
  
  
  
  
  
  

  intl::SharedIntlData& sharedIntlData = cx->runtime()->sharedIntlData.ref();

  auto findLast = [](const auto* chars, size_t length) {
    auto rbegin = std::make_reverse_iterator(chars + length);
    auto rend = std::make_reverse_iterator(chars);
    auto p = std::find(rbegin, rend, '-');

    
    
    ptrdiff_t r = std::distance(chars, p.base());
    MOZ_ASSERT(r == std::distance(p, rend));

    
    
    
    return r - 1;
  };

  if (!AssertCanonicalLocaleWithoutUnicodeExtension(cx, locale)) {
    return cx->alreadyReportedError();
  }

  
  Rooted<JSLinearString*> candidate(cx, locale);

  
  while (true) {
    
    bool supported = false;
    if (!sharedIntlData.isAvailableLocale(cx, availableLocales, candidate,
                                          &supported)) {
      return cx->alreadyReportedError();
    }
    if (supported) {
      return candidate.get();
    }

    if (defaultLocale && SameOrParentLocale(candidate, defaultLocale)) {
      return candidate.get();
    }

    
    ptrdiff_t pos;
    if (candidate->hasLatin1Chars()) {
      JS::AutoCheckCannotGC nogc;
      pos = findLast(candidate->latin1Chars(nogc), candidate->length());
    } else {
      JS::AutoCheckCannotGC nogc;
      pos = findLast(candidate->twoByteChars(nogc), candidate->length());
    }

    if (pos < 0) {
      return nullptr;
    }

    
    size_t length = size_t(pos);
    if (length >= 2 && candidate->latin1OrTwoByteChar(length - 2) == '-') {
      length -= 2;
    }

    
    candidate = NewDependentString(cx, candidate, 0, length);
    if (!candidate) {
      return cx->alreadyReportedError();
    }
  }
}





bool js::intl::BestAvailableLocale(JSContext* cx,
                                   AvailableLocaleKind availableLocales,
                                   Handle<JSLinearString*> locale,
                                   Handle<JSLinearString*> defaultLocale,
                                   MutableHandle<JSLinearString*> result) {
  JSLinearString* res;
  JS_TRY_VAR_OR_RETURN_FALSE(
      cx, res,
      BestAvailableLocale(cx, availableLocales, locale, defaultLocale));
  if (res) {
    result.set(res);
  } else {
    result.set(nullptr);
  }
  return true;
}

template <typename CharT>
static size_t BaseNameLength(mozilla::Range<const CharT> locale) {
  
  for (size_t i = 0; i < locale.length(); i++) {
    if (locale[i] == '-') {
      MOZ_RELEASE_ASSERT(i + 2 < locale.length(), "invalid locale");
      if (locale[i + 2] == '-') {
        return i;
      }
    }
  }
  return locale.length();
}

static size_t BaseNameLength(JSLinearString* locale) {
  JS::AutoCheckCannotGC nogc;
  if (locale->hasLatin1Chars()) {
    return BaseNameLength(locale->latin1Range(nogc));
  }
  return BaseNameLength(locale->twoByteRange(nogc));
}









static bool LookupSupportedLocales(
    JSContext* cx, AvailableLocaleKind availableLocales,
    Handle<LocalesList> requestedLocales,
    MutableHandle<LocalesList> supportedLocales) {
  
  MOZ_ASSERT(supportedLocales.empty());

  Rooted<JSLinearString*> defaultLocale(
      cx, cx->global()->globalIntlData().defaultLocale(cx));
  if (!defaultLocale) {
    return false;
  }

  
  Rooted<JSLinearString*> noExtensionsLocale(cx);
  Rooted<JSLinearString*> availableLocale(cx);
  for (size_t i = 0; i < requestedLocales.length(); i++) {
    auto locale = requestedLocales[i];

    
    
    
    noExtensionsLocale =
        NewDependentString(cx, locale, 0, BaseNameLength(locale));
    if (!noExtensionsLocale) {
      return false;
    }

    
    JSLinearString* availableLocale;
    JS_TRY_VAR_OR_RETURN_FALSE(
        cx, availableLocale,
        BestAvailableLocale(cx, availableLocales, noExtensionsLocale,
                            defaultLocale));

    
    if (availableLocale) {
      if (!supportedLocales.append(locale)) {
        return false;
      }
    }
  }

  
  return true;
}








static bool SupportedLocales(JSContext* cx,
                             AvailableLocaleKind availableLocales,
                             Handle<LocalesList> requestedLocales,
                             Handle<Value> options,
                             MutableHandle<LocalesList> supportedLocales) {
  
  if (!options.isUndefined()) {
    
    Rooted<JSObject*> obj(cx, ToObject(cx, options));
    if (!obj) {
      return false;
    }

    
    Rooted<Value> localeMatcher(cx);
    if (!GetProperty(cx, obj, obj, cx->names().localeMatcher, &localeMatcher)) {
      return false;
    }

    if (!localeMatcher.isUndefined()) {
      JSString* str = ToString(cx, localeMatcher);
      if (!str) {
        return false;
      }

      JSLinearString* linear = str->ensureLinear(cx);
      if (!linear) {
        return false;
      }

      if (!StringEqualsLiteral(linear, "lookup") &&
          !StringEqualsLiteral(linear, "best fit")) {
        if (auto chars = QuoteString(cx, linear)) {
          JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                    JSMSG_INVALID_LOCALE_MATCHER, chars.get());
        }
        return false;
      }
    }
  }

  
  
  
  return LookupSupportedLocales(cx, availableLocales, requestedLocales,
                                supportedLocales);
}













template <typename CharT>
static std::pair<size_t, size_t> FindUnicodeExtensionSequence(
    mozilla::Range<const CharT> locale) {
  
  
  
  
  
  if (locale.length() < (2 + 5)) {
    return {};
  }

  
  
  
  
  
  
  
  size_t start = 0;
  for (size_t i = 2; i <= locale.length() - 5; i++) {
    
    if (locale[i] == '-' && locale[i + 1] == 'u' && locale[i + 2] == '-') {
      start = i;
      break;
    }

    
    
    if (locale[i] == '-' && locale[i + 1] == 'x' && locale[i + 2] == '-') {
      break;
    }
  }

  
  if (start == 0) {
    return {};
  }

  
  
  
  
  
  
  
  for (size_t i = start + 5; i <= locale.length() - 4; i++) {
    if (locale[i] != '-') {
      continue;
    }
    if (locale[i + 2] == '-') {
      return {start, i};
    }

    
    
    i += 2;
  }

  
  
  return {start, locale.length()};
}

static auto FindUnicodeExtensionSequence(const JSLinearString* locale) {
  JS::AutoCheckCannotGC nogc;
  if (locale->hasLatin1Chars()) {
    return FindUnicodeExtensionSequence(locale->latin1Range(nogc));
  }
  return FindUnicodeExtensionSequence(locale->twoByteRange(nogc));
}

void js::intl::LookupMatcherResult::trace(JSTracer* trc) {
  TraceNullableRoot(trc, &locale_, "LookupMatcherResult::locale");
  TraceNullableRoot(trc, &extension_, "LookupMatcherResult::extension");
}




bool js::intl::LookupMatcher(JSContext* cx,
                             AvailableLocaleKind availableLocales,
                             Handle<ArrayObject*> locales,
                             MutableHandle<LookupMatcherResult> result) {
  MOZ_RELEASE_ASSERT(IsPackedArray(locales));

  Rooted<JSLinearString*> defaultLocale(
      cx, cx->global()->globalIntlData().defaultLocale(cx));
  if (!defaultLocale) {
    return false;
  }

  

  
  Rooted<JSLinearString*> locale(cx);
  Rooted<JSLinearString*> noExtensionsLocale(cx);
  Rooted<JSLinearString*> availableLocale(cx);
  for (size_t i = 0, length = locales->length(); i < length; i++) {
    locale = locales->getDenseElement(i).toString()->ensureLinear(cx);
    if (!locale) {
      return false;
    }

    
    
    
    noExtensionsLocale =
        NewDependentString(cx, locale, 0, BaseNameLength(locale));
    if (!noExtensionsLocale) {
      return false;
    }

    
    JS_TRY_VAR_OR_RETURN_FALSE(
        cx, availableLocale,
        BestAvailableLocale(cx, availableLocales, noExtensionsLocale,
                            defaultLocale));

    
    if (availableLocale) {
      

      
      
      
      
      JSLinearString* extension = nullptr;
      if (locale->length() > noExtensionsLocale->length()) {
        auto [startOfUnicodeExtensions, endOfUnicodeExtensions] =
            FindUnicodeExtensionSequence(locale);

        
        if (startOfUnicodeExtensions) {
          MOZ_ASSERT(startOfUnicodeExtensions < endOfUnicodeExtensions);
          MOZ_ASSERT(endOfUnicodeExtensions <= locale->length());

          extension = NewDependentString(
              cx, locale, startOfUnicodeExtensions,
              endOfUnicodeExtensions - startOfUnicodeExtensions);
          if (!extension) {
            return false;
          }
        }
      }

      
      result.set({availableLocale, extension});
      return true;
    }
  }

  
  result.set({defaultLocale, nullptr});
  return true;
}

void js::intl::LocaleOptions::trace(JSTracer* trc) {
  for (auto& extension : extensions_) {
    TraceNullableRoot(trc, &extension, "LocaleOptions::extension");
  }
}

JSLinearString* js::intl::ResolvedLocale::toLocale(JSContext* cx) const {
  if (keywords_.isEmpty()) {
    return dataLocale_;
  }

  JSStringBuilder sb(cx);
  if (!sb.append(dataLocale_)) {
    return nullptr;
  }
  if (!sb.append("-u")) {
    return nullptr;
  }
  for (auto key : keywords_) {
    static constexpr auto names = UnicodeExtensionKeyNames();

    if (!sb.append('-') || !sb.append(names[key], 2)) {
      return nullptr;
    }

    auto* extension = extensions_[key];
    MOZ_ASSERT(extension);

    if (!extension->empty() && !StringEqualsLiteral(extension, "true")) {
      if (!sb.append('-') || !sb.append(extension)) {
        return nullptr;
      }
    }
  }
  return sb.finishString();
}

void js::intl::ResolvedLocale::trace(JSTracer* trc) {
  TraceNullableRoot(trc, &dataLocale_, "ResolvedLocale::dataLocale");
  for (auto& extension : extensions_) {
    TraceNullableRoot(trc, &extension, "ResolvedLocale::extension");
  }
}




class UnicodeExtensionKeywords {
  
  using Value = std::pair<size_t, size_t>;

  mozilla::EnumeratedArray<UnicodeExtensionKey, Value> keywords{};

 public:
  


  bool has(UnicodeExtensionKey key) const { return keywords[key].first > 0; }

  


  const auto& get(UnicodeExtensionKey key) const { return keywords[key]; }

  


  auto& get(UnicodeExtensionKey key) { return keywords[key]; }
};




template <typename CharT>
static auto UnicodeExtensionComponents(
    std::basic_string_view<CharT> extension) {
  
  MOZ_ASSERT(std::all_of(extension.begin(), extension.end(), [](auto ch) {
    return mozilla::IsAscii(ch) && !mozilla::IsAsciiUppercaseAlpha(ch);
  }));

  
  MOZ_ASSERT(extension.length() >= 5);
  MOZ_ASSERT(extension[0] == '-');
  MOZ_ASSERT(extension[1] == 'u');
  MOZ_ASSERT(extension[2] == '-');

  

  
  UnicodeExtensionKeywords keywords{};

  
  mozilla::Maybe<UnicodeExtensionKey> key{};

  
  for (size_t k = 3; k < extension.length();) {
    
    size_t e = extension.find('-', k);

    
    size_t len = (e == extension.npos ? extension.length() : e) - k;

    
    auto subtag = extension.substr(k, len);

    
    MOZ_ASSERT(len >= 2);

    
    if (len == 2) {
      key = ToUnicodeExtensionKey(subtag);

      if (key && !keywords.has(*key)) {
        
        keywords.get(*key) = {k + 3, 0};
      } else {
        
        key = mozilla::Nothing();
      }
    } else if (key) {
      
      auto& keyword = keywords.get(*key);
      if (keyword.second == 0) {
        keyword.second = len;
      } else {
        keyword.second += 1 + len;
      }
    }

    
    k = k + len + 1;
  }

  
  return keywords;
}




static auto UnicodeExtensionComponents(const JSLinearString* extension) {
  MOZ_ASSERT(StringIsAscii(extension));

  JS::AutoCheckCannotGC nogc;
  if (extension->hasLatin1Chars()) {
    auto* chars = extension->latin1Chars(nogc);
    std::string_view sv{reinterpret_cast<const char*>(chars),
                        extension->length()};
    return UnicodeExtensionComponents(sv);
  }
  auto* chars = extension->twoByteChars(nogc);
  std::u16string_view sv{chars, extension->length()};
  return UnicodeExtensionComponents(sv);
}





static bool IsSupportedCalendar(JSContext* cx, Handle<JSLinearString*> loc,
                                Handle<JSLinearString*> string, bool* result) {
  MOZ_ASSERT(StringIsAscii(string));

  UniqueChars locale = intl::EncodeLocale(cx, loc);
  if (!locale) {
    return false;
  }

  auto keywords =
      mozilla::intl::Calendar::GetBcp47KeywordValuesForLocale(locale.get());
  if (keywords.isErr()) {
    intl::ReportInternalError(cx, keywords.unwrapErr());
    return false;
  }

  for (auto keyword : keywords.unwrap()) {
    if (keyword.isErr()) {
      intl::ReportInternalError(cx);
      return false;
    }
    auto calendar = keyword.unwrap();

    if (StringEqualsAscii(string, calendar.data(), calendar.size())) {
      *result = true;
      return true;
    }
  }

  *result = false;
  return true;
}





static bool IsSupportedCollation(JSContext* cx, Handle<JSLinearString*> loc,
                                 Handle<JSLinearString*> string, bool* result) {
  MOZ_ASSERT(StringIsAscii(string));

  UniqueChars locale = intl::EncodeLocale(cx, loc);
  if (!locale) {
    return false;
  }

  auto keywords =
      mozilla::intl::Collator::GetBcp47KeywordValuesForLocale(locale.get());
  if (keywords.isErr()) {
    ReportInternalError(cx, keywords.unwrapErr());
    return false;
  }

  for (auto keyword : keywords.unwrap()) {
    if (keyword.isErr()) {
      ReportInternalError(cx);
      return false;
    }
    auto collation = keyword.unwrap();

    
    
    
    
    
    static constexpr auto standard = mozilla::MakeStringSpan("standard");
    static constexpr auto search = mozilla::MakeStringSpan("search");
    if (collation == standard || collation == search) {
      continue;
    }

    if (StringEqualsAscii(string, collation.data(), collation.size())) {
      *result = true;
      return true;
    }
  }

  *result = false;
  return true;
}





template <typename CharT>
static bool IsSupportedCollationCaseFirst(mozilla::Range<const CharT> string) {
  
  static constexpr auto caseFirst = std::to_array<std::string_view>({
      "false",
      "lower",
      "upper",
  });

  return std::any_of(caseFirst.begin(), caseFirst.end(), [&](const auto& a) {
    return a.length() == string.length() &&
           EqualChars(a.data(), string.begin().get(), a.length());
  });
}

static bool IsSupportedCollationCaseFirst(const JSLinearString* string) {
  MOZ_ASSERT(StringIsAscii(string));

  JS::AutoCheckCannotGC nogc;
  if (string->hasLatin1Chars()) {
    return IsSupportedCollationCaseFirst(string->latin1Range(nogc));
  }
  return IsSupportedCollationCaseFirst(string->twoByteRange(nogc));
}





template <typename CharT>
static bool IsSupportedCollationNumeric(mozilla::Range<const CharT> string) {
  
  static constexpr auto numeric = std::to_array<std::string_view>({
      "false",
      "true",
  });

  return std::any_of(numeric.begin(), numeric.end(), [&](const auto& a) {
    return a.length() == string.length() &&
           EqualChars(a.data(), string.begin().get(), a.length());
  });
}

static bool IsSupportedCollationNumeric(const JSLinearString* string) {
  MOZ_ASSERT(StringIsAscii(string));

  JS::AutoCheckCannotGC nogc;
  if (string->hasLatin1Chars()) {
    return IsSupportedCollationNumeric(string->latin1Range(nogc));
  }
  return IsSupportedCollationNumeric(string->twoByteRange(nogc));
}





template <typename CharT>
static bool IsSupportedHourCycle(mozilla::Range<const CharT> string) {
  
  
  
  
  static constexpr auto hourCycles = std::to_array<std::string_view>({
      "h11",
      "h12",
      "h23",
      "h24",
  });

  return std::any_of(hourCycles.begin(), hourCycles.end(), [&](const auto& a) {
    return a.length() == string.length() &&
           EqualChars(a.data(), string.begin().get(), a.length());
  });
}

static bool IsSupportedHourCycle(const JSLinearString* string) {
  
  if (!string) {
    return true;
  }
  MOZ_ASSERT(StringIsAscii(string));

  JS::AutoCheckCannotGC nogc;
  if (string->hasLatin1Chars()) {
    return IsSupportedHourCycle(string->latin1Range(nogc));
  }
  return IsSupportedHourCycle(string->twoByteRange(nogc));
}





template <typename CharT>
static bool IsSupportedNumberingSystem(std::basic_string_view<CharT> string) {
  
  
  
  
  
  

  
  static constexpr auto numberingSystems = std::to_array<std::string_view>(
      {NUMBERING_SYSTEMS_WITH_SIMPLE_DIGIT_MAPPINGS});

  return std::binary_search(numberingSystems.begin(), numberingSystems.end(),
                            string, [](const auto& a, const auto& b) {
                              return CompareChars(a.data(), a.length(),
                                                  b.data(), b.length()) < 0;
                            });
}

static bool IsSupportedNumberingSystem(const JSLinearString* string) {
  MOZ_ASSERT(StringIsAscii(string));

  JS::AutoCheckCannotGC nogc;
  if (string->hasLatin1Chars()) {
    auto* chars = string->latin1Chars(nogc);
    std::string_view sv{reinterpret_cast<const char*>(chars), string->length()};
    return IsSupportedNumberingSystem(sv);
  }
  auto* chars = string->twoByteChars(nogc);
  std::u16string_view sv{chars, string->length()};
  return IsSupportedNumberingSystem(sv);
}




static JSLinearString* DefaultCalendar(JSContext* cx,
                                       Handle<JSLinearString*> loc) {
  auto locale = intl::EncodeLocale(cx, loc);
  if (!locale) {
    return nullptr;
  }

  auto calendar = mozilla::intl::Calendar::TryCreate(locale.get());
  if (calendar.isErr()) {
    intl::ReportInternalError(cx, calendar.unwrapErr());
    return nullptr;
  }

  auto type = calendar.unwrap()->GetBcp47Type();
  if (type.isErr()) {
    intl::ReportInternalError(cx, type.unwrapErr());
    return nullptr;
  }

  return NewStringCopy<CanGC>(cx, type.unwrap());
}




static JSLinearString* DefaultCollationCaseFirst(
    JSContext* cx, Handle<JSLinearString*> locale) {
  
  
  
  Rooted<JSLinearString*> actualLocale(cx);
  if (!BestAvailableLocale(cx, AvailableLocaleKind::Collator, locale, nullptr,
                           &actualLocale)) {
    return nullptr;
  }

  auto& sharedIntlData = cx->runtime()->sharedIntlData.ref();

  bool isUpperFirst;
  if (!sharedIntlData.isUpperCaseFirst(cx, actualLocale, &isUpperFirst)) {
    return nullptr;
  }

  if (isUpperFirst) {
    return cx->names().upper;
  }
  return cx->names().false_;
}




static JSLinearString* DefaultNumberingSystem(JSContext* cx,
                                              Handle<JSLinearString*> loc) {
  auto locale = intl::EncodeLocale(cx, loc);
  if (!locale) {
    return nullptr;
  }

  auto numberingSystem =
      mozilla::intl::NumberingSystem::TryCreate(locale.get());
  if (numberingSystem.isErr()) {
    intl::ReportInternalError(cx, numberingSystem.unwrapErr());
    return nullptr;
  }

  auto name = numberingSystem.inspect()->GetName();
  if (name.isErr()) {
    intl::ReportInternalError(cx, name.unwrapErr());
    return nullptr;
  }

  return NewStringCopy<CanGC>(cx, name.unwrap());
}




static bool IsSupported(JSContext* cx, LocaleData localeData,
                        Handle<JSLinearString*> locale, UnicodeExtensionKey key,
                        Handle<JSLinearString*> value, bool* result) {
  switch (key) {
    case UnicodeExtensionKey::Calendar: {
      return IsSupportedCalendar(cx, locale, value, result);
    }
    case UnicodeExtensionKey::Collation: {
      
      if (localeData == LocaleData::CollatorSearch) {
        *result = false;
        return true;
      }
      return IsSupportedCollation(cx, locale, value, result);
    }
    case UnicodeExtensionKey::CollationCaseFirst: {
      *result = IsSupportedCollationCaseFirst(value);
      return true;
    }
    case UnicodeExtensionKey::CollationNumeric: {
      *result = IsSupportedCollationNumeric(value);
      return true;
    }
    case UnicodeExtensionKey::HourCycle: {
      *result = IsSupportedHourCycle(value);
      return true;
    }
    case UnicodeExtensionKey::NumberingSystem: {
      *result = IsSupportedNumberingSystem(value);
      return true;
    }
  }
  MOZ_CRASH("invalid Unicode extension key");
}




static bool DefaultValue(JSContext* cx, LocaleData localeData,
                         Handle<JSLinearString*> locale,
                         UnicodeExtensionKey key,
                         MutableHandle<JSLinearString*> result) {
  switch (key) {
    case UnicodeExtensionKey::Calendar: {
      auto ca = DefaultCalendar(cx, locale);
      if (!ca) {
        return false;
      }
      result.set(ca);
      return true;
    }
    case UnicodeExtensionKey::Collation: {
      
      
      result.set(nullptr);
      return true;
    }
    case UnicodeExtensionKey::CollationCaseFirst: {
      
      if (localeData == LocaleData::CollatorSearch) {
        result.set(cx->names().false_);
        return true;
      }

      auto kf = DefaultCollationCaseFirst(cx, locale);
      if (!kf) {
        return false;
      }
      result.set(kf);
      return true;
    }
    case UnicodeExtensionKey::CollationNumeric: {
      
      result.set(cx->names().false_);
      return true;
    }
    case UnicodeExtensionKey::HourCycle: {
      
      result.set(nullptr);
      return true;
    }
    case UnicodeExtensionKey::NumberingSystem: {
      auto nu = DefaultNumberingSystem(cx, locale);
      if (!nu) {
        return false;
      }
      result.set(nu);
      return true;
    }
  }
  MOZ_CRASH("invalid Unicode extension key");
}





bool js::intl::ResolveLocale(
    JSContext* cx, AvailableLocaleKind availableLocales,
    Handle<ArrayObject*> requestedLocales, Handle<LocaleOptions> options,
    mozilla::EnumSet<UnicodeExtensionKey> relevantExtensionKeys,
    LocaleData localeData, JS::MutableHandle<ResolvedLocale> result) {
  
  
  
  Rooted<intl::LookupMatcherResult> match(cx);
  if (!intl::LookupMatcher(cx, availableLocales, requestedLocales, &match)) {
    return false;
  }

  
  auto foundLocale = match.locale();

  

  
  result.set(ResolvedLocale{});

  

  
  UnicodeExtensionKeywords keywords{};
  if (match.extension()) {
    keywords = UnicodeExtensionComponents(match.extension());
  }

  
  mozilla::EnumSet<UnicodeExtensionKey> supportedKeywords = {};

  
  Rooted<mozilla::Maybe<JSLinearString*>> extensionValue(cx);
  Rooted<JSLinearString*> keywordsValue(cx);
  Rooted<JSLinearString*> optionsValue(cx);
  Rooted<JSLinearString*> defaultValue(cx);
  for (auto key : relevantExtensionKeys) {
    
    extensionValue = mozilla::Nothing();

    

    
    bool isSupportedKeyword = false;

    
    if (keywords.has(key)) {
      
      auto [start, length] = keywords.get(key);

      
      if (length > 0) {
        MOZ_ASSERT(start + length <= match.extension()->length());

        keywordsValue =
            NewDependentString(cx, match.extension(), start, length);
        if (!keywordsValue) {
          return false;
        }
      } else {
        keywordsValue = cx->names().true_;
      }

      
    }

    
    
    
    if (options.hasUnicodeExtension(key)) {
      

      
      optionsValue = options.getUnicodeExtension(key);

      

      
      
      

      
      
      
      MOZ_ASSERT_IF(optionsValue, !optionsValue->empty());

      bool supported;
      if (!IsSupported(cx, localeData, foundLocale, key, optionsValue,
                       &supported)) {
        return false;
      }

      if (supported) {
        extensionValue = mozilla::Some(optionsValue.get());

        if (optionsValue && keywords.has(key)) {
          MOZ_ASSERT(keywordsValue && !keywordsValue->empty());
          isSupportedKeyword = EqualStrings(keywordsValue, optionsValue);
        }
      }
    }

    
    
    
    if (extensionValue.isNothing() && keywords.has(key)) {
      MOZ_ASSERT(keywordsValue && !keywordsValue->empty());

      bool supported;
      if (!IsSupported(cx, localeData, foundLocale, key, keywordsValue,
                       &supported)) {
        return false;
      }

      if (supported) {
        extensionValue = mozilla::Some(keywordsValue.get());
        isSupportedKeyword = true;
      }
    }

    
    if (extensionValue.isNothing()) {
      
      if (!DefaultValue(cx, localeData, foundLocale, key, &defaultValue)) {
        return false;
      }
      extensionValue = mozilla::Some(defaultValue.get());

      
    }

    
    if (isSupportedKeyword) {
      supportedKeywords += key;
    }

    
    result.setUnicodeExtension(key, *extensionValue);
  }

  
  result.setUnicodeKeywords(supportedKeywords);

  
  result.setDataLocale(foundLocale);

  
  return true;
}





bool js::intl::ResolveLocale(
    JSContext* cx, AvailableLocaleKind availableLocales,
    Handle<ArrayObject*> requestedLocales, Handle<JSObject*> options,
    mozilla::EnumSet<UnicodeExtensionKey> relevantExtensionKeys,
    LocaleData localeData, JS::MutableHandle<ResolvedLocale> result) {
  Rooted<LocaleOptions> localeOptions(cx);

  Rooted<JS::Value> value(cx);
  Rooted<JS::PropertyKey> optionName(cx);
  for (auto key : relevantExtensionKeys) {
    optionName.set(UnicodeExtensionPropertyKey(cx, key));
    if (!GetProperty(cx, options, options, optionName, &value)) {
      return false;
    }
    MOZ_ASSERT(value.isString() || value.isNullOrUndefined(),
               "unexpected type for options value");

    if (!value.isUndefined()) {
      JSLinearString* optionsValue = nullptr;
      if (value.isString()) {
        optionsValue = value.toString()->ensureLinear(cx);
        if (!optionsValue) {
          return false;
        }
      }
      localeOptions.setUnicodeExtension(key, optionsValue);
    }
  }

  return ResolveLocale(cx, availableLocales, requestedLocales, localeOptions,
                       relevantExtensionKeys, localeData, result);
}

JSObject* js::intl::ResolveLocaleToObject(
    JSContext* cx, Handle<ResolvedLocale> resolved,
    mozilla::EnumSet<UnicodeExtensionKey> relevantExtensionKeys) {
  Rooted<IdValueVector> properties(cx, cx);

  auto* locale = resolved.toLocale(cx);
  if (!locale) {
    return nullptr;
  }
  if (!properties.emplaceBack(NameToId(cx->names().locale),
                              StringValue(locale))) {
    return nullptr;
  }

  if (!properties.emplaceBack(NameToId(cx->names().dataLocale),
                              StringValue(resolved.dataLocale()))) {
    return nullptr;
  }

  for (auto key : relevantExtensionKeys) {
    auto value = NullValue();
    if (auto ext = resolved.extension(key)) {
      value = StringValue(ext);
    }
    if (!properties.emplaceBack(UnicodeExtensionPropertyKey(cx, key), value)) {
      return nullptr;
    }
  }

  return NewPlainObjectWithUniqueNames(cx, properties);
}

ArrayObject* js::intl::LocalesListToArray(JSContext* cx,
                                          Handle<LocalesList> locales) {
  auto* array = NewDenseFullyAllocatedArray(cx, locales.length());
  if (!array) {
    return nullptr;
  }
  array->setDenseInitializedLength(locales.length());

  for (size_t i = 0; i < locales.length(); i++) {
    array->initDenseElement(i, StringValue(locales[i]));
  }
  return array;
}

ArrayObject* js::intl::SupportedLocalesOf(JSContext* cx,
                                          AvailableLocaleKind availableLocales,
                                          Handle<Value> locales,
                                          Handle<Value> options) {
  Rooted<LocalesList> requestedLocales(cx, cx);
  if (!CanonicalizeLocaleList(cx, locales, &requestedLocales)) {
    return nullptr;
  }

  Rooted<LocalesList> supportedLocales(cx, cx);
  if (!SupportedLocales(cx, availableLocales, requestedLocales, options,
                        &supportedLocales)) {
    return nullptr;
  }

  return LocalesListToArray(cx, supportedLocales);
}

JSLinearString* js::intl::ComputeDefaultLocale(JSContext* cx) {
  const char* locale = cx->realm()->getLocale();
  if (!locale) {
    ReportOutOfMemory(cx);
    return nullptr;
  }

  auto span = mozilla::MakeStringSpan(locale);

  mozilla::intl::Locale tag;
  bool canParseLocale =
      mozilla::intl::LocaleParser::TryParse(span, tag).isOk() &&
      tag.Canonicalize().isOk();

  Rooted<JSLinearString*> candidate(cx);
  if (!canParseLocale) {
    candidate = NewStringCopyZ<CanGC>(cx, intl::LastDitchLocale());
    if (!candidate) {
      return nullptr;
    }
  } else {
    
    
    
    tag.ClearUnicodeExtension();

    intl::FormatBuffer<char, intl::INITIAL_CHAR_BUFFER_SIZE> buffer(cx);
    if (auto result = tag.ToString(buffer); result.isErr()) {
      intl::ReportInternalError(cx, result.unwrapErr());
      return nullptr;
    }

    candidate = buffer.toAsciiString(cx);
    if (!candidate) {
      return nullptr;
    }

    
    
    
    for (const auto& mapping : js::intl::oldStyleLanguageTagMappings) {
      const char* oldStyle = mapping.oldStyle;
      const char* modernStyle = mapping.modernStyle;

      if (StringEqualsAscii(candidate, oldStyle)) {
        candidate = NewStringCopyZ<CanGC>(cx, modernStyle);
        if (!candidate) {
          return nullptr;
        }
        break;
      }
    }
  }

  
  
  
  
  
  
  

  Rooted<JSLinearString*> supportedCollator(cx);
  JS_TRY_VAR_OR_RETURN_NULL(
      cx, supportedCollator,
      BestAvailableLocale(cx, AvailableLocaleKind::Collator, candidate,
                          nullptr));

  Rooted<JSLinearString*> supportedDateTimeFormat(cx);
  JS_TRY_VAR_OR_RETURN_NULL(
      cx, supportedDateTimeFormat,
      BestAvailableLocale(cx, AvailableLocaleKind::DateTimeFormat, candidate,
                          nullptr));

#ifdef DEBUG
  
  
  
  for (auto kind : {
           AvailableLocaleKind::DisplayNames,
           AvailableLocaleKind::DurationFormat,
           AvailableLocaleKind::ListFormat,
           AvailableLocaleKind::NumberFormat,
           AvailableLocaleKind::PluralRules,
           AvailableLocaleKind::RelativeTimeFormat,
           AvailableLocaleKind::Segmenter,
       }) {
    JSLinearString* supported;
    JS_TRY_VAR_OR_RETURN_NULL(
        cx, supported, BestAvailableLocale(cx, kind, candidate, nullptr));

    MOZ_ASSERT(!!supported == !!supportedDateTimeFormat);
    MOZ_ASSERT_IF(supported, EqualStrings(supported, supportedDateTimeFormat));
  }
#endif

  
  
  if (supportedCollator && supportedDateTimeFormat) {
    
    
    
    
    
    
    
    if (SameOrParentLocale(supportedCollator, supportedDateTimeFormat)) {
      return supportedDateTimeFormat;
    }
    return supportedCollator;
  }

  
  return NewStringCopyZ<CanGC>(cx, intl::LastDitchLocale());
}
