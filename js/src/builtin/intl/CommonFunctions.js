










function CanonicalizeLocaleList(locales) {
  
  if (locales === undefined) {
    return [];
  }

  
  var tag = intl_ValidateAndCanonicalizeLanguageTag(locales, false);
  if (tag !== null) {
    assert(
      typeof tag === "string",
      "intl_ValidateAndCanonicalizeLanguageTag returns a string value"
    );
    return [tag];
  }

  
  var seen = [];

  
  var O = ToObject(locales);

  
  var len = ToLength(O.length);

  
  var k = 0;

  
  while (k < len) {
    
    if (k in O) {
      
      var kValue = O[k];

      
      if (!(typeof kValue === "string" || IsObject(kValue))) {
        ThrowTypeError(JSMSG_INVALID_LOCALES_ELEMENT);
      }

      
      var tag = intl_ValidateAndCanonicalizeLanguageTag(kValue, true);
      assert(
        typeof tag === "string",
        "ValidateAndCanonicalizeLanguageTag returns a string value"
      );

      
      if (callFunction(std_Array_indexOf, seen, tag) === -1) {
        DefineDataProperty(seen, seen.length, tag);
      }
    }

    
    k++;
  }

  
  return seen;
}





function BestAvailableLocaleIgnoringDefault(availableLocales, locale) {
  return intl_BestAvailableLocale(availableLocales, locale, null);
}








function GetOption(options, property, type, values, fallback) {
  
  var value = options[property];

  
  if (value !== undefined) {
    
    if (type === "boolean") {
      value = TO_BOOLEAN(value);
    } else if (type === "string") {
      value = ToString(value);
    } else {
      assert(false, "GetOption");
    }

    
    if (
      values !== undefined &&
      callFunction(std_Array_indexOf, values, value) === -1
    ) {
      ThrowRangeError(JSMSG_INVALID_OPTION_VALUE, property, `"${value}"`);
    }

    
    return value;
  }

  
  return fallback;
}






function GetStringOrBooleanOption(
  options,
  property,
  stringValues,
  fallback
) {
  assert(IsObject(stringValues), "GetStringOrBooleanOption");

  
  var value = options[property];

  
  if (value === undefined) {
    return fallback;
  }

  
  if (value === true) {
    return true;
  }

  
  if (!value) {
    return false;
  }

  
  value = ToString(value);

  
  if (callFunction(std_Array_indexOf, stringValues, value) === -1) {
    ThrowRangeError(JSMSG_INVALID_OPTION_VALUE, property, `"${value}"`);
  }

  
  return value;
}








function DefaultNumberOption(value, minimum, maximum, fallback) {
  assert(
    typeof minimum === "number" && (minimum | 0) === minimum,
    "DefaultNumberOption"
  );
  assert(
    typeof maximum === "number" && (maximum | 0) === maximum,
    "DefaultNumberOption"
  );
  assert(
    fallback === undefined ||
      (typeof fallback === "number" && (fallback | 0) === fallback),
    "DefaultNumberOption"
  );
  assert(
    fallback === undefined || (minimum <= fallback && fallback <= maximum),
    "DefaultNumberOption"
  );

  
  if (value === undefined) {
    return fallback;
  }

  
  value = TO_NUMBER(value);

  
  if (Number_isNaN(value) || value < minimum || value > maximum) {
    ThrowRangeError(JSMSG_INVALID_DIGITS_VALUE, value);
  }

  
  
  
  return std_Math_floor(value) | 0;
}








function GetNumberOption(options, property, minimum, maximum, fallback) {
  
  return DefaultNumberOption(options[property], minimum, maximum, fallback);
}




function initializeIntlObject(obj, type, lazyData) {
  assert(IsObject(obj), "Non-object passed to initializeIntlObject");
  assert(
    (type === "PluralRules" && intl_GuardToPluralRules(obj) !== null),
    "type must match the object's class"
  );
  assert(IsObject(lazyData), "non-object lazy data");

  
  
  
  
  
  
  
  
  
  
  
  
  

  var internals = std_Object_create(null);
  internals.type = type;
  internals.lazyData = lazyData;
  internals.internalProps = null;

  assert(
    UnsafeGetReservedSlot(obj, INTL_INTERNALS_OBJECT_SLOT) === undefined,
    "Internal slot already initialized?"
  );
  UnsafeSetReservedSlot(obj, INTL_INTERNALS_OBJECT_SLOT, internals);
}





function setInternalProperties(internals, internalProps) {
  assert(IsObject(internals.lazyData), "lazy data must exist already");
  assert(IsObject(internalProps), "internalProps argument should be an object");

  
  internals.internalProps = internalProps;
  internals.lazyData = null;
}





function maybeInternalProperties(internals) {
  assert(IsObject(internals), "non-object passed to maybeInternalProperties");
  var lazyData = internals.lazyData;
  if (lazyData) {
    return null;
  }
  assert(
    IsObject(internals.internalProps),
    "missing lazy data and computed internals"
  );
  return internals.internalProps;
}









function getIntlObjectInternals(obj) {
  assert(IsObject(obj), "getIntlObjectInternals called with non-Object");
  assert(
    intl_GuardToPluralRules(obj) !== null,
    "getIntlObjectInternals called with non-Intl object"
  );

  var internals = UnsafeGetReservedSlot(obj, INTL_INTERNALS_OBJECT_SLOT);

  assert(IsObject(internals), "internals not an object");
  assert(hasOwn("type", internals), "missing type");
  assert(
    (internals.type === "PluralRules" && intl_GuardToPluralRules(obj) !== null),
    "type must match the object's class"
  );
  assert(hasOwn("lazyData", internals), "missing lazyData");
  assert(hasOwn("internalProps", internals), "missing internalProps");

  return internals;
}





function getInternals(obj) {
  var internals = getIntlObjectInternals(obj);

  
  var internalProps = maybeInternalProperties(internals);
  if (internalProps) {
    return internalProps;
  }

  
  var type = internals.type;
  if (type === "PluralRules") {
    internalProps = resolvePluralRulesInternals(internals.lazyData);
  } else {
    assert(false, "unexpected Intl constructor");
  }
  setInternalProperties(internals, internalProps);
  return internalProps;
}
