





#ifndef builtin_intl_IntlMathematicalValue_h
#define builtin_intl_IntlMathematicalValue_h

#include <stddef.h>
#include <string_view>

#include "js/GCAPI.h"
#include "js/RootingAPI.h"
#include "js/TypeDecls.h"
#include "js/Utility.h"
#include "js/Value.h"

class JSLinearString;

namespace js::intl {

class IntlMathematicalValueString;
class IntlMathematicalValueStringView;





class IntlMathematicalValue final {
  JS::Value value_{};

  JSLinearString* toLinearString(JSContext* cx) const;

 public:
  IntlMathematicalValue() = default;

  explicit IntlMathematicalValue(JS::Value value) : value_(value) {
    MOZ_ASSERT(value.isNumeric() || value.isString());
  }

  explicit IntlMathematicalValue(JS::BigInt* bigInt)
      : value_(JS::BigIntValue(bigInt)) {}

  bool isNumber() const { return value_.isNumber(); }
  bool isBigInt() const { return value_.isBigInt(); }
  bool isNaN() const { return value_.isNaN(); }

  double toNumber() const { return value_.toNumber(); }
  JS::BigInt* toBigInt() const { return value_.toBigInt(); }

  bool isRepresentableAsDouble(double* result) const;

  [[nodiscard]] IntlMathematicalValueString toString(JSContext* cx) const;

  void trace(JSTracer* trc);
};




class IntlMathematicalValueString final {
  JSLinearString* string_ = nullptr;

  explicit IntlMathematicalValueString(JSLinearString* string)
      : string_(string) {}

  friend class IntlMathematicalValue;

 public:
  IntlMathematicalValueString() = default;

  explicit operator bool() const { return !!string_; }

  [[nodiscard]] IntlMathematicalValueStringView asView(
      JSContext* cx, const JS::AutoCheckCannotGC& nogc) const;

  void trace(JSTracer* trc);
};




class IntlMathematicalValueStringView final {
  std::string_view view_{};

  
  JS::UniqueChars latin1_{};

 public:
  IntlMathematicalValueStringView() = default;

  explicit IntlMathematicalValueStringView(std::string_view view,
                                           JS::UniqueChars latin1 = nullptr)
      : view_(view), latin1_(std::move(latin1)) {}

  explicit operator bool() const { return !view_.empty(); }

  operator std::string_view() const { return view_; }
};

inline IntlMathematicalValueString IntlMathematicalValue::toString(
    JSContext* cx) const {
  return IntlMathematicalValueString{toLinearString(cx)};
}






bool ToIntlMathematicalValue(JSContext* cx, JS::Handle<JS::Value> value,
                             JS::MutableHandle<IntlMathematicalValue> result);
}  

namespace js {

template <typename Wrapper>
class WrappedPtrOperations<intl::IntlMathematicalValue, Wrapper> {
  const intl::IntlMathematicalValue& container() const {
    return static_cast<const Wrapper*>(this)->get();
  }

 public:
  bool isNumber() const { return container().isNumber(); }
  bool isBigInt() const { return container().isBigInt(); }
  bool isNaN() const { return container().isNaN(); }

  double toNumber() const { return container().toNumber(); }
  JS::BigInt* toBigInt() const { return container().toBigInt(); }

  bool isRepresentableAsDouble(double* result) const {
    return container().isRepresentableAsDouble(result);
  }

  [[nodiscard]] auto toString(JSContext* cx) const {
    return container().toString(cx);
  }
};

template <typename Wrapper>
class WrappedPtrOperations<intl::IntlMathematicalValueString, Wrapper> {
  const intl::IntlMathematicalValueString& container() const {
    return static_cast<const Wrapper*>(this)->get();
  }

 public:
  explicit operator bool() const { return bool(container()); }

  auto asView(JSContext* cx, const JS::AutoCheckCannotGC& nogc) const {
    return container().asView(cx, nogc);
  }
};

}  

#endif 
