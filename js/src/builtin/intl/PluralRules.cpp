







#include "builtin/intl/PluralRules.h"

#include "mozilla/Assertions.h"
#include "mozilla/intl/PluralRules.h"

#include "builtin/Array.h"
#include "builtin/intl/CommonFunctions.h"
#include "builtin/intl/LocaleNegotiation.h"
#include "builtin/intl/NumberFormat.h"
#include "builtin/intl/ParameterNegotiation.h"
#include "builtin/intl/UsingEnum.h"
#include "gc/GCContext.h"
#include "js/PropertySpec.h"
#include "vm/GlobalObject.h"
#include "vm/JSContext.h"
#include "vm/PlainObject.h"
#include "vm/StringType.h"

#include "vm/JSObject-inl.h"
#include "vm/NativeObject-inl.h"

using namespace js;
using namespace js::intl;

const JSClassOps PluralRulesObject::classOps_ = {
    nullptr,                      
    nullptr,                      
    nullptr,                      
    nullptr,                      
    nullptr,                      
    nullptr,                      
    PluralRulesObject::finalize,  
    nullptr,                      
    nullptr,                      
    nullptr,                      
};

const JSClass PluralRulesObject::class_ = {
    "Intl.PluralRules",
    JSCLASS_HAS_RESERVED_SLOTS(PluralRulesObject::SLOT_COUNT) |
        JSCLASS_HAS_CACHED_PROTO(JSProto_PluralRules) |
        JSCLASS_BACKGROUND_FINALIZE,
    &PluralRulesObject::classOps_,
    &PluralRulesObject::classSpec_,
};

const JSClass& PluralRulesObject::protoClass_ = PlainObject::class_;

static bool pluralRules_supportedLocalesOf(JSContext* cx, unsigned argc,
                                           Value* vp);

static bool pluralRules_select(JSContext* cx, unsigned argc, Value* vp);

static bool pluralRules_selectRange(JSContext* cx, unsigned argc, Value* vp);

static bool pluralRules_resolvedOptions(JSContext* cx, unsigned argc,
                                        Value* vp);

static bool pluralRules_toSource(JSContext* cx, unsigned argc, Value* vp) {
  CallArgs args = CallArgsFromVp(argc, vp);
  args.rval().setString(cx->names().PluralRules);
  return true;
}

static const JSFunctionSpec pluralRules_static_methods[] = {
    JS_FN("supportedLocalesOf", pluralRules_supportedLocalesOf, 1, 0),
    JS_FS_END,
};

static const JSFunctionSpec pluralRules_methods[] = {
    JS_FN("resolvedOptions", pluralRules_resolvedOptions, 0, 0),
    JS_FN("select", pluralRules_select, 1, 0),
    JS_FN("selectRange", pluralRules_selectRange, 2, 0),
    JS_FN("toSource", pluralRules_toSource, 0, 0),
    JS_FS_END,
};

static const JSPropertySpec pluralRules_properties[] = {
    JS_STRING_SYM_PS(toStringTag, "Intl.PluralRules", JSPROP_READONLY),
    JS_PS_END,
};

static bool PluralRules(JSContext* cx, unsigned argc, Value* vp);

const ClassSpec PluralRulesObject::classSpec_ = {
    GenericCreateConstructor<PluralRules, 0, gc::AllocKind::FUNCTION>,
    GenericCreatePrototype<PluralRulesObject>,
    pluralRules_static_methods,
    nullptr,
    pluralRules_methods,
    pluralRules_properties,
    nullptr,
    ClassSpec::DontDefineConstructor,
};

static constexpr std::string_view PluralRulesTypeToString(
    PluralRulesOptions::Type type) {
#ifndef USING_ENUM
  using enum PluralRulesOptions::Type;
#else
  USING_ENUM(PluralRulesOptions::Type, Cardinal, Ordinal);
#endif
  switch (type) {
    case Cardinal:
      return "cardinal";
    case Ordinal:
      return "ordinal";
  }
  MOZ_CRASH("invalid plural rules type");
}

static constexpr std::string_view PluralRulesNotationToString(
    PluralRulesOptions::Notation notation) {
#ifndef USING_ENUM
  using enum PluralRulesOptions::Notation;
#else
  USING_ENUM(PluralRulesOptions::Notation, Standard, Scientific, Engineering,
             Compact);
#endif
  switch (notation) {
    case Standard:
      return "standard";
    case Scientific:
      return "scientific";
    case Engineering:
      return "engineering";
    case Compact:
      return "compact";
  }
  MOZ_CRASH("invalid plural rules notation");
}

static constexpr std::string_view PluralRulesCompactDisplayToString(
    PluralRulesOptions::CompactDisplay compactDisplay) {
#ifndef USING_ENUM
  using enum PluralRulesOptions::CompactDisplay;
#else
  USING_ENUM(PluralRulesOptions::CompactDisplay, Short, Long);
#endif
  switch (compactDisplay) {
    case Short:
      return "short";
    case Long:
      return "long";
  }
  MOZ_CRASH("invalid plural rules compact display");
}






static bool PluralRules(JSContext* cx, unsigned argc, Value* vp) {
  CallArgs args = CallArgsFromVp(argc, vp);

  
  if (!ThrowIfNotConstructing(cx, args, "Intl.PluralRules")) {
    return false;
  }

  
  Rooted<JSObject*> proto(cx);
  if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_PluralRules,
                                          &proto)) {
    return false;
  }

  Rooted<PluralRulesObject*> pluralRules(cx);
  pluralRules = NewObjectWithClassProto<PluralRulesObject>(cx, proto);
  if (!pluralRules) {
    return false;
  }

  
  Rooted<LocalesList> requestedLocales(cx, cx);
  if (!CanonicalizeLocaleList(cx, args.get(0), &requestedLocales)) {
    return false;
  }

  Rooted<ArrayObject*> requestedLocalesArray(
      cx, LocalesListToArray(cx, requestedLocales));
  if (!requestedLocalesArray) {
    return false;
  }
  pluralRules->setRequestedLocales(requestedLocalesArray);

  auto plOptions = cx->make_unique<PluralRulesOptions>();
  if (!plOptions) {
    return false;
  }

  if (args.hasDefined(1)) {
    
    Rooted<JSObject*> options(cx, JS::ToObject(cx, args[1]));
    if (!options) {
      return false;
    }

    
    LocaleMatcher matcher;
    if (!GetLocaleMatcherOption(cx, options, &matcher)) {
      return false;
    }

    
    
    
    

    
    
    

    

    

    

    

    

    
    static constexpr auto types = MapOptions<PluralRulesTypeToString>(
        PluralRulesOptions::Type::Cardinal, PluralRulesOptions::Type::Ordinal);
    if (!GetStringOption(cx, options, cx->names().type, types,
                         PluralRulesOptions::Type::Cardinal,
                         &plOptions->type)) {
      return false;
    }

    
    static constexpr auto notations = MapOptions<PluralRulesNotationToString>(
        PluralRulesOptions::Notation::Standard,
        PluralRulesOptions::Notation::Scientific,
        PluralRulesOptions::Notation::Engineering,
        PluralRulesOptions::Notation::Compact);
    if (!GetStringOption(cx, options, cx->names().notation, notations,
                         NumberFormatOptions::Notation::Standard,
                         &plOptions->notation)) {
      return false;
    }

    
    static constexpr auto compactDisplays =
        MapOptions<PluralRulesCompactDisplayToString>(
            PluralRulesOptions::CompactDisplay::Short,
            PluralRulesOptions::CompactDisplay::Long);
    if (!GetStringOption(cx, options, cx->names().compactDisplay,
                         compactDisplays,
                         PluralRulesOptions::CompactDisplay::Short,
                         &plOptions->compactDisplay)) {
      return false;
    }

    
    if (!SetNumberFormatDigitOptions(cx, plOptions->digitOptions, options, 0, 3,
                                     plOptions->notation)) {
      return false;
    }
  } else {
    static constexpr PluralRulesOptions defaultOptions = {
        .digitOptions =
            {
                .roundingIncrement = 1,
                .minimumIntegerDigits = 1,
                .minimumFractionDigits = 0,
                .maximumFractionDigits = 3,
                .minimumSignificantDigits = 0,
                .maximumSignificantDigits = 0,
                .roundingMode =
                    NumberFormatDigitOptions::RoundingMode::HalfExpand,
                .roundingPriority =
                    NumberFormatDigitOptions::RoundingPriority::Auto,
                .trailingZeroDisplay =
                    NumberFormatDigitOptions::TrailingZeroDisplay::Auto,
            },
        .notation = NumberFormatOptions::Notation::Standard,
    };

    
    *plOptions = defaultOptions;
  }
  pluralRules->setOptions(plOptions.release());
  AddCellMemory(pluralRules, sizeof(PluralRulesOptions),
                MemoryUse::IntlOptions);

  
  args.rval().setObject(*pluralRules);
  return true;
}

void js::intl::PluralRulesObject::finalize(JS::GCContext* gcx, JSObject* obj) {
  auto* pluralRules = &obj->as<PluralRulesObject>();

  if (auto* options = pluralRules->getOptions()) {
    gcx->delete_(obj, options, MemoryUse::IntlOptions);
  }

  if (auto* pr = pluralRules->getPluralRules()) {
    RemoveICUCellMemory(gcx, obj,
                        PluralRulesObject::UPluralRulesEstimatedMemoryUse);
    delete pr;
  }
}




static bool ResolveLocale(JSContext* cx,
                          Handle<PluralRulesObject*> pluralRules) {
  
  if (pluralRules->isLocaleResolved()) {
    return true;
  }

  Rooted<ArrayObject*> requestedLocales(
      cx, &pluralRules->getRequestedLocales()->as<ArrayObject>());

  
  mozilla::EnumSet<UnicodeExtensionKey> relevantExtensionKeys{};

  
  Rooted<LocaleOptions> localeOptions(cx);

  
  auto localeData = LocaleData::Default;

  
  Rooted<ResolvedLocale> resolved(cx);
  if (!ResolveLocale(cx, AvailableLocaleKind::PluralRules, requestedLocales,
                     localeOptions, relevantExtensionKeys, localeData,
                     &resolved)) {
    return false;
  }

  
  pluralRules->setLocale(resolved.dataLocale());

  MOZ_ASSERT(pluralRules->isLocaleResolved(), "locale successfully resolved");
  return true;
}

static JSString* KeywordToString(mozilla::intl::PluralRules::Keyword keyword,
                                 JSContext* cx) {
#ifndef USING_ENUM
  using enum mozilla::intl::PluralRules::Keyword;
#else
  USING_ENUM(mozilla::intl::PluralRules::Keyword, Zero, One, Two, Few, Many,
             Other);
#endif
  switch (keyword) {
    case Zero:
      return cx->names().zero;
    case One:
      return cx->names().one;
    case Two:
      return cx->names().two;
    case Few:
      return cx->names().few;
    case Many:
      return cx->names().many;
    case Other:
      return cx->names().other;
  }
  MOZ_CRASH("Unexpected PluralRules keyword");
}

static auto ToPluralRulesType(PluralRulesOptions::Type type) {
#ifndef USING_ENUM
  using enum mozilla::intl::PluralRules::Type;
#else
  USING_ENUM(mozilla::intl::PluralRules::Type, Cardinal, Ordinal);
#endif
  switch (type) {
    case PluralRulesOptions::Type::Cardinal:
      return Cardinal;
    case PluralRulesOptions::Type::Ordinal:
      return Ordinal;
  }
  MOZ_CRASH("invalid plural rules type");
}





static mozilla::intl::PluralRules* NewPluralRules(
    JSContext* cx, Handle<PluralRulesObject*> pluralRules) {
  if (!ResolveLocale(cx, pluralRules)) {
    return nullptr;
  }
  auto plOptions = *pluralRules->getOptions();

  auto locale = EncodeLocale(cx, pluralRules->getLocale());
  if (!locale) {
    return nullptr;
  }

  mozilla::intl::PluralRulesOptions options = {
      .mPluralType = ToPluralRulesType(plOptions.type),
  };
  SetPluralRulesOptions(plOptions, options);

  auto result = mozilla::intl::PluralRules::TryCreate(locale.get(), options);
  if (result.isErr()) {
    ReportInternalError(cx, result.unwrapErr());
    return nullptr;
  }
  return result.unwrap().release();
}

static mozilla::intl::PluralRules* GetOrCreatePluralRules(
    JSContext* cx, Handle<PluralRulesObject*> pluralRules) {
  
  if (auto* pr = pluralRules->getPluralRules()) {
    return pr;
  }

  auto* pr = NewPluralRules(cx, pluralRules);
  if (!pr) {
    return nullptr;
  }
  pluralRules->setPluralRules(pr);

  AddICUCellMemory(pluralRules,
                   PluralRulesObject::UPluralRulesEstimatedMemoryUse);
  return pr;
}











static JSString* ResolvePlural(JSContext* cx,
                               Handle<PluralRulesObject*> pluralRules,
                               double x) {
  
  auto* pr = GetOrCreatePluralRules(cx, pluralRules);
  if (!pr) {
    return nullptr;
  }

  auto keywordResult = pr->Select(x);
  if (keywordResult.isErr()) {
    ReportInternalError(cx, keywordResult.unwrapErr());
    return nullptr;
  }

  return KeywordToString(keywordResult.unwrap(), cx);
}











static JSString* ResolvePluralRange(JSContext* cx,
                                    Handle<PluralRulesObject*> pluralRules,
                                    double x, double y) {
  
  if (std::isnan(x)) {
    JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                              JSMSG_NAN_NUMBER_RANGE, "start", "PluralRules",
                              "selectRange");
    return nullptr;
  }

  
  if (std::isnan(y)) {
    JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                              JSMSG_NAN_NUMBER_RANGE, "end", "PluralRules",
                              "selectRange");
    return nullptr;
  }

  
  auto* pr = GetOrCreatePluralRules(cx, pluralRules);
  if (!pr) {
    return nullptr;
  }

  auto keywordResult = pr->SelectRange(x, y);
  if (keywordResult.isErr()) {
    ReportInternalError(cx, keywordResult.unwrapErr());
    return nullptr;
  }

  return KeywordToString(keywordResult.unwrap(), cx);
}











static ArrayObject* GetPluralCategories(
    JSContext* cx, Handle<PluralRulesObject*> pluralRules) {
  auto* pr = GetOrCreatePluralRules(cx, pluralRules);
  if (!pr) {
    return nullptr;
  }

  auto categoriesResult = pr->Categories();
  if (categoriesResult.isErr()) {
    ReportInternalError(cx, categoriesResult.unwrapErr());
    return nullptr;
  }
  auto categories = categoriesResult.unwrap();

  auto* res = NewDenseFullyAllocatedArray(cx, categories.size());
  if (!res) {
    return nullptr;
  }
  res->setDenseInitializedLength(categories.size());

  using PluralRules = mozilla::intl::PluralRules;

  size_t index = 0;
  for (auto keyword : {
           PluralRules::Keyword::Zero,
           PluralRules::Keyword::One,
           PluralRules::Keyword::Two,
           PluralRules::Keyword::Few,
           PluralRules::Keyword::Many,
           PluralRules::Keyword::Other,
       }) {
    if (categories.contains(keyword)) {
      auto* str = KeywordToString(keyword, cx);
      MOZ_ASSERT(str);

      res->initDenseElement(index++, StringValue(str));
    }
  }
  MOZ_ASSERT(index == categories.size());

  return res;
}

static bool IsPluralRules(Handle<JS::Value> v) {
  return v.isObject() && v.toObject().is<PluralRulesObject>();
}




static bool pluralRules_select(JSContext* cx, const CallArgs& args) {
  Rooted<PluralRulesObject*> pluralRules(
      cx, &args.thisv().toObject().as<PluralRulesObject>());

  
  double x;
  if (!JS::ToNumber(cx, args.get(0), &x)) {
    return false;
  }

  
  auto* result = ResolvePlural(cx, pluralRules, x);
  if (!result) {
    return false;
  }
  args.rval().setString(result);
  return true;
}




static bool pluralRules_select(JSContext* cx, unsigned argc, Value* vp) {
  
  CallArgs args = CallArgsFromVp(argc, vp);
  return CallNonGenericMethod<IsPluralRules, pluralRules_select>(cx, args);
}




static bool pluralRules_selectRange(JSContext* cx, const CallArgs& args) {
  Rooted<PluralRulesObject*> pluralRules(
      cx, &args.thisv().toObject().as<PluralRulesObject>());

  
  if (!args.hasDefined(0) || !args.hasDefined(1)) {
    JS_ReportErrorNumberASCII(
        cx, GetErrorMessage, nullptr, JSMSG_UNDEFINED_NUMBER,
        !args.hasDefined(0) ? "start" : "end", "PluralRules", "selectRange");
    return false;
  }

  
  double x;
  if (!JS::ToNumber(cx, args[0], &x)) {
    return false;
  }

  
  double y;
  if (!JS::ToNumber(cx, args[1], &y)) {
    return false;
  }

  
  auto* result = ResolvePluralRange(cx, pluralRules, x, y);
  if (!result) {
    return false;
  }
  args.rval().setString(result);
  return true;
}




static bool pluralRules_selectRange(JSContext* cx, unsigned argc, Value* vp) {
  
  CallArgs args = CallArgsFromVp(argc, vp);
  return CallNonGenericMethod<IsPluralRules, pluralRules_selectRange>(cx, args);
}




static bool pluralRules_resolvedOptions(JSContext* cx, const CallArgs& args) {
  Rooted<PluralRulesObject*> pluralRules(
      cx, &args.thisv().toObject().as<PluralRulesObject>());

  if (!ResolveLocale(cx, pluralRules)) {
    return false;
  }
  auto plOptions = *pluralRules->getOptions();

  
  Rooted<ArrayObject*> pluralCategories(cx,
                                        GetPluralCategories(cx, pluralRules));
  if (!pluralCategories) {
    return false;
  }

  
  Rooted<IdValueVector> options(cx, cx);

  
  if (!options.emplaceBack(NameToId(cx->names().locale),
                           StringValue(pluralRules->getLocale()))) {
    return false;
  }

  auto* type =
      NewStringCopy<CanGC>(cx, PluralRulesTypeToString(plOptions.type));
  if (!type) {
    return false;
  }
  if (!options.emplaceBack(NameToId(cx->names().type), StringValue(type))) {
    return false;
  }

  if (!ResolvePluralRulesOptions(cx, plOptions, pluralCategories, &options)) {
    return false;
  }

  
  auto* result = NewPlainObjectWithUniqueNames(cx, options);
  if (!result) {
    return false;
  }
  args.rval().setObject(*result);
  return true;
}




static bool pluralRules_resolvedOptions(JSContext* cx, unsigned argc,
                                        Value* vp) {
  
  CallArgs args = CallArgsFromVp(argc, vp);
  return CallNonGenericMethod<IsPluralRules, pluralRules_resolvedOptions>(cx,
                                                                          args);
}




static bool pluralRules_supportedLocalesOf(JSContext* cx, unsigned argc,
                                           Value* vp) {
  CallArgs args = CallArgsFromVp(argc, vp);

  
  auto* array = SupportedLocalesOf(cx, AvailableLocaleKind::PluralRules,
                                   args.get(0), args.get(1));
  if (!array) {
    return false;
  }
  args.rval().setObject(*array);
  return true;
}
