





#ifndef util_PortableMath_h
#define util_PortableMath_h

#include "mozilla/Casting.h"
#include "mozilla/FloatingPoint.h"

#include <math.h>

#include "js/Value.h"
#include "vm/JSContext.h"

namespace js {

inline double NumberDiv(double a, double b) {
  AutoUnsafeCallWithABI unsafe;
  if (b == 0) {
    if (a == 0 || std::isnan(a)) {
      return JS::GenericNaN();
    }
    if (mozilla::IsNegative(a) != mozilla::IsNegative(b)) {
      return mozilla::NegativeInfinity<double>();
    }
    return mozilla::PositiveInfinity<double>();
  }

  return a / b;
}

inline double NumberMod(double a, double b) {
  AutoUnsafeCallWithABI unsafe;
  if (b == 0) {
    return JS::GenericNaN();
  }
  double r = fmod(a, b);
#if defined(XP_WIN)
  
  
  
  if (mozilla::IsPositiveZero(r) && mozilla::IsNegative(a)) {
    return -0.0;
  }
#endif
  return r;
}

template <typename T>
inline T GetBiggestNumberLessThan(T x) {
  MOZ_ASSERT(!mozilla::IsNegative(x));
  MOZ_ASSERT(std::isfinite(x));
  using Bits = typename mozilla::FloatingPoint<T>::Bits;
  Bits bits = mozilla::BitwiseCast<Bits>(x);
  MOZ_ASSERT(bits > 0, "will underflow");
  return mozilla::BitwiseCast<T>(bits - 1);
}

}  

#endif 
