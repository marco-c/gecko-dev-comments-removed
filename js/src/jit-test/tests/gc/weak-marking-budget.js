


gcparam("concurrentMarkingEnabled", 0);
gczeal(0);
gc();
assertEq(gcstate(), "NotActive");

function checkFinishMarkingDuringSweeping(expected) {
  if (hasFunction["currentgc"]) {
    assertEq(currentgc().finishMarkingDuringSweeping, expected);
  }
}

var keys = [];
var maps = Array(1000).fill().map(() => new WeakMap);
for (const map of maps) {
  for (let i = 0; i < 100; i++) {
    
    
    let key = {};
    keys.push(key);
    map.set(key, {}); 
  }
}

minorgc();
keys = undefined;


startgc(10);
while (["Prepare", "MarkRoots"].includes(gcstate())) {
    gcslice(10);
}
assertEq(gcstate(), "Mark");








while (gcstate() === "Mark") {
    gcslice(10000);
}
assertEq(gcstate(), "Sweep");
checkFinishMarkingDuringSweeping(true);







gcslice(100);
assertEq(gcstate(), "Sweep");
checkFinishMarkingDuringSweeping(false);



finishgc();





startgc(10);
while (["Prepare", "MarkRoots"].includes(gcstate())) {
    gcslice(10);
}
assertEq(gcstate(), "Mark");

while (gcstate() === "Mark") {
    gcslice(100);
}
assertEq(gcstate(), "Sweep");
checkFinishMarkingDuringSweeping(false);

gcslice(1);
assertEq(gcstate(), "Sweep");
checkFinishMarkingDuringSweeping(false);
