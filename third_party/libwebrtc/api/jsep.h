


















#ifndef API_JSEP_H_
#define API_JSEP_H_

#include <stddef.h>

#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <vector>

#include "absl/base/nullability.h"
#include "absl/strings/str_format.h"
#include "absl/strings/string_view.h"
#include "api/candidate.h"
#include "api/ref_count.h"
#include "api/rtc_error.h"
#include "api/sequence_checker.h"
#include "rtc_base/system/no_unique_address.h"
#include "rtc_base/system/rtc_export.h"
#include "rtc_base/thread_annotations.h"

namespace webrtc {

class SessionDescription;

struct SdpParseError {
 public:
  
  std::string line;
  
  std::string description;
};


class RTC_EXPORT IceCandidate final {
 public:
  IceCandidate(absl::string_view sdp_mid,
               int sdp_mline_index,
               const Candidate& candidate);
  ~IceCandidate() = default;

  IceCandidate(const IceCandidate&) = delete;
  IceCandidate& operator=(const IceCandidate&) = delete;

  
  
  
  
  static std::unique_ptr<IceCandidate> Create(
      absl::string_view mid,
      int sdp_mline_index,
      absl::string_view sdp,
      SdpParseError* absl_nullable error = nullptr);

  
  
  
  std::string sdp_mid() const { return sdp_mid_; }

  
  
  int sdp_mline_index() const { return sdp_mline_index_; }

  
  const Candidate& candidate() const { return candidate_; }

  
  
  std::string server_url() const { return candidate_.url(); }

  
  std::string ToString() const;

  
  bool ToString(std::string* out) const {
    if (!out)
      return false;
    *out = ToString();
    return !out->empty();
  }

  template <typename Sink>
  friend void AbslStringify(Sink& sink, const IceCandidate& c) {
    absl::Format(&sink, "IceCandidate: {'%s', %i, '%s'}", c.sdp_mid_.c_str(),
                 c.sdp_mline_index_, c.ToString().c_str());
  }

 private:
  const std::string sdp_mid_;
  const int sdp_mline_index_;
  const Candidate candidate_;
};



using JsepIceCandidate = IceCandidate;
using IceCandidateInterface = IceCandidate;




RTC_EXPORT IceCandidate* CreateIceCandidate(const std::string& sdp_mid,
                                            int sdp_mline_index,
                                            const std::string& sdp,
                                            SdpParseError* error);


RTC_EXPORT std::unique_ptr<IceCandidate> CreateIceCandidate(
    const std::string& sdp_mid,
    int sdp_mline_index,
    const Candidate& candidate);



class IceCandidateCollection final {
 public:
  IceCandidateCollection() = default;
  explicit IceCandidateCollection(
      std::vector<std::unique_ptr<IceCandidate>>&& candidates)
      : candidates_(std::move(candidates)) {}
  ~IceCandidateCollection() = default;

  
  
  IceCandidateCollection(IceCandidateCollection&& o) = default;

  IceCandidateCollection(const IceCandidateCollection&) = delete;
  IceCandidateCollection& operator=(const IceCandidateCollection&) = delete;

  size_t count() const {
    RTC_DCHECK_RUN_ON(&sequence_checker_);
    return candidates_.size();
  }
  bool empty() const {
    RTC_DCHECK_RUN_ON(&sequence_checker_);
    return candidates_.empty();
  }
  const IceCandidate* at(size_t index) const;

  
  void add(std::unique_ptr<IceCandidate> candidate);
  [[deprecated("Use unique_ptr version")]]
  void add(IceCandidate* candidate);

  
  void Append(IceCandidateCollection collection);

  
  
  
  size_t remove(const IceCandidate* candidate);

  const std::vector<std::unique_ptr<IceCandidate>>& candidates() const {
    return candidates_;
  }

  
  bool HasCandidate(const IceCandidate* candidate) const;

  IceCandidateCollection Clone() const;
  void RelinquishThreadOwnership();

 private:
  RTC_NO_UNIQUE_ADDRESS SequenceChecker sequence_checker_;
  std::vector<std::unique_ptr<IceCandidate>> candidates_
      RTC_GUARDED_BY(sequence_checker_);
};




enum class SdpType {
  kOffer,     
  kPrAnswer,  
              
  kAnswer,    
              
              
  kRollback   
              
};



RTC_EXPORT const char* SdpTypeToString(SdpType type);

template <typename Sink>
void AbslStringify(Sink& sink, SdpType sdp_type) {
  sink.Append(SdpTypeToString(sdp_type));
}




RTC_EXPORT std::optional<SdpType> SdpTypeFromString(
    const std::string& type_str);







class RTC_EXPORT SessionDescriptionInterface final {
 public:
  static std::unique_ptr<SessionDescriptionInterface> Create(
      SdpType type,
      std::unique_ptr<SessionDescription> description,
      absl::string_view id,
      absl::string_view version,
      std::vector<IceCandidateCollection> candidates = {});

  SessionDescriptionInterface(const SessionDescriptionInterface&) = delete;
  SessionDescriptionInterface& operator=(const SessionDescriptionInterface&) =
      delete;

  
  static const char kOffer[];
  static const char kPrAnswer[];
  static const char kAnswer[];
  static const char kRollback[];

  ~SessionDescriptionInterface();

  
  
  std::unique_ptr<SessionDescriptionInterface> Clone() const;

  absl::string_view id() const { return id_; }
  absl::string_view version() const { return version_; }

  
  const SessionDescription* description() const { return description_.get(); }
  SessionDescription* description() { return description_.get(); }

  
  
  std::string session_id() const { return std::string(id()); }
  std::string session_version() const { return std::string(version()); }

  
  
  SdpType GetType() const { return sdp_type_; }

  
  std::string type() const { return SdpTypeToString(sdp_type_); }

  
  
  
  
  
  
  
  bool AddCandidate(const IceCandidate* candidate);

  
  
  
  
  
  
  bool RemoveCandidate(const IceCandidate* candidate);

  
  size_t number_of_mediasections() const;

  
  
  const IceCandidateCollection* candidates(size_t mediasection_index) const;

  
  bool ToString(std::string* out) const {
    if (!out)
      return false;
    *out = ToString();
    return !out->empty();
  }

  
  std::string ToString() const;

  template <typename Sink>
  friend void AbslStringify(Sink& sink, const SessionDescriptionInterface& p) {
    sink.Append("\n--- BEGIN SDP ");
    absl::Format(&sink, "%v", p.GetType());
    sink.Append(" ---\n");
    std::string temp = p.ToString();
    if (!temp.empty()) {
      sink.Append(temp);
    } else {
      sink.Append("<no session description>\n");
    }
    sink.Append("--- END SDP ---\n");
  }

  
  
  
  
  void RelinquishThreadOwnership();

 protected:
  explicit SessionDescriptionInterface(
      SdpType type,
      std::unique_ptr<SessionDescription> description,
      absl::string_view id,
      absl::string_view version,
      std::vector<IceCandidateCollection> candidates = {});

 private:
  bool IsValidMLineIndex(int index) const;
  bool GetMediasectionIndex(const IceCandidate* candidate, size_t* index) const;
  int GetMediasectionIndex(absl::string_view mid) const;

  const SdpType sdp_type_;
  const std::string id_;
  const std::string version_;
  absl_nullable const std::unique_ptr<SessionDescription> description_;

  RTC_NO_UNIQUE_ADDRESS SequenceChecker sequence_checker_{
      SequenceChecker::kDetached};
  std::vector<IceCandidateCollection> candidate_collection_
      RTC_GUARDED_BY(sequence_checker_);
};





RTC_EXPORT std::unique_ptr<SessionDescriptionInterface>
CreateSessionDescription(SdpType type, absl::string_view sdp);
RTC_EXPORT std::unique_ptr<SessionDescriptionInterface>
CreateSessionDescription(SdpType type,
                         absl::string_view sdp,
                         SdpParseError* error_out);



std::unique_ptr<SessionDescriptionInterface> CreateSessionDescription(
    SdpType type,
    absl::string_view session_id,
    absl::string_view session_version,
    std::unique_ptr<SessionDescription> description);


std::unique_ptr<SessionDescriptionInterface> CreateRollbackSessionDescription(
    absl::string_view session_id = "",
    absl::string_view session_version = "");


class RTC_EXPORT CreateSessionDescriptionObserver : public RefCountInterface {
 public:
  
  
  
  virtual void OnSuccess(SessionDescriptionInterface* desc) = 0;
  
  
  
  
  
  
  virtual void OnFailure(RTCError error) = 0;

 protected:
  ~CreateSessionDescriptionObserver() override = default;
};


class RTC_EXPORT SetSessionDescriptionObserver : public RefCountInterface {
 public:
  virtual void OnSuccess() = 0;
  
  virtual void OnFailure(RTCError error) = 0;

 protected:
  ~SetSessionDescriptionObserver() override = default;
};

}  

#endif  
