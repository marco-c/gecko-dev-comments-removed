









#include "video/timing/simulator/assembler.h"

#include <cstdint>
#include <memory>
#include <utility>

#include "absl/base/nullability.h"
#include "api/environment/environment.h"
#include "api/rtp_parameters.h"
#include "api/sequence_checker.h"
#include "api/video/encoded_frame.h"
#include "api/video/video_codec_type.h"
#include "call/video_receive_stream.h"
#include "modules/rtp_rtcp/include/receive_statistics.h"
#include "modules/rtp_rtcp/source/rtp_packet_received.h"

namespace webrtc::video_timing_simulator {

namespace {

VideoReceiveStreamInterface::Config CreateVideoReceiveStreamConfig(
    uint32_t ssrc) {
  VideoReceiveStreamInterface::Config config(nullptr);
  config.rtp.remote_ssrc = ssrc;
  
  
  config.rtp.local_ssrc = ssrc + 1;
  return config;
}

}  

Assembler::Assembler(const Environment& env,
                     uint32_t ssrc,
                     AssemblerEvents* absl_nonnull observer,
                     AssembledFrameCallback* absl_nonnull assembled_frame_cb)
    : env_(env),
      video_receive_stream_config_(CreateVideoReceiveStreamConfig(ssrc)),
      rtp_receive_statistics_(
          ReceiveStatistics::CreateThreadCompatible(&env_.clock())),
      
      
      rtp_video_stream_receiver2_(env_,
                                  nullptr,
                                  this,
                                  nullptr,
                                  nullptr,
                                  &video_receive_stream_config_,
                                  rtp_receive_statistics_.get(),
                                  nullptr,
                                  nullptr,
                                  nullptr,
                                  this,
                                  nullptr,
                                  nullptr),
      observer_(*observer),
      assembled_frame_cb_(*assembled_frame_cb) {
  RTC_DCHECK_RUN_ON(&sequence_checker_);
  rtp_video_stream_receiver2_.StartReceive();
}

Assembler::~Assembler() {
  RTC_DCHECK_RUN_ON(&sequence_checker_);
  rtp_video_stream_receiver2_.StopReceive();
}

void Assembler::InsertPacket(const RtpPacketReceived& rtp_packet) {
  RTC_DCHECK_RUN_ON(&sequence_checker_);
  
  uint8_t payload_type = rtp_packet.PayloadType();
  if (registered_payload_types_.find(payload_type) ==
      registered_payload_types_.end()) {
    CodecParameterMap unused_map;
    rtp_video_stream_receiver2_.AddReceiveCodec(
        payload_type, VideoCodecType::kVideoCodecGeneric, unused_map,
        true);
    registered_payload_types_.insert(payload_type);
  }
  rtp_video_stream_receiver2_.OnRtpPacket(rtp_packet);
}

void Assembler::OnDecodedFrameId(int64_t frame_id) {
  RTC_DCHECK_RUN_ON(&sequence_checker_);
  
  rtp_video_stream_receiver2_.FrameDecoded(frame_id);
}

void Assembler::OnCompleteFrame(std::unique_ptr<EncodedFrame> encoded_frame) {
  RTC_DCHECK_RUN_ON(&sequence_checker_);
  
  
  observer_.OnAssembledFrame(*encoded_frame);
  assembled_frame_cb_.OnAssembledFrame(std::move(encoded_frame));
}

}  
