









#ifndef VIDEO_TIMING_SIMULATOR_RENDERING_TRACKER_H_
#define VIDEO_TIMING_SIMULATOR_RENDERING_TRACKER_H_

#include <cstddef>
#include <cstdint>
#include <memory>
#include <optional>

#include "absl/base/nullability.h"
#include "api/environment/environment.h"
#include "api/sequence_checker.h"
#include "api/task_queue/pending_task_safety_flag.h"
#include "api/task_queue/task_queue_base.h"
#include "api/units/time_delta.h"
#include "api/video/encoded_frame.h"
#include "api/video/video_content_type.h"
#include "api/video/video_frame.h"
#include "api/video/video_sink_interface.h"
#include "api/video/video_timing.h"
#include "modules/video_coding/timing/timing.h"
#include "rtc_base/thread_annotations.h"
#include "video/timing/simulator/assembler.h"
#include "video/video_stream_buffer_controller.h"

namespace webrtc::video_timing_simulator {


class RenderingTrackerEvents {
 public:
  virtual ~RenderingTrackerEvents() = default;
  virtual void OnDecodedFrame(const EncodedFrame& decoded_frame,
                              int frames_dropped,
                              TimeDelta jitter_buffer_minimum_delay,
                              TimeDelta jitter_buffer_target_delay,
                              TimeDelta jitter_buffer_delay) = 0;
  virtual void OnRenderedFrame(const VideoFrame& rendered_frame) = 0;
};








class RenderingTracker : public AssembledFrameCallback,
                         public FrameSchedulingReceiver,
                         public VideoStreamBufferControllerStatsObserver,
                         public VideoSinkInterface<VideoFrame> {
 public:
  
  struct Config {
    uint32_t ssrc = 0;
    
    TimeDelta max_wait_for_keyframe = TimeDelta::MinusInfinity();
    
    TimeDelta max_wait_for_frame = TimeDelta::MinusInfinity();
    
    TimeDelta render_delay = TimeDelta::MinusInfinity();
  };

  RenderingTracker(const Environment& env,
                   const Config& config,
                   std::unique_ptr<VCMTiming> video_timing,
                   RenderingTrackerEvents* absl_nonnull observer);
  ~RenderingTracker() override;

  RenderingTracker(const RenderingTracker&) = delete;
  RenderingTracker& operator=(const RenderingTracker&) = delete;

  void SetDecodedFrameIdCallback(
      DecodedFrameIdCallback* absl_nonnull decoded_id_cb);

  
  
  void OnAssembledFrame(std::unique_ptr<EncodedFrame> assembled_frame) override;

 private:
  struct VideoStreamBufferControllerObserverDecodableStats {
    TimeDelta jitter_buffer_delay = TimeDelta::Zero();
    TimeDelta jitter_buffer_target_delay = TimeDelta::Zero();
    TimeDelta jitter_buffer_minimum_delay = TimeDelta::Zero();
  };

  
  void OnEncodedFrame(std::unique_ptr<EncodedFrame> encoded_frame) override;
  void OnDecodableFrameTimeout(TimeDelta wait_time) override;

  
  void OnCompleteFrame(bool, size_t, VideoContentType) override {}
  void OnDroppedFrames(uint32_t frames_dropped) override;
  void OnDecodableFrame(TimeDelta jitter_buffer_delay,
                        TimeDelta jitter_buffer_target_delay,
                        TimeDelta jitter_buffer_minimum_delay) override;
  void OnFrameBufferTimingsUpdated(int, int, int, int, int, int) override {}
  void OnTimingFrameInfoUpdated(const TimingFrameInfo&) override {}

  
  void OnFrame(const VideoFrame& decoded_frame) override;

  void ResetVideoStreamBufferControllerObserverStats();

  
  SequenceChecker sequence_checker_;
  const Environment env_;
  const Config config_;
  TaskQueueBase* const simulator_queue_;

  
  std::unique_ptr<VCMTiming> video_timing_ RTC_GUARDED_BY(sequence_checker_);
  VideoStreamBufferController video_stream_buffer_controller_
      RTC_GUARDED_BY(sequence_checker_);
  std::unique_ptr<VideoSinkInterface<VideoFrame>> incoming_video_stream_
      RTC_GUARDED_BY(sequence_checker_);

  
  
  
  std::optional<int> vsbc_frames_dropped_;
  std::optional<VideoStreamBufferControllerObserverDecodableStats>
      vsbc_decodable_stats_;

  
  RenderingTrackerEvents& observer_;
  DecodedFrameIdCallback* absl_nullable decoded_frame_id_cb_
      RTC_GUARDED_BY(sequence_checker_);

  
  
  ScopedTaskSafety safety_;
};

}  

#endif  
