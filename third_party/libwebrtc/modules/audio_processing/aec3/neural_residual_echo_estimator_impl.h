









#ifndef MODULES_AUDIO_PROCESSING_AEC3_NEURAL_RESIDUAL_ECHO_ESTIMATOR_IMPL_H_
#define MODULES_AUDIO_PROCESSING_AEC3_NEURAL_RESIDUAL_ECHO_ESTIMATOR_IMPL_H_

#include <array>
#include <memory>
#include <vector>

#include "absl/base/nullability.h"
#include "absl/strings/string_view.h"
#include "api/array_view.h"
#include "api/audio/echo_canceller3_config.h"
#include "api/audio/neural_residual_echo_estimator.h"
#include "modules/audio_processing/aec3/aec3_common.h"
#include "modules/audio_processing/aec3/neural_feature_extractor.h"
#include "modules/audio_processing/logging/apm_data_dumper.h"
#include "third_party/tflite/src/tensorflow/lite/op_resolver.h"
#ifdef WEBRTC_ANDROID_PLATFORM_BUILD
#include "external/webrtc/webrtc/modules/audio_processing/aec3/neural_residual_echo_estimator.pb.h"
#else
#include "modules/audio_processing/aec3/neural_residual_echo_estimator.pb.h"
#endif

namespace webrtc {






class NeuralResidualEchoEstimatorImpl : public NeuralResidualEchoEstimator {
 public:
  enum class ModelInputEnum {
    kModelState = 0,
    kMic = 1,
    kLinearAecOutput = 2,
    kAecRef = 3,
    kNumInputs = 4
  };
  enum class ModelOutputEnum {
    kEchoMask = 0,
    kModelState = 1,
    kNumOutputs = 2
  };

  
  class ModelRunner {
   public:
    virtual ~ModelRunner() = default;

    virtual int StepSize() const = 0;
    virtual ArrayView<float> GetInput(ModelInputEnum input_enum) = 0;
    virtual ArrayView<const float> GetOutputEchoMask() = 0;
    virtual const audioproc::ReeModelMetadata& GetMetadata() const = 0;
    virtual bool Invoke() = 0;
  };

  
  
  static absl_nullable std::unique_ptr<NeuralResidualEchoEstimator> Create(
      absl::string_view ml_ree_model_path,
      const tflite::OpResolver& op_resolver);

  
  static std::unique_ptr<ModelRunner> LoadTfLiteModel(
      absl::string_view ml_ree_model_path,
      const tflite::OpResolver& op_resolver);

  
  explicit NeuralResidualEchoEstimatorImpl(
      absl_nonnull std::unique_ptr<ModelRunner> model_runner);

  void Estimate(
      ArrayView<const float> x,
      ArrayView<const std::array<float, kBlockSize>> y,
      ArrayView<const std::array<float, kBlockSize>> e,
      ArrayView<const std::array<float, kFftLengthBy2Plus1>> S2,
      ArrayView<const std::array<float, kFftLengthBy2Plus1>> Y2,
      ArrayView<const std::array<float, kFftLengthBy2Plus1>> E2,
      ArrayView<std::array<float, kFftLengthBy2Plus1>> R2,
      ArrayView<std::array<float, kFftLengthBy2Plus1>> R2_unbounded) override;

  EchoCanceller3Config GetConfiguration(bool multi_channel) const override;

 private:
  void DumpInputs();

  
  const std::unique_ptr<ModelRunner> model_runner_;
  std::unique_ptr<FeatureExtractor> feature_extractor_;

  
  
  std::vector<float> input_mic_buffer_;
  std::vector<float> input_linear_aec_output_buffer_;
  std::vector<float> input_aec_ref_buffer_;

  
  
  std::array<float, kFftLengthBy2Plus1> output_mask_;

  static int instance_count_;
  
  std::unique_ptr<ApmDataDumper> data_dumper_;
};

}  

#endif  
