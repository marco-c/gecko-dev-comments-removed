








#ifndef MODULES_REMOTE_BITRATE_ESTIMATOR_CONGESTION_CONTROL_FEEDBACK_TRACKER_H_
#define MODULES_REMOTE_BITRATE_ESTIMATOR_CONGESTION_CONTROL_FEEDBACK_TRACKER_H_

#include <cstdint>
#include <vector>

#include "api/transport/ecn_marking.h"
#include "api/units/timestamp.h"
#include "modules/rtp_rtcp/source/rtcp_packet/congestion_control_feedback.h"
#include "modules/rtp_rtcp/source/rtp_packet_received.h"
#include "rtc_base/numerics/sequence_number_unwrapper.h"

namespace webrtc {




class CongestionControlFeedbackTracker {
 public:
  explicit CongestionControlFeedbackTracker(uint32_t ssrc) : ssrc_(ssrc) {}

  void ReceivedPacket(const RtpPacketReceived& packet);

  
  
  
  
  void AddPacketsToFeedback(
      Timestamp feedback_time,
      std::vector<rtcp::CongestionControlFeedback::PacketInfo>&
          packet_feedback);

  
  
  int64_t NumPacketsReportedAsLost() const { return num_reported_lost_; }

  
  
  
  int64_t NumPacketsReportedAsLostButRecovered() const {
    return num_reported_recovered_;
  }

 private:
  struct PacketInfo {
    bool received() const { return arrival_time != Timestamp::MinusInfinity(); }

    Timestamp arrival_time = Timestamp::MinusInfinity();
    EcnMarking ecn = EcnMarking::kNotEct;

    
    
    bool last_reported_as_lost = false;
  };

  
  
  
  PacketInfo* FindOrCreatePacketInfo(int64_t sequence_number);

  const uint32_t ssrc_;
  SeqNumUnwrapper<uint16_t> unwrapper_;

  
  
  
  std::vector<PacketInfo> packets_;

  
  
  int64_t first_sequence_number_in_packets_ = -1;

  
  
  int64_t next_sequence_number_in_feedback_ = -1;

  
  
  int num_ignored_packets_since_last_feedback_ = 0;

  int64_t num_reported_lost_ = 0;
  int64_t num_reported_recovered_ = 0;
};

}  

#endif  
