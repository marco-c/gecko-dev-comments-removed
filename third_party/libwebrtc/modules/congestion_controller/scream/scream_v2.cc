









#include "modules/congestion_controller/scream/scream_v2.h"

#include <algorithm>
#include <memory>
#include <vector>

#include "api/environment/environment.h"
#include "api/transport/ecn_marking.h"
#include "api/transport/network_types.h"
#include "api/units/data_rate.h"
#include "api/units/data_size.h"
#include "api/units/time_delta.h"
#include "api/units/timestamp.h"
#include "logging/rtc_event_log/events/rtc_event_bwe_update_scream.h"
#include "rtc_base/checks.h"
#include "rtc_base/experiments/field_trial_parser.h"
#include "rtc_base/logging.h"

namespace webrtc {

namespace {



DataSize DataUnitsAckedAndNotMarked(const TransportPacketsFeedback& msg) {
  DataSize acked_not_marked = DataSize::Zero();
  for (const PacketResult& packet : msg.PacketsWithFeedback()) {
    if (packet.ecn != EcnMarking::kCe) {
      acked_not_marked += packet.sent_packet.size;
    }
  }
  return acked_not_marked;
}

bool HasCeMarking(const TransportPacketsFeedback& msg) {
  for (const auto& packet : msg.PacketsWithFeedback()) {
    if (packet.ecn == EcnMarking::kCe) {
      return true;
    }
  }
  return false;
}

bool HasLostPackets(const TransportPacketsFeedback& msg) {
  for (const auto& packet : msg.PacketsWithFeedback()) {
    if (!packet.IsReceived()) {
      return true;
    }
  }
  return false;
}

}  

ScreamV2::ScreamV2(const Environment& env)
    : env_(env),
      params_(env_.field_trials()),
      ref_window_(params_.min_ref_window.Get()),
      delay_based_congestion_control_(params_) {}

void ScreamV2::SetTargetBitrateConstraints(DataRate min, DataRate max) {
  RTC_DCHECK_GE(max, min);
  min_target_bitrate_ = min;
  max_target_bitrate_ = max;
  RTC_LOG_F(LS_INFO) << "min_target_bitrate_=" << min_target_bitrate_
                     << " max_target_bitrate_=" << max_target_bitrate_;
}

DataRate ScreamV2::OnTransportPacketsFeedback(
    const TransportPacketsFeedback& msg) {
  delay_based_congestion_control_.OnTransportPacketsFeedback(msg);
  UpdateL4SAlpha(msg);
  UpdateRefWindowAndTargetRate(msg);
  env_.event_log().Log(std::make_unique<RtcEventBweUpdateScream>(
      ref_window_, msg.data_in_flight, target_rate_, msg.smoothed_rtt,
      delay_based_congestion_control_.queue_delay(),
       l4s_alpha_ * 1000));
  return target_rate_;
}

void ScreamV2::UpdateL4SAlpha(const TransportPacketsFeedback& msg) {
  
  const std::vector<PacketResult> received_packets = msg.ReceivedWithSendInfo();
  if (received_packets.empty()) {
    return;
  }
  data_units_delivered_this_rtt_ += received_packets.size();
  for (const PacketResult& packet : received_packets) {
    if (packet.ecn == EcnMarking::kCe) {
      ++data_units_marked_this_rtt_;
    }
  }

  
  constexpr TimeDelta kMaxTimeBetweenL4sUpdate = TimeDelta::Millis(10);
  if (msg.feedback_time - last_l4s_alpha_update_ <
      std::min(kMaxTimeBetweenL4sUpdate, msg.smoothed_rtt)) {
    return;
  }
  last_l4s_alpha_update_ = msg.feedback_time;

  double fraction_marked = static_cast<double>(data_units_marked_this_rtt_) /
                           data_units_delivered_this_rtt_;
  l4s_alpha_ = params_.l4s_avg_g.Get() * fraction_marked +
               (1.0 - params_.l4s_avg_g.Get()) * l4s_alpha_;

  data_units_delivered_this_rtt_ = 0;
  data_units_marked_this_rtt_ = 0;
}

void ScreamV2::UpdateRefWindowAndTargetRate(
    const TransportPacketsFeedback& msg) {
  max_data_in_flight_this_rtt_ =
      std::max(max_data_in_flight_this_rtt_, msg.data_in_flight);

  
  
  double scale_close_to_ref_window_i =
      ref_window_scale_factor_close_to_ref_window_i();

  
  const TimeDelta non_zero_smoothed_rtt =
      std::max(msg.smoothed_rtt, TimeDelta::Millis(1));

  double virtual_alpha_lim =
      ((2 * params_.max_segment_size.Get()) / non_zero_smoothed_rtt) /
      target_rate_;
  bool is_ce = false;
  bool is_loss = false;
  bool is_virtual_ce = false;
  if (msg.feedback_time - last_reaction_to_congestion_time_ >=
      std::min(msg.smoothed_rtt, params_.virtual_rtt.Get())) {
    is_ce = HasCeMarking(msg);
    is_loss = HasLostPackets(msg);
    if (l4s_alpha_ < virtual_alpha_lim &&
        delay_based_congestion_control_.ShouldReduceReferenceWindow()) {
      
      is_virtual_ce = true;
    }
  }

  
  
  if (is_virtual_ce || is_loss || is_ce) {
    if (msg.feedback_time - last_ref_window_i_update_ >
        params_.number_of_rtts_between_ref_window_i_updates.Get() *
            msg.smoothed_rtt) {
      
      
      last_ref_window_i_update_ = msg.feedback_time;
      ref_window_i_ = ref_window_;
    }
  }

  DataSize previous_ref_window = ref_window_;
  if (is_loss) {  
    ref_window_ = ref_window_ * params_.beta_loss.Get();
  }
  if (is_ce) {  
    double backoff = l4s_alpha_ / 2.0;
    
    backoff *= std::max(0.5, 1.0 - ref_window_mss_ratio());

    if (!delay_based_congestion_control_.IsQueueDelayDetected()) {
      
      
      backoff *= std::max(0.25, scale_close_to_ref_window_i);
    }

    if (msg.feedback_time - last_reaction_to_congestion_time_ >
        params_.number_of_rtts_between_reset_ref_window_i_on_congestion.Get() *
            std::max(params_.virtual_rtt.Get(), msg.smoothed_rtt)) {
      
      
      
      
      
      ref_window_ = std::clamp(max_data_in_flight_prev_rtt_,
                               params_.min_ref_window.Get(), ref_window_);
      
      
      
      
      backoff = std::max(backoff, 0.25);
      
      
      
      l4s_alpha_ = 0.25;
    }
    ref_window_ = (1.0 - backoff) * ref_window_;
  }  
  if (is_virtual_ce) {  
    ref_window_ = delay_based_congestion_control_.UpdateReferenceWindow(
        ref_window_, virtual_alpha_lim);
  }
  if (is_virtual_ce || is_ce || is_loss) {
    last_reaction_to_congestion_time_ = msg.feedback_time;
  }

  
  
  DataSize increase = DataUnitsAckedAndNotMarked(msg) * ref_window_mss_ratio();

  
  if (msg.smoothed_rtt < params_.virtual_rtt.Get()) {
    double rtt_ratio = msg.smoothed_rtt / params_.virtual_rtt.Get();
    increase = increase * (rtt_ratio * rtt_ratio);
  }
  if (l4s_alpha_ < virtual_alpha_lim) {
    
    increase = increase * delay_based_congestion_control_.scale_increase();
  }
  
  
  increase = increase * std::max(0.25, scale_close_to_ref_window_i);
  
  
  increase = increase * std::max(0.5, 1.0 - ref_window_mss_ratio());

  const TimeDelta max_of_virtual_and_smothed_rtt =
      std::max(params_.virtual_rtt.Get(), msg.smoothed_rtt);

  
  
  double post_congestion_scale =
      std::clamp((msg.feedback_time - last_reaction_to_congestion_time_) /
                     (params_.post_congestion_delay_rtts.Get() *
                      max_of_virtual_and_smothed_rtt),
                 0.0, 1.0);
  double multiplicative_scale =
      1.0 + (ref_window_multiplicative_scale_factor() - 1.0) *
                post_congestion_scale * scale_close_to_ref_window_i;
  RTC_DCHECK_GE(multiplicative_scale, 1.0);
  increase = increase * multiplicative_scale;

  
  
  
  DataSize max_allowed_ref_window = std::max(
      params_.max_segment_size.Get() +
          std::max(max_data_in_flight_this_rtt_, max_data_in_flight_prev_rtt_) *
              params_.bytes_in_flight_head_room.Get(),
      params_.min_ref_window.Get());

  if (ref_window_ < max_allowed_ref_window) {
    ref_window_ =
        std::clamp(ref_window_ + increase, params_.min_ref_window.Get(),
                   max_allowed_ref_window);
  }

  double scale_target_rate = 1.0;
  if (delay_based_congestion_control_.IsQueueDelayDetected()) {
    
    
    
    
    
    
    double data_in_flight_ratio = msg.data_in_flight / ref_window_;
    if (data_in_flight_ratio > params_.data_in_flight_limit.Get()) {
      scale_target_rate /=
          std::min(params_.max_data_in_flight_limit_compensation.Get(),
                   data_in_flight_ratio / params_.data_in_flight_limit.Get());
    }
  }
  
  
  scale_target_rate =
      scale_target_rate *
      (1.0 - std::clamp(ref_window_mss_ratio() - 0.1, 0.0, 0.2));
  target_rate_ =
      std::clamp(scale_target_rate * (ref_window_ / non_zero_smoothed_rtt),
                 min_target_bitrate_, max_target_bitrate_);

  RTC_LOG_IF(LS_VERBOSE, previous_ref_window != ref_window_)
      << "ScreamV2: "
      << ", ref_window = " << ref_window_ << " ref_window_i_=" << ref_window_i_
      << ", change=" << ref_window_.bytes() - previous_ref_window.bytes()
      << " bytes "
      << ", l4s_alpha=" << l4s_alpha_
      << ", scale_target_rate=" << scale_target_rate << ", is_ce=" << is_ce
      << " is_loss=" << is_loss << " smoothed_rtt=" << msg.smoothed_rtt
      << ", queue_delay=" << delay_based_congestion_control_.queue_delay()
      << ", target_rate_=" << target_rate_
      << " is_virtual_ce=" << is_virtual_ce;

  if (msg.feedback_time - last_data_in_flight_update_ >=
      max_of_virtual_and_smothed_rtt) {
    last_data_in_flight_update_ = msg.feedback_time;
    max_data_in_flight_prev_rtt_ = max_data_in_flight_this_rtt_;
    max_data_in_flight_this_rtt_ = DataSize::Zero();
  }
}

}  
