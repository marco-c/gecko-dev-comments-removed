









#ifndef MODULES_CONGESTION_CONTROLLER_SCREAM_SCREAM_V2_H_
#define MODULES_CONGESTION_CONTROLLER_SCREAM_SCREAM_V2_H_

#include <algorithm>

#include "api/environment/environment.h"
#include "api/field_trials_view.h"
#include "api/transport/network_types.h"
#include "api/units/data_rate.h"
#include "api/units/data_size.h"
#include "api/units/time_delta.h"
#include "api/units/timestamp.h"
#include "rtc_base/experiments/field_trial_parser.h"

namespace webrtc {









class ScreamV2 {
 public:
  explicit ScreamV2(const Environment& env);
  ~ScreamV2() = default;

  void SetTargetBitrateConstraints(DataRate min, DataRate max);
  
  DataRate OnTransportPacketsFeedback(const TransportPacketsFeedback& msg);

  
  
  DataSize ref_window() const { return ref_window_; }

  
  double l4s_alpha() const { return l4s_alpha_; }

 private:
  struct Parameters {
    explicit Parameters(const FieldTrialsView& trials);

    
    FieldTrialParameter<DataSize> min_ref_window;

    
    FieldTrialParameter<double> l4s_avg_g;

    
    
    
    FieldTrialParameter<DataSize> max_segment_size;

    
    FieldTrialParameter<double> bytes_in_flight_head_room;

    
    
    FieldTrialParameter<int> post_congestion_delay_rtts;

    
    
    FieldTrialParameter<double> multiplicative_increase_factor;

    
    
    FieldTrialParameter<TimeDelta> virtual_rtt;

    
    
    
    
    FieldTrialParameter<double> backoff_scale_factor_close_to_ref_window_i;

    FieldTrialParameter<int> number_of_rtts_between_ref_window_i_updates;

    
    
    FieldTrialParameter<int>
        number_of_rtts_between_reset_ref_window_i_on_congestion;
  };

  void UpdateL4SAlpha(const TransportPacketsFeedback& msg);
  void UpdateRefWindowAndTargetRate(const TransportPacketsFeedback& msg);

  
  double ref_window_mss_ratio() const {
    return params_.max_segment_size.Get() / ref_window_;
  }

  
  
  
  double ref_window_scale_factor_close_to_ref_window_i() const {
    const double scale_factor =
        params_.backoff_scale_factor_close_to_ref_window_i.Get();
    double scl =
        ref_window_ > ref_window_i_
            ? scale_factor * (ref_window_ - ref_window_i_) / ref_window_i_
            : scale_factor * (ref_window_i_ - ref_window_) / ref_window_i_;
    return std::clamp(scl * scl, 0.1, 1.0);
  }

  
  
  double ref_window_multiplicative_scale_factor() const {
    return 1.0 + (params_.multiplicative_increase_factor.Get() * ref_window_) /
                     params_.max_segment_size.Get();
  }

  const Environment env_;
  const Parameters params_;

  DataRate max_target_bitrate_ = DataRate::PlusInfinity();
  DataRate min_target_bitrate_ = DataRate::Zero();
  DataRate target_rate_ = DataRate::Zero();

  
  
  DataSize ref_window_;
  
  
  
  DataSize ref_window_i_ = DataSize::Bytes(1);
  Timestamp last_ref_window_i_update_ = Timestamp::MinusInfinity();

  
  
  double l4s_alpha_ = 0.0;
  Timestamp last_l4s_alpha_update_ = Timestamp::MinusInfinity();
  Timestamp last_ce_mark_detected_time_ = Timestamp::MinusInfinity();

  
  int data_units_delivered_this_rtt_ = 0;
  int data_units_marked_this_rtt_ = 0;
  Timestamp last_data_in_flight_update_ = Timestamp::MinusInfinity();
  DataSize max_data_in_flight_this_rtt_ = DataSize::Zero();
  DataSize max_data_in_flight_prev_rtt_ = DataSize::Zero();

  
  
  
  
  Timestamp last_reaction_to_congestion_time_ = Timestamp::MinusInfinity();
};

}  
#endif  
