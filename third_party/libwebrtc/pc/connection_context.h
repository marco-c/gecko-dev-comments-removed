









#ifndef PC_CONNECTION_CONTEXT_H_
#define PC_CONNECTION_CONTEXT_H_

#include <memory>
#include <utility>

#include "api/environment/environment.h"
#include "api/packet_socket_factory.h"
#include "api/peer_connection_interface.h"
#include "api/ref_counted_base.h"
#include "api/scoped_refptr.h"
#include "api/sequence_checker.h"
#include "api/transport/sctp_transport_factory_interface.h"
#include "media/base/media_engine.h"
#include "rtc_base/memory/always_valid_pointer.h"
#include "rtc_base/network.h"
#include "rtc_base/network_monitor_factory.h"
#include "rtc_base/socket_factory.h"
#include "rtc_base/thread.h"
#include "rtc_base/thread_annotations.h"
#include "rtc_base/unique_id_generator.h"

namespace webrtc {







class ConnectionContext final : public RefCountedNonVirtual<ConnectionContext> {
 public:
  
  
  
  static scoped_refptr<ConnectionContext> Create(
      const Environment& env,
      PeerConnectionFactoryDependencies* dependencies);

  class MediaEngineReference {
   public:
    explicit MediaEngineReference(scoped_refptr<ConnectionContext> c)
        : c_(std::move(c)) {
      if (c_->media_engine()) {
        c_->AddRefMediaEngine();
      }
    }
    ~MediaEngineReference() {
      if (c_->media_engine()) {
        c_->ReleaseMediaEngine();
      }
    }

    
    
    
    MediaEngineInterface* media_engine() const;

   private:
    const scoped_refptr<ConnectionContext> c_;
  };

  
  ConnectionContext(const ConnectionContext&) = delete;
  ConnectionContext& operator=(const ConnectionContext&) = delete;

  
  SctpTransportFactoryInterface* sctp_transport_factory() const {
    return sctp_factory_.get();
  }

  
  const MediaEngineInterface* media_engine() const {
    return media_engine_.get();
  }

  bool is_configured_for_media() const { return is_configured_for_media_; }

  Thread* signaling_thread() { return signaling_thread_; }
  const Thread* signaling_thread() const { return signaling_thread_; }
  Thread* worker_thread() { return worker_thread_.get(); }
  const Thread* worker_thread() const { return worker_thread_.get(); }
  Thread* network_thread() { return network_thread_; }
  const Thread* network_thread() const { return network_thread_; }

  
  NetworkManager* default_network_manager() const {
    RTC_DCHECK_RUN_ON(signaling_thread_);
    return default_network_manager_.get();
  }
  PacketSocketFactory* default_socket_factory() const {
    RTC_DCHECK_RUN_ON(signaling_thread_);
    return default_socket_factory_.get();
  }
  MediaFactory* call_factory() {
    RTC_DCHECK_RUN_ON(worker_thread());
    return call_factory_.get();
  }
  UniqueRandomIdGenerator* ssrc_generator() { return &ssrc_generator_; }
  
  
  
  
  bool use_rtx() const { return use_rtx_; }

  
  void set_use_rtx(bool use_rtx) { use_rtx_ = use_rtx; }

 protected:
  friend class MediaEngineReference;
  
  
  void AddRefMediaEngine();

  
  
  void ReleaseMediaEngine();

  
  
  MediaEngineInterface* media_engine_w();

  ConnectionContext(const Environment& env,
                    PeerConnectionFactoryDependencies* dependencies);

  friend class RefCountedNonVirtual<ConnectionContext>;
  ~ConnectionContext();

 private:
  
  
  bool wraps_current_thread_;
  const bool is_configured_for_media_;
  std::unique_ptr<SocketFactory> owned_socket_factory_;
  std::unique_ptr<Thread> owned_network_thread_
      RTC_GUARDED_BY(signaling_thread_);
  bool blocking_media_engine_destruction_;
  Thread* const network_thread_;
  AlwaysValidPointer<Thread> const worker_thread_;
  Thread* const signaling_thread_;

  
  
  std::unique_ptr<MediaEngineInterface> media_engine_;
  int media_engine_reference_count_ RTC_GUARDED_BY(worker_thread()) = 0;

  
  
  
  
  UniqueRandomIdGenerator ssrc_generator_;
  std::unique_ptr<NetworkMonitorFactory> const network_monitor_factory_
      RTC_GUARDED_BY(signaling_thread_);
  std::unique_ptr<NetworkManager> default_network_manager_
      RTC_GUARDED_BY(signaling_thread_);
  std::unique_ptr<MediaFactory> const call_factory_
      RTC_GUARDED_BY(worker_thread());

  std::unique_ptr<PacketSocketFactory> default_socket_factory_
      RTC_GUARDED_BY(signaling_thread_);
  std::unique_ptr<SctpTransportFactoryInterface> const sctp_factory_;

  
  
  bool use_rtx_;
};

}  

#endif  
