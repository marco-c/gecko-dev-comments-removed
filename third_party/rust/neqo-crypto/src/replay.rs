





use std::{
    ops::Deref,
    os::raw::c_uint,
    ptr::null_mut,
    time::{Duration, Instant},
};

use crate::{
    err::Res,
    ssl::PRFileDesc,
    time::{Interval, PRTime, Time},
};


pub enum SSLAntiReplayContext {}

experimental_api!(SSL_CreateAntiReplayContext(
    now: PRTime,
    window: PRTime,
    k: c_uint,
    bits: c_uint,
    ctx: *mut *mut SSLAntiReplayContext,
));
experimental_api!(SSL_ReleaseAntiReplayContext(ctx: *mut SSLAntiReplayContext));
experimental_api!(SSL_SetAntiReplayContext(
    fd: *mut PRFileDesc,
    ctx: *mut SSLAntiReplayContext,
));

scoped_ptr!(
    AntiReplayContext,
    SSLAntiReplayContext,
    SSL_ReleaseAntiReplayContext
);






pub struct AntiReplay {
    ctx: AntiReplayContext,
}

impl AntiReplay {
    
    
    
    
    
    
    
    pub fn new(now: Instant, window: Duration, k: usize, bits: usize) -> Res<Self> {
        let mut ctx: *mut SSLAntiReplayContext = null_mut();
        unsafe {
            SSL_CreateAntiReplayContext(
                Time::from(now).try_into()?,
                Interval::from(window).try_into()?,
                c_uint::try_from(k)?,
                c_uint::try_from(bits)?,
                &raw mut ctx,
            )
        }?;

        Ok(Self {
            ctx: AntiReplayContext::from_ptr(ctx)?,
        })
    }

    
    pub(crate) fn config_socket(&self, fd: *mut PRFileDesc) -> Res<()> {
        unsafe { SSL_SetAntiReplayContext(fd, *self.ctx) }
    }
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use std::time::Duration;

    #[test]
    fn creation() {
        test_fixture::fixture_init();
        for (k, bits, expected) in [(7, 8, true), (usize::MAX, 3, false), (1, usize::MAX, false)] {
            let res = crate::AntiReplay::new(test_fixture::now(), Duration::from_secs(10), k, bits);
            assert_eq!(res.is_ok(), expected);
        }
    }
}
