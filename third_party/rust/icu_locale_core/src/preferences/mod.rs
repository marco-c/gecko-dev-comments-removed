



















































































































































































































































































































pub mod extensions;
mod locale;
pub use locale::*;




















































































pub trait PreferenceKey: Sized {
    
    
    
    
    fn try_from_key_value(
        _key: &crate::extensions::unicode::Key,
        _value: &crate::extensions::unicode::Value,
    ) -> Result<Option<Self>, crate::preferences::extensions::unicode::errors::PreferencesParseError>
    {
        Ok(None)
    }

    
    fn unicode_extension_key() -> Option<crate::extensions::unicode::Key> {
        None
    }

    
    fn unicode_extension_value(&self) -> Option<crate::extensions::unicode::Value> {
        None
    }
}











































#[macro_export]
#[doc(hidden)]
macro_rules! __define_preferences {
    (
        $(#[$doc:meta])*
        $([$derive_attrs:ty])?
        $name:ident,
        {
            $(
                $(#[$key_doc:meta])*
                $key:ident: $pref:ty
            ),*
        }
     ) => (
        $(#[$doc])*
        #[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
        $(#[derive($derive_attrs)])?
        #[non_exhaustive]
        pub struct $name {
            /// Locale Preferences for the Preferences structure.
            pub locale_preferences: $crate::preferences::LocalePreferences,

            $(
                $(#[$key_doc])*
                pub $key: Option<$pref>,
            )*
        }

        impl From<$crate::Locale> for $name {
            fn from(loc: $crate::Locale) -> Self {
                $name::from(&loc)
            }
        }

        impl From<&$crate::Locale> for $name {
            fn from(loc: &$crate::Locale) -> Self {
                $name::from_locale_strict(loc).unwrap_or_else(|e| e)
            }
        }

        impl From<$crate::LanguageIdentifier> for $name {
            fn from(lid: $crate::LanguageIdentifier) -> Self {
                $name::from(&lid)
            }
        }

        impl From<&$crate::LanguageIdentifier> for $name {
            fn from(lid: &$crate::LanguageIdentifier) -> Self {
                Self {
                    locale_preferences: lid.into(),

                    $(
                        $key: None,
                    )*
                }
            }
        }

        // impl From<$name> for $crate::Locale {
        //     fn from(other: $name) -> Self {
        //         use $crate::preferences::PreferenceKey;
        //         let mut result = Self::from(other.locale_preferences);
        //         $(
        //             if let Some(value) = other.$key {
        //                 if let Some(ue) = <$pref>::unicode_extension_key() {
        //                     let val = value.unicode_extension_value().unwrap();
        //                     result.extensions.unicode.keywords.set(ue, val);
        //                 }
        //             }
        //         )*
        //         result
        //     }
        // }

        impl $name {
            /// Extends the preferences with the values from another set of preferences.
            pub fn extend(&mut self, other: $name) {
                self.locale_preferences.extend(other.locale_preferences);
                $(
                    if let Some(value) = other.$key {
                        self.$key = Some(value);
                    }
                )*
            }

            #[doc = concat!("Construct a `", stringify!($name), "` from a `Locale`")]
            ///
            /// Returns `Err` if any of of the preference values are invalid.
            pub fn from_locale_strict(loc: &$crate::Locale) -> Result<Self, Self> {
                use $crate::preferences::PreferenceKey;

                let mut is_err = false;

                $(
                    let mut $key = None;
                )*

                for (k, v) in loc.extensions.unicode.keywords.iter() {
                    $(

                        match <$pref>::try_from_key_value(k, v) {
                            Ok(Some(k)) => {
                                $key = Some(k);
                                continue;
                            }
                            Ok(None) => {}
                            Err(_) => {
                                is_err = true
                            }
                        }
                    )*
                }

                let r = Self {
                    locale_preferences: loc.into(),

                    $(
                        $key,
                    )*
                };

                if is_err {
                    Err(r)
                } else {
                    Ok(r)
                }
            }
        }
    )
}

#[macro_export]
#[doc(hidden)]
macro_rules! __prefs_convert {
    (
        $name1:ident,
        $name2:ident
    ) => {
        impl From<&$name1> for $name2 {
            fn from(other: &$name1) -> Self {
                let mut result = Self::default();
                result.locale_preferences = other.locale_preferences;
                result
            }
        }
    };
    (
        $name1:ident,
        $name2:ident,
        {
            $(
                $key:ident
            ),*
        }
    ) => {
        impl From<&$name1> for $name2 {
            fn from(other: &$name1) -> Self {
                let mut result = Self::default();
                result.locale_preferences = other.locale_preferences;
                $(
                    result.$key = other.$key;
                )*
                result
            }
        }
    };
}

#[doc(inline)]
pub use __define_preferences as define_preferences;

#[doc(inline)]
pub use __prefs_convert as prefs_convert;
