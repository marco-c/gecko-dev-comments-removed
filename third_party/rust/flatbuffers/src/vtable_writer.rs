















use core::ptr::write_bytes;

use crate::endian_scalar::emplace_scalar;
use crate::primitives::*;


#[derive(Debug)]
pub struct VTableWriter<'a> {
    buf: &'a mut [u8],
}

impl<'a> VTableWriter<'a> {
    #[inline(always)]
    pub fn init(buf: &'a mut [u8]) -> Self {
        VTableWriter { buf }
    }

    
    
    
    
    
    
    
    #[inline(always)]
    pub fn write_vtable_byte_length(&mut self, n: VOffsetT) {
        let buf = &mut self.buf[..SIZE_VOFFSET];
        
        
        unsafe {
            emplace_scalar::<VOffsetT>(buf, n);
        }
        debug_assert_eq!(n as usize, self.buf.len());
    }

    
    #[inline(always)]
    pub fn write_object_inline_size(&mut self, n: VOffsetT) {
        let buf = &mut self.buf[SIZE_VOFFSET..2 * SIZE_VOFFSET];
        
        
        unsafe {
            emplace_scalar::<VOffsetT>(buf, n);
        }
    }

    
    
    
    
    #[inline(always)]
    pub fn write_field_offset(&mut self, vtable_offset: VOffsetT, object_data_offset: VOffsetT) {
        let idx = vtable_offset as usize;
        let buf = &mut self.buf[idx..idx + SIZE_VOFFSET];
        
        
        unsafe {
            emplace_scalar::<VOffsetT>(buf, object_data_offset);
        }
    }

    
    
    #[inline(always)]
    pub fn clear(&mut self) {
        
        let len = self.buf.len();
        let p = self.buf.as_mut_ptr() as *mut u8;

        
        
        unsafe {
            write_bytes(p, 0, len);
        }
    }
}
