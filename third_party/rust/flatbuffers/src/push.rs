















use core::cmp::max;
use core::mem::{align_of, size_of};

use crate::endian_scalar::emplace_scalar;




pub trait Push: Sized {
    type Output;

    
    
    
    unsafe fn push(&self, dst: &mut [u8], written_len: usize);
    #[inline]
    fn size() -> usize {
        size_of::<Self::Output>()
    }
    #[inline]
    fn alignment() -> PushAlignment {
        PushAlignment::new(align_of::<Self::Output>())
    }
}

impl<'a, T: Push> Push for &'a T {
    type Output = T::Output;

    unsafe fn push(&self, dst: &mut [u8], written_len: usize) {
        T::push(self, dst, written_len)
    }

    fn size() -> usize {
        T::size()
    }

    fn alignment() -> PushAlignment {
        T::alignment()
    }
}



pub struct PushAlignment(usize);
impl PushAlignment {
    #[inline]
    pub fn new(x: usize) -> Self {
        PushAlignment(x)
    }
    #[inline]
    pub fn value(&self) -> usize {
        self.0
    }
    #[inline]
    pub fn max_of(&self, o: usize) -> Self {
        PushAlignment::new(max(self.0, o))
    }
}


macro_rules! impl_push_for_endian_scalar {
    ($ty:ident) => {
        impl Push for $ty {
            type Output = $ty;

            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                emplace_scalar::<$ty>(dst, *self);
            }
        }
    };
}

impl_push_for_endian_scalar!(bool);
impl_push_for_endian_scalar!(u8);
impl_push_for_endian_scalar!(i8);
impl_push_for_endian_scalar!(u16);
impl_push_for_endian_scalar!(i16);
impl_push_for_endian_scalar!(u32);
impl_push_for_endian_scalar!(i32);
impl_push_for_endian_scalar!(u64);
impl_push_for_endian_scalar!(i64);
impl_push_for_endian_scalar!(f32);
impl_push_for_endian_scalar!(f64);
