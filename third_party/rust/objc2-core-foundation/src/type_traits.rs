use core::ptr::NonNull;

use crate::{CFRetained, CFType, CFTypeID};

















pub unsafe trait Type {
    
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "CFRetain")]
    fn retain(&self) -> CFRetained<Self>
    where
        Self: Sized,
    {
        let ptr = NonNull::from(self);

        
        unsafe { CFRetained::retain(ptr) }
    }

    
    #[deprecated = "this is redundant"]
    #[inline]
    #[allow(non_snake_case)]
    fn as_concrete_TypeRef(&self) -> &Self {
        self
    }

    
    
    
    
    
    #[deprecated = "use CFRetained::retain"]
    #[inline]
    unsafe fn wrap_under_get_rule(ptr: *const Self) -> CFRetained<Self>
    where
        Self: Sized,
    {
        let ptr = NonNull::new(ptr.cast_mut()).expect("attempted to create a NULL object");
        
        unsafe { CFRetained::retain(ptr) }
    }

    
    #[deprecated = "this is redundant (CF types deref to CFType)"]
    #[inline]
    #[allow(non_snake_case)]
    fn as_CFTypeRef(&self) -> &CFType
    where
        Self: AsRef<CFType>,
    {
        self.as_ref()
    }

    
    
    
    
    
    #[deprecated = "use CFRetained::from_raw"]
    #[inline]
    unsafe fn wrap_under_create_rule(ptr: *const Self) -> CFRetained<Self>
    where
        Self: Sized,
    {
        let ptr = NonNull::new(ptr.cast_mut()).expect("attempted to create a NULL object");
        
        unsafe { CFRetained::from_raw(ptr) }
    }
}









































pub unsafe trait ConcreteType: Type {
    
    
    
    
    #[doc(alias = "GetTypeID")]
    fn type_id() -> CFTypeID;
}
