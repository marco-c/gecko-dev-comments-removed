

use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

impl CFStringTokenizer {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFStringTokenizerCopyBestStringLanguage")]
    #[inline]
    pub fn best_string_language(string: &CFString, range: CFRange) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringTokenizerCopyBestStringLanguage(
                string: &CFString,
                range: CFRange,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFStringTokenizerCopyBestStringLanguage(string, range) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}


#[doc(alias = "CFStringTokenizerRef")]
#[repr(C)]
pub struct CFStringTokenizer {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFStringTokenizer {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFStringTokenizer"> for CFStringTokenizer {}
);






pub const kCFStringTokenizerUnitWord: CFOptionFlags = 0;





pub const kCFStringTokenizerUnitSentence: CFOptionFlags = 1;





pub const kCFStringTokenizerUnitParagraph: CFOptionFlags = 2;





pub const kCFStringTokenizerUnitLineBreak: CFOptionFlags = 3;





pub const kCFStringTokenizerUnitWordBoundary: CFOptionFlags = 4;







pub const kCFStringTokenizerAttributeLatinTranscription: CFOptionFlags = 1 << 16;







pub const kCFStringTokenizerAttributeLanguage: CFOptionFlags = 1 << 17;







#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFStringTokenizerTokenType(pub CFOptionFlags);
bitflags::bitflags! {
    impl CFStringTokenizerTokenType: CFOptionFlags {
        #[doc(alias = "kCFStringTokenizerTokenNone")]
        const None = 0;
        #[doc(alias = "kCFStringTokenizerTokenNormal")]
        const Normal = 1<<0;
/// Compound token which may contain subtokens but with no derived subtokens.
/// Its subtokens can be obtained by calling CFStringTokenizerGetCurrentSubTokens.
        #[doc(alias = "kCFStringTokenizerTokenHasSubTokensMask")]
        const HasSubTokensMask = 1<<1;
/// Compound token which may contain derived subtokens.
/// Its subtokens and derived subtokens can be obtained by calling
/// CFStringTokenizerGetCurrentSubTokens.
        #[doc(alias = "kCFStringTokenizerTokenHasDerivedSubTokensMask")]
        const HasDerivedSubTokensMask = 1<<2;
/// Compound token which may contain derived subtokens.
/// Its subtokens and derived subtokens can be obtained by calling
/// CFStringTokenizerGetCurrentSubTokens.
        #[doc(alias = "kCFStringTokenizerTokenHasHasNumbersMask")]
        const HasHasNumbersMask = 1<<3;
/// Compound token which may contain derived subtokens.
/// Its subtokens and derived subtokens can be obtained by calling
/// CFStringTokenizerGetCurrentSubTokens.
        #[doc(alias = "kCFStringTokenizerTokenHasNonLettersMask")]
        const HasNonLettersMask = 1<<4;
/// Compound token which may contain derived subtokens.
/// Its subtokens and derived subtokens can be obtained by calling
/// CFStringTokenizerGetCurrentSubTokens.
        #[doc(alias = "kCFStringTokenizerTokenIsCJWordMask")]
        const IsCJWordMask = 1<<5;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFStringTokenizerTokenType {
    const ENCODING: Encoding = CFOptionFlags::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFStringTokenizerTokenType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl ConcreteType for CFStringTokenizer {
    
    
    
    #[doc(alias = "CFStringTokenizerGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFStringTokenizerGetTypeID() -> CFTypeID;
        }
        unsafe { CFStringTokenizerGetTypeID() }
    }
}

impl CFStringTokenizer {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFStringTokenizerCreate")]
    #[cfg(feature = "CFLocale")]
    #[inline]
    pub unsafe fn new(
        alloc: Option<&CFAllocator>,
        string: Option<&CFString>,
        range: CFRange,
        options: CFOptionFlags,
        locale: Option<&CFLocale>,
    ) -> Option<CFRetained<CFStringTokenizer>> {
        extern "C-unwind" {
            fn CFStringTokenizerCreate(
                alloc: Option<&CFAllocator>,
                string: Option<&CFString>,
                range: CFRange,
                options: CFOptionFlags,
                locale: Option<&CFLocale>,
            ) -> Option<NonNull<CFStringTokenizer>>;
        }
        let ret = unsafe { CFStringTokenizerCreate(alloc, string, range, options, locale) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFStringTokenizerSetString")]
    #[inline]
    pub unsafe fn set_string(&self, string: Option<&CFString>, range: CFRange) {
        extern "C-unwind" {
            fn CFStringTokenizerSetString(
                tokenizer: &CFStringTokenizer,
                string: Option<&CFString>,
                range: CFRange,
            );
        }
        unsafe { CFStringTokenizerSetString(self, string, range) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFStringTokenizerGoToTokenAtIndex")]
    #[inline]
    pub fn go_to_token_at_index(&self, index: CFIndex) -> CFStringTokenizerTokenType {
        extern "C-unwind" {
            fn CFStringTokenizerGoToTokenAtIndex(
                tokenizer: &CFStringTokenizer,
                index: CFIndex,
            ) -> CFStringTokenizerTokenType;
        }
        unsafe { CFStringTokenizerGoToTokenAtIndex(self, index) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFStringTokenizerAdvanceToNextToken")]
    #[inline]
    pub fn advance_to_next_token(&self) -> CFStringTokenizerTokenType {
        extern "C-unwind" {
            fn CFStringTokenizerAdvanceToNextToken(
                tokenizer: &CFStringTokenizer,
            ) -> CFStringTokenizerTokenType;
        }
        unsafe { CFStringTokenizerAdvanceToNextToken(self) }
    }

    
    
    
    
    
    
    #[doc(alias = "CFStringTokenizerGetCurrentTokenRange")]
    #[inline]
    pub fn current_token_range(&self) -> CFRange {
        extern "C-unwind" {
            fn CFStringTokenizerGetCurrentTokenRange(tokenizer: &CFStringTokenizer) -> CFRange;
        }
        unsafe { CFStringTokenizerGetCurrentTokenRange(self) }
    }

    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFStringTokenizerCopyCurrentTokenAttribute")]
    #[inline]
    pub fn current_token_attribute(&self, attribute: CFOptionFlags) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn CFStringTokenizerCopyCurrentTokenAttribute(
                tokenizer: &CFStringTokenizer,
                attribute: CFOptionFlags,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { CFStringTokenizerCopyCurrentTokenAttribute(self, attribute) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFStringTokenizerGetCurrentSubTokens")]
    #[cfg(feature = "CFArray")]
    #[inline]
    pub unsafe fn current_sub_tokens(
        &self,
        ranges: *mut CFRange,
        max_range_length: CFIndex,
        derived_sub_tokens: Option<&CFMutableArray>,
    ) -> CFIndex {
        extern "C-unwind" {
            fn CFStringTokenizerGetCurrentSubTokens(
                tokenizer: &CFStringTokenizer,
                ranges: *mut CFRange,
                max_range_length: CFIndex,
                derived_sub_tokens: Option<&CFMutableArray>,
            ) -> CFIndex;
        }
        unsafe {
            CFStringTokenizerGetCurrentSubTokens(self, ranges, max_range_length, derived_sub_tokens)
        }
    }
}

#[deprecated = "renamed to `CFStringTokenizer::best_string_language`"]
#[inline]
pub extern "C-unwind" fn CFStringTokenizerCopyBestStringLanguage(
    string: &CFString,
    range: CFRange,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringTokenizerCopyBestStringLanguage(
            string: &CFString,
            range: CFRange,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFStringTokenizerCopyBestStringLanguage(string, range) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFLocale")]
#[deprecated = "renamed to `CFStringTokenizer::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringTokenizerCreate(
    alloc: Option<&CFAllocator>,
    string: Option<&CFString>,
    range: CFRange,
    options: CFOptionFlags,
    locale: Option<&CFLocale>,
) -> Option<CFRetained<CFStringTokenizer>> {
    extern "C-unwind" {
        fn CFStringTokenizerCreate(
            alloc: Option<&CFAllocator>,
            string: Option<&CFString>,
            range: CFRange,
            options: CFOptionFlags,
            locale: Option<&CFLocale>,
        ) -> Option<NonNull<CFStringTokenizer>>;
    }
    let ret = unsafe { CFStringTokenizerCreate(alloc, string, range, options, locale) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFStringTokenizer::set_string`"]
    pub fn CFStringTokenizerSetString(
        tokenizer: &CFStringTokenizer,
        string: Option<&CFString>,
        range: CFRange,
    );
}

#[deprecated = "renamed to `CFStringTokenizer::go_to_token_at_index`"]
#[inline]
pub extern "C-unwind" fn CFStringTokenizerGoToTokenAtIndex(
    tokenizer: &CFStringTokenizer,
    index: CFIndex,
) -> CFStringTokenizerTokenType {
    extern "C-unwind" {
        fn CFStringTokenizerGoToTokenAtIndex(
            tokenizer: &CFStringTokenizer,
            index: CFIndex,
        ) -> CFStringTokenizerTokenType;
    }
    unsafe { CFStringTokenizerGoToTokenAtIndex(tokenizer, index) }
}

#[deprecated = "renamed to `CFStringTokenizer::advance_to_next_token`"]
#[inline]
pub extern "C-unwind" fn CFStringTokenizerAdvanceToNextToken(
    tokenizer: &CFStringTokenizer,
) -> CFStringTokenizerTokenType {
    extern "C-unwind" {
        fn CFStringTokenizerAdvanceToNextToken(
            tokenizer: &CFStringTokenizer,
        ) -> CFStringTokenizerTokenType;
    }
    unsafe { CFStringTokenizerAdvanceToNextToken(tokenizer) }
}

#[deprecated = "renamed to `CFStringTokenizer::current_token_range`"]
#[inline]
pub extern "C-unwind" fn CFStringTokenizerGetCurrentTokenRange(
    tokenizer: &CFStringTokenizer,
) -> CFRange {
    extern "C-unwind" {
        fn CFStringTokenizerGetCurrentTokenRange(tokenizer: &CFStringTokenizer) -> CFRange;
    }
    unsafe { CFStringTokenizerGetCurrentTokenRange(tokenizer) }
}

#[deprecated = "renamed to `CFStringTokenizer::current_token_attribute`"]
#[inline]
pub extern "C-unwind" fn CFStringTokenizerCopyCurrentTokenAttribute(
    tokenizer: &CFStringTokenizer,
    attribute: CFOptionFlags,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn CFStringTokenizerCopyCurrentTokenAttribute(
            tokenizer: &CFStringTokenizer,
            attribute: CFOptionFlags,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { CFStringTokenizerCopyCurrentTokenAttribute(tokenizer, attribute) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "CFArray")]
    #[deprecated = "renamed to `CFStringTokenizer::current_sub_tokens`"]
    pub fn CFStringTokenizerGetCurrentSubTokens(
        tokenizer: &CFStringTokenizer,
        ranges: *mut CFRange,
        max_range_length: CFIndex,
        derived_sub_tokens: Option<&CFMutableArray>,
    ) -> CFIndex;
}
