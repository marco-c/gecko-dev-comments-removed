

use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;


#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFBinaryHeapCompareContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: Option<unsafe extern "C-unwind" fn(*const c_void) -> *const c_void>,
    pub release: Option<unsafe extern "C-unwind" fn(*const c_void)>,
    pub copyDescription: Option<unsafe extern "C-unwind" fn(*const c_void) -> *const CFString>,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFBinaryHeapCompareContext {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*const c_void) -> *const c_void>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*const c_void)>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*const c_void) -> *const CFString>>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFBinaryHeapCompareContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}























#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFBinaryHeapCallBacks {
    pub version: CFIndex,
    pub retain:
        Option<unsafe extern "C-unwind" fn(*const CFAllocator, *const c_void) -> *const c_void>,
    pub release: Option<unsafe extern "C-unwind" fn(*const CFAllocator, *const c_void)>,
    pub copyDescription: Option<unsafe extern "C-unwind" fn(*const c_void) -> *const CFString>,
    pub compare: Option<
        unsafe extern "C-unwind" fn(
            *const c_void,
            *const c_void,
            *mut c_void,
        ) -> CFComparisonResult,
    >,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFBinaryHeapCallBacks {
    const ENCODING: Encoding =
        Encoding::Struct(
            "?",
            &[
                <CFIndex>::ENCODING,
                <Option<
                    unsafe extern "C-unwind" fn(*const CFAllocator, *const c_void) -> *const c_void,
                >>::ENCODING,
                <Option<unsafe extern "C-unwind" fn(*const CFAllocator, *const c_void)>>::ENCODING,
                <Option<unsafe extern "C-unwind" fn(*const c_void) -> *const CFString>>::ENCODING,
                <Option<
                    unsafe extern "C-unwind" fn(
                        *const c_void,
                        *const c_void,
                        *mut c_void,
                    ) -> CFComparisonResult,
                >>::ENCODING,
            ],
        );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFBinaryHeapCallBacks {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    
    
    
    
    
    pub static kCFStringBinaryHeapCallBacks: CFBinaryHeapCallBacks;
}










pub type CFBinaryHeapApplierFunction =
    Option<unsafe extern "C-unwind" fn(*const c_void, *mut c_void)>;




#[doc(alias = "CFBinaryHeapRef")]
#[repr(C)]
pub struct CFBinaryHeap<T: ?Sized = Opaque> {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
    _generics: PhantomData<(*mut T,)>,
}

cf_type!(
    unsafe impl<T: ?Sized> CFBinaryHeap<T> {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl<T: ?Sized> RefEncode<"__CFBinaryHeap"> for CFBinaryHeap<T> {}
);

impl<T: ?Sized> CFBinaryHeap<T> {
    
    
    
    
    
    #[inline]
    pub unsafe fn cast_unchecked<NewT: ?Sized>(&self) -> &CFBinaryHeap<NewT> {
        unsafe { &*((self as *const Self).cast()) }
    }

    
    #[inline]
    pub fn as_opaque(&self) -> &CFBinaryHeap {
        unsafe { self.cast_unchecked() }
    }
}

unsafe impl ConcreteType for CFBinaryHeap {
    
    #[doc(alias = "CFBinaryHeapGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFBinaryHeapGetTypeID() -> CFTypeID;
        }
        unsafe { CFBinaryHeapGetTypeID() }
    }
}

impl CFBinaryHeap {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFBinaryHeapCreate")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        capacity: CFIndex,
        call_backs: *const CFBinaryHeapCallBacks,
        compare_context: *const CFBinaryHeapCompareContext,
    ) -> Option<CFRetained<CFBinaryHeap>> {
        extern "C-unwind" {
            fn CFBinaryHeapCreate(
                allocator: Option<&CFAllocator>,
                capacity: CFIndex,
                call_backs: *const CFBinaryHeapCallBacks,
                compare_context: *const CFBinaryHeapCompareContext,
            ) -> Option<NonNull<CFBinaryHeap>>;
        }
        let ret = unsafe { CFBinaryHeapCreate(allocator, capacity, call_backs, compare_context) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFBinaryHeapCreateCopy")]
    #[inline]
    pub unsafe fn new_copy(
        allocator: Option<&CFAllocator>,
        capacity: CFIndex,
        heap: Option<&CFBinaryHeap>,
    ) -> Option<CFRetained<CFBinaryHeap>> {
        extern "C-unwind" {
            fn CFBinaryHeapCreateCopy(
                allocator: Option<&CFAllocator>,
                capacity: CFIndex,
                heap: Option<&CFBinaryHeap>,
            ) -> Option<NonNull<CFBinaryHeap>>;
        }
        let ret = unsafe { CFBinaryHeapCreateCopy(allocator, capacity, heap) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFBinaryHeapGetCount")]
    #[inline]
    pub unsafe fn count(&self) -> CFIndex {
        extern "C-unwind" {
            fn CFBinaryHeapGetCount(heap: &CFBinaryHeap) -> CFIndex;
        }
        unsafe { CFBinaryHeapGetCount(self) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFBinaryHeapGetCountOfValue")]
    #[inline]
    pub unsafe fn count_of_value(&self, value: *const c_void) -> CFIndex {
        extern "C-unwind" {
            fn CFBinaryHeapGetCountOfValue(heap: &CFBinaryHeap, value: *const c_void) -> CFIndex;
        }
        unsafe { CFBinaryHeapGetCountOfValue(self, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFBinaryHeapContainsValue")]
    #[inline]
    pub unsafe fn contains_value(&self, value: *const c_void) -> bool {
        extern "C-unwind" {
            fn CFBinaryHeapContainsValue(heap: &CFBinaryHeap, value: *const c_void) -> Boolean;
        }
        let ret = unsafe { CFBinaryHeapContainsValue(self, value) };
        ret != 0
    }

    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFBinaryHeapGetMinimum")]
    #[inline]
    pub unsafe fn minimum(&self) -> *const c_void {
        extern "C-unwind" {
            fn CFBinaryHeapGetMinimum(heap: &CFBinaryHeap) -> *const c_void;
        }
        unsafe { CFBinaryHeapGetMinimum(self) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFBinaryHeapGetMinimumIfPresent")]
    #[inline]
    pub unsafe fn minimum_if_present(&self, value: *mut *const c_void) -> bool {
        extern "C-unwind" {
            fn CFBinaryHeapGetMinimumIfPresent(
                heap: &CFBinaryHeap,
                value: *mut *const c_void,
            ) -> Boolean;
        }
        let ret = unsafe { CFBinaryHeapGetMinimumIfPresent(self, value) };
        ret != 0
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFBinaryHeapGetValues")]
    #[inline]
    pub unsafe fn values(&self, values: *mut *const c_void) {
        extern "C-unwind" {
            fn CFBinaryHeapGetValues(heap: &CFBinaryHeap, values: *mut *const c_void);
        }
        unsafe { CFBinaryHeapGetValues(self, values) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFBinaryHeapApplyFunction")]
    #[inline]
    pub unsafe fn apply_function(
        &self,
        applier: CFBinaryHeapApplierFunction,
        context: *mut c_void,
    ) {
        extern "C-unwind" {
            fn CFBinaryHeapApplyFunction(
                heap: &CFBinaryHeap,
                applier: CFBinaryHeapApplierFunction,
                context: *mut c_void,
            );
        }
        unsafe { CFBinaryHeapApplyFunction(self, applier, context) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFBinaryHeapAddValue")]
    #[inline]
    pub unsafe fn add_value(&self, value: *const c_void) {
        extern "C-unwind" {
            fn CFBinaryHeapAddValue(heap: &CFBinaryHeap, value: *const c_void);
        }
        unsafe { CFBinaryHeapAddValue(self, value) }
    }

    
    
    
    
    
    
    
    
    #[doc(alias = "CFBinaryHeapRemoveMinimumValue")]
    #[inline]
    pub unsafe fn remove_minimum_value(&self) {
        extern "C-unwind" {
            fn CFBinaryHeapRemoveMinimumValue(heap: &CFBinaryHeap);
        }
        unsafe { CFBinaryHeapRemoveMinimumValue(self) }
    }

    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFBinaryHeapRemoveAllValues")]
    #[inline]
    pub unsafe fn remove_all_values(&self) {
        extern "C-unwind" {
            fn CFBinaryHeapRemoveAllValues(heap: &CFBinaryHeap);
        }
        unsafe { CFBinaryHeapRemoveAllValues(self) }
    }
}

#[deprecated = "renamed to `CFBinaryHeap::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFBinaryHeapCreate(
    allocator: Option<&CFAllocator>,
    capacity: CFIndex,
    call_backs: *const CFBinaryHeapCallBacks,
    compare_context: *const CFBinaryHeapCompareContext,
) -> Option<CFRetained<CFBinaryHeap>> {
    extern "C-unwind" {
        fn CFBinaryHeapCreate(
            allocator: Option<&CFAllocator>,
            capacity: CFIndex,
            call_backs: *const CFBinaryHeapCallBacks,
            compare_context: *const CFBinaryHeapCompareContext,
        ) -> Option<NonNull<CFBinaryHeap>>;
    }
    let ret = unsafe { CFBinaryHeapCreate(allocator, capacity, call_backs, compare_context) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFBinaryHeap::new_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFBinaryHeapCreateCopy(
    allocator: Option<&CFAllocator>,
    capacity: CFIndex,
    heap: Option<&CFBinaryHeap>,
) -> Option<CFRetained<CFBinaryHeap>> {
    extern "C-unwind" {
        fn CFBinaryHeapCreateCopy(
            allocator: Option<&CFAllocator>,
            capacity: CFIndex,
            heap: Option<&CFBinaryHeap>,
        ) -> Option<NonNull<CFBinaryHeap>>;
    }
    let ret = unsafe { CFBinaryHeapCreateCopy(allocator, capacity, heap) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFBinaryHeap::count`"]
    pub fn CFBinaryHeapGetCount(heap: &CFBinaryHeap) -> CFIndex;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFBinaryHeap::count_of_value`"]
    pub fn CFBinaryHeapGetCountOfValue(heap: &CFBinaryHeap, value: *const c_void) -> CFIndex;
}

#[deprecated = "renamed to `CFBinaryHeap::contains_value`"]
#[inline]
pub unsafe extern "C-unwind" fn CFBinaryHeapContainsValue(
    heap: &CFBinaryHeap,
    value: *const c_void,
) -> bool {
    extern "C-unwind" {
        fn CFBinaryHeapContainsValue(heap: &CFBinaryHeap, value: *const c_void) -> Boolean;
    }
    let ret = unsafe { CFBinaryHeapContainsValue(heap, value) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFBinaryHeap::minimum`"]
    pub fn CFBinaryHeapGetMinimum(heap: &CFBinaryHeap) -> *const c_void;
}

#[deprecated = "renamed to `CFBinaryHeap::minimum_if_present`"]
#[inline]
pub unsafe extern "C-unwind" fn CFBinaryHeapGetMinimumIfPresent(
    heap: &CFBinaryHeap,
    value: *mut *const c_void,
) -> bool {
    extern "C-unwind" {
        fn CFBinaryHeapGetMinimumIfPresent(
            heap: &CFBinaryHeap,
            value: *mut *const c_void,
        ) -> Boolean;
    }
    let ret = unsafe { CFBinaryHeapGetMinimumIfPresent(heap, value) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFBinaryHeap::values`"]
    pub fn CFBinaryHeapGetValues(heap: &CFBinaryHeap, values: *mut *const c_void);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFBinaryHeap::apply_function`"]
    pub fn CFBinaryHeapApplyFunction(
        heap: &CFBinaryHeap,
        applier: CFBinaryHeapApplierFunction,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFBinaryHeap::add_value`"]
    pub fn CFBinaryHeapAddValue(heap: &CFBinaryHeap, value: *const c_void);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFBinaryHeap::remove_minimum_value`"]
    pub fn CFBinaryHeapRemoveMinimumValue(heap: &CFBinaryHeap);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFBinaryHeap::remove_all_values`"]
    pub fn CFBinaryHeapRemoveAllValues(heap: &CFBinaryHeap);
}
