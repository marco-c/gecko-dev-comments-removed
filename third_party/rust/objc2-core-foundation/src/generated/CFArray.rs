

use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;






















pub type CFArrayRetainCallBack =
    Option<unsafe extern "C-unwind" fn(*const CFAllocator, *const c_void) -> *const c_void>;


pub type CFArrayReleaseCallBack =
    Option<unsafe extern "C-unwind" fn(*const CFAllocator, *const c_void)>;


pub type CFArrayCopyDescriptionCallBack =
    Option<unsafe extern "C-unwind" fn(*const c_void) -> *const CFString>;


pub type CFArrayEqualCallBack =
    Option<unsafe extern "C-unwind" fn(*const c_void, *const c_void) -> Boolean>;


#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFArrayCallBacks {
    pub version: CFIndex,
    pub retain: CFArrayRetainCallBack,
    pub release: CFArrayReleaseCallBack,
    pub copyDescription: CFArrayCopyDescriptionCallBack,
    pub equal: CFArrayEqualCallBack,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFArrayCallBacks {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <CFArrayRetainCallBack>::ENCODING,
            <CFArrayReleaseCallBack>::ENCODING,
            <CFArrayCopyDescriptionCallBack>::ENCODING,
            <CFArrayEqualCallBack>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFArrayCallBacks {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    
    
    
    
    pub static kCFTypeArrayCallBacks: CFArrayCallBacks;
}










pub type CFArrayApplierFunction = Option<unsafe extern "C-unwind" fn(*const c_void, *mut c_void)>;






#[doc(alias = "CFArrayRef")]
#[repr(C)]
pub struct CFArray<T: ?Sized = Opaque> {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
    _generics: PhantomData<(*mut T,)>,
}

cf_type!(
    unsafe impl<T: ?Sized> CFArray<T> {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl<T: ?Sized> RefEncode<"__CFArray"> for CFArray<T> {}
);

impl<T: ?Sized> CFArray<T> {
    
    
    
    
    
    #[inline]
    pub unsafe fn cast_unchecked<NewT: ?Sized>(&self) -> &CFArray<NewT> {
        unsafe { &*((self as *const Self).cast()) }
    }

    
    #[inline]
    pub fn as_opaque(&self) -> &CFArray {
        unsafe { self.cast_unchecked() }
    }
}






#[doc(alias = "CFMutableArrayRef")]
#[repr(C)]
pub struct CFMutableArray<T: ?Sized = Opaque> {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
    _generics: PhantomData<(*mut T,)>,
}

cf_type!(
    unsafe impl<T: ?Sized> CFMutableArray<T>: CFArray<T> {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl<T: ?Sized> RefEncode<"__CFArray"> for CFMutableArray<T> {}
);

impl<T: ?Sized> CFMutableArray<T> {
    
    
    
    
    
    #[inline]
    pub unsafe fn cast_unchecked<NewT: ?Sized>(&self) -> &CFMutableArray<NewT> {
        unsafe { &*((self as *const Self).cast()) }
    }

    
    #[inline]
    pub fn as_opaque(&self) -> &CFMutableArray {
        unsafe { self.cast_unchecked() }
    }
}

unsafe impl ConcreteType for CFArray {
    
    #[doc(alias = "CFArrayGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFArrayGetTypeID() -> CFTypeID;
        }
        unsafe { CFArrayGetTypeID() }
    }
}

impl CFArray {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayCreate")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        values: *mut *const c_void,
        num_values: CFIndex,
        call_backs: *const CFArrayCallBacks,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CFArrayCreate(
                allocator: Option<&CFAllocator>,
                values: *mut *const c_void,
                num_values: CFIndex,
                call_backs: *const CFArrayCallBacks,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CFArrayCreate(allocator, values, num_values, call_backs) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayCreateCopy")]
    #[inline]
    pub unsafe fn new_copy(
        allocator: Option<&CFAllocator>,
        the_array: Option<&CFArray>,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CFArrayCreateCopy(
                allocator: Option<&CFAllocator>,
                the_array: Option<&CFArray>,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CFArrayCreateCopy(allocator, the_array) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFMutableArray {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayCreateMutable")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        capacity: CFIndex,
        call_backs: *const CFArrayCallBacks,
    ) -> Option<CFRetained<CFMutableArray>> {
        extern "C-unwind" {
            fn CFArrayCreateMutable(
                allocator: Option<&CFAllocator>,
                capacity: CFIndex,
                call_backs: *const CFArrayCallBacks,
            ) -> Option<NonNull<CFMutableArray>>;
        }
        let ret = unsafe { CFArrayCreateMutable(allocator, capacity, call_backs) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayCreateMutableCopy")]
    #[inline]
    pub unsafe fn new_copy(
        allocator: Option<&CFAllocator>,
        capacity: CFIndex,
        the_array: Option<&CFArray>,
    ) -> Option<CFRetained<CFMutableArray>> {
        extern "C-unwind" {
            fn CFArrayCreateMutableCopy(
                allocator: Option<&CFAllocator>,
                capacity: CFIndex,
                the_array: Option<&CFArray>,
            ) -> Option<NonNull<CFMutableArray>>;
        }
        let ret = unsafe { CFArrayCreateMutableCopy(allocator, capacity, the_array) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFArray {
    
    
    
    
    
    
    #[doc(alias = "CFArrayGetCount")]
    #[inline]
    pub fn count(&self) -> CFIndex {
        extern "C-unwind" {
            fn CFArrayGetCount(the_array: &CFArray) -> CFIndex;
        }
        unsafe { CFArrayGetCount(self) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayGetCountOfValue")]
    #[inline]
    pub unsafe fn count_of_value(&self, range: CFRange, value: *const c_void) -> CFIndex {
        extern "C-unwind" {
            fn CFArrayGetCountOfValue(
                the_array: &CFArray,
                range: CFRange,
                value: *const c_void,
            ) -> CFIndex;
        }
        unsafe { CFArrayGetCountOfValue(self, range, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayContainsValue")]
    #[inline]
    pub unsafe fn contains_value(&self, range: CFRange, value: *const c_void) -> bool {
        extern "C-unwind" {
            fn CFArrayContainsValue(
                the_array: &CFArray,
                range: CFRange,
                value: *const c_void,
            ) -> Boolean;
        }
        let ret = unsafe { CFArrayContainsValue(self, range, value) };
        ret != 0
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayGetValueAtIndex")]
    #[inline]
    pub unsafe fn value_at_index(&self, idx: CFIndex) -> *const c_void {
        extern "C-unwind" {
            fn CFArrayGetValueAtIndex(the_array: &CFArray, idx: CFIndex) -> *const c_void;
        }
        unsafe { CFArrayGetValueAtIndex(self, idx) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayGetValues")]
    #[inline]
    pub unsafe fn values(&self, range: CFRange, values: *mut *const c_void) {
        extern "C-unwind" {
            fn CFArrayGetValues(the_array: &CFArray, range: CFRange, values: *mut *const c_void);
        }
        unsafe { CFArrayGetValues(self, range, values) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayApplyFunction")]
    #[inline]
    pub unsafe fn apply_function(
        &self,
        range: CFRange,
        applier: CFArrayApplierFunction,
        context: *mut c_void,
    ) {
        extern "C-unwind" {
            fn CFArrayApplyFunction(
                the_array: &CFArray,
                range: CFRange,
                applier: CFArrayApplierFunction,
                context: *mut c_void,
            );
        }
        unsafe { CFArrayApplyFunction(self, range, applier, context) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayGetFirstIndexOfValue")]
    #[inline]
    pub unsafe fn first_index_of_value(&self, range: CFRange, value: *const c_void) -> CFIndex {
        extern "C-unwind" {
            fn CFArrayGetFirstIndexOfValue(
                the_array: &CFArray,
                range: CFRange,
                value: *const c_void,
            ) -> CFIndex;
        }
        unsafe { CFArrayGetFirstIndexOfValue(self, range, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayGetLastIndexOfValue")]
    #[inline]
    pub unsafe fn last_index_of_value(&self, range: CFRange, value: *const c_void) -> CFIndex {
        extern "C-unwind" {
            fn CFArrayGetLastIndexOfValue(
                the_array: &CFArray,
                range: CFRange,
                value: *const c_void,
            ) -> CFIndex;
        }
        unsafe { CFArrayGetLastIndexOfValue(self, range, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayBSearchValues")]
    #[inline]
    pub unsafe fn b_search_values(
        &self,
        range: CFRange,
        value: *const c_void,
        comparator: CFComparatorFunction,
        context: *mut c_void,
    ) -> CFIndex {
        extern "C-unwind" {
            fn CFArrayBSearchValues(
                the_array: &CFArray,
                range: CFRange,
                value: *const c_void,
                comparator: CFComparatorFunction,
                context: *mut c_void,
            ) -> CFIndex;
        }
        unsafe { CFArrayBSearchValues(self, range, value, comparator, context) }
    }
}

impl CFMutableArray {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayAppendValue")]
    #[inline]
    pub unsafe fn append_value(the_array: Option<&CFMutableArray>, value: *const c_void) {
        extern "C-unwind" {
            fn CFArrayAppendValue(the_array: Option<&CFMutableArray>, value: *const c_void);
        }
        unsafe { CFArrayAppendValue(the_array, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayInsertValueAtIndex")]
    #[inline]
    pub unsafe fn insert_value_at_index(
        the_array: Option<&CFMutableArray>,
        idx: CFIndex,
        value: *const c_void,
    ) {
        extern "C-unwind" {
            fn CFArrayInsertValueAtIndex(
                the_array: Option<&CFMutableArray>,
                idx: CFIndex,
                value: *const c_void,
            );
        }
        unsafe { CFArrayInsertValueAtIndex(the_array, idx, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArraySetValueAtIndex")]
    #[inline]
    pub unsafe fn set_value_at_index(
        the_array: Option<&CFMutableArray>,
        idx: CFIndex,
        value: *const c_void,
    ) {
        extern "C-unwind" {
            fn CFArraySetValueAtIndex(
                the_array: Option<&CFMutableArray>,
                idx: CFIndex,
                value: *const c_void,
            );
        }
        unsafe { CFArraySetValueAtIndex(the_array, idx, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayRemoveValueAtIndex")]
    #[inline]
    pub unsafe fn remove_value_at_index(the_array: Option<&CFMutableArray>, idx: CFIndex) {
        extern "C-unwind" {
            fn CFArrayRemoveValueAtIndex(the_array: Option<&CFMutableArray>, idx: CFIndex);
        }
        unsafe { CFArrayRemoveValueAtIndex(the_array, idx) }
    }

    
    
    
    
    
    #[doc(alias = "CFArrayRemoveAllValues")]
    #[inline]
    pub fn remove_all_values(the_array: Option<&CFMutableArray>) {
        extern "C-unwind" {
            fn CFArrayRemoveAllValues(the_array: Option<&CFMutableArray>);
        }
        unsafe { CFArrayRemoveAllValues(the_array) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayReplaceValues")]
    #[inline]
    pub unsafe fn replace_values(
        the_array: Option<&CFMutableArray>,
        range: CFRange,
        new_values: *mut *const c_void,
        new_count: CFIndex,
    ) {
        extern "C-unwind" {
            fn CFArrayReplaceValues(
                the_array: Option<&CFMutableArray>,
                range: CFRange,
                new_values: *mut *const c_void,
                new_count: CFIndex,
            );
        }
        unsafe { CFArrayReplaceValues(the_array, range, new_values, new_count) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayExchangeValuesAtIndices")]
    #[inline]
    pub unsafe fn exchange_values_at_indices(
        the_array: Option<&CFMutableArray>,
        idx1: CFIndex,
        idx2: CFIndex,
    ) {
        extern "C-unwind" {
            fn CFArrayExchangeValuesAtIndices(
                the_array: Option<&CFMutableArray>,
                idx1: CFIndex,
                idx2: CFIndex,
            );
        }
        unsafe { CFArrayExchangeValuesAtIndices(the_array, idx1, idx2) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArraySortValues")]
    #[inline]
    pub unsafe fn sort_values(
        the_array: Option<&CFMutableArray>,
        range: CFRange,
        comparator: CFComparatorFunction,
        context: *mut c_void,
    ) {
        extern "C-unwind" {
            fn CFArraySortValues(
                the_array: Option<&CFMutableArray>,
                range: CFRange,
                comparator: CFComparatorFunction,
                context: *mut c_void,
            );
        }
        unsafe { CFArraySortValues(the_array, range, comparator, context) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFArrayAppendArray")]
    #[inline]
    pub unsafe fn append_array(
        the_array: Option<&CFMutableArray>,
        other_array: Option<&CFArray>,
        other_range: CFRange,
    ) {
        extern "C-unwind" {
            fn CFArrayAppendArray(
                the_array: Option<&CFMutableArray>,
                other_array: Option<&CFArray>,
                other_range: CFRange,
            );
        }
        unsafe { CFArrayAppendArray(the_array, other_array, other_range) }
    }
}

#[deprecated = "renamed to `CFArray::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFArrayCreate(
    allocator: Option<&CFAllocator>,
    values: *mut *const c_void,
    num_values: CFIndex,
    call_backs: *const CFArrayCallBacks,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CFArrayCreate(
            allocator: Option<&CFAllocator>,
            values: *mut *const c_void,
            num_values: CFIndex,
            call_backs: *const CFArrayCallBacks,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CFArrayCreate(allocator, values, num_values, call_backs) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFArray::new_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFArrayCreateCopy(
    allocator: Option<&CFAllocator>,
    the_array: Option<&CFArray>,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CFArrayCreateCopy(
            allocator: Option<&CFAllocator>,
            the_array: Option<&CFArray>,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CFArrayCreateCopy(allocator, the_array) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFMutableArray::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFArrayCreateMutable(
    allocator: Option<&CFAllocator>,
    capacity: CFIndex,
    call_backs: *const CFArrayCallBacks,
) -> Option<CFRetained<CFMutableArray>> {
    extern "C-unwind" {
        fn CFArrayCreateMutable(
            allocator: Option<&CFAllocator>,
            capacity: CFIndex,
            call_backs: *const CFArrayCallBacks,
        ) -> Option<NonNull<CFMutableArray>>;
    }
    let ret = unsafe { CFArrayCreateMutable(allocator, capacity, call_backs) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFMutableArray::new_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFArrayCreateMutableCopy(
    allocator: Option<&CFAllocator>,
    capacity: CFIndex,
    the_array: Option<&CFArray>,
) -> Option<CFRetained<CFMutableArray>> {
    extern "C-unwind" {
        fn CFArrayCreateMutableCopy(
            allocator: Option<&CFAllocator>,
            capacity: CFIndex,
            the_array: Option<&CFArray>,
        ) -> Option<NonNull<CFMutableArray>>;
    }
    let ret = unsafe { CFArrayCreateMutableCopy(allocator, capacity, the_array) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFArray::count`"]
#[inline]
pub extern "C-unwind" fn CFArrayGetCount(the_array: &CFArray) -> CFIndex {
    extern "C-unwind" {
        fn CFArrayGetCount(the_array: &CFArray) -> CFIndex;
    }
    unsafe { CFArrayGetCount(the_array) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFArray::count_of_value`"]
    pub fn CFArrayGetCountOfValue(
        the_array: &CFArray,
        range: CFRange,
        value: *const c_void,
    ) -> CFIndex;
}

#[deprecated = "renamed to `CFArray::contains_value`"]
#[inline]
pub unsafe extern "C-unwind" fn CFArrayContainsValue(
    the_array: &CFArray,
    range: CFRange,
    value: *const c_void,
) -> bool {
    extern "C-unwind" {
        fn CFArrayContainsValue(
            the_array: &CFArray,
            range: CFRange,
            value: *const c_void,
        ) -> Boolean;
    }
    let ret = unsafe { CFArrayContainsValue(the_array, range, value) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFArray::value_at_index`"]
    pub fn CFArrayGetValueAtIndex(the_array: &CFArray, idx: CFIndex) -> *const c_void;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFArray::values`"]
    pub fn CFArrayGetValues(the_array: &CFArray, range: CFRange, values: *mut *const c_void);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFArray::apply_function`"]
    pub fn CFArrayApplyFunction(
        the_array: &CFArray,
        range: CFRange,
        applier: CFArrayApplierFunction,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFArray::first_index_of_value`"]
    pub fn CFArrayGetFirstIndexOfValue(
        the_array: &CFArray,
        range: CFRange,
        value: *const c_void,
    ) -> CFIndex;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFArray::last_index_of_value`"]
    pub fn CFArrayGetLastIndexOfValue(
        the_array: &CFArray,
        range: CFRange,
        value: *const c_void,
    ) -> CFIndex;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFArray::b_search_values`"]
    pub fn CFArrayBSearchValues(
        the_array: &CFArray,
        range: CFRange,
        value: *const c_void,
        comparator: CFComparatorFunction,
        context: *mut c_void,
    ) -> CFIndex;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableArray::append_value`"]
    pub fn CFArrayAppendValue(the_array: Option<&CFMutableArray>, value: *const c_void);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableArray::insert_value_at_index`"]
    pub fn CFArrayInsertValueAtIndex(
        the_array: Option<&CFMutableArray>,
        idx: CFIndex,
        value: *const c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableArray::set_value_at_index`"]
    pub fn CFArraySetValueAtIndex(
        the_array: Option<&CFMutableArray>,
        idx: CFIndex,
        value: *const c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableArray::remove_value_at_index`"]
    pub fn CFArrayRemoveValueAtIndex(the_array: Option<&CFMutableArray>, idx: CFIndex);
}

#[deprecated = "renamed to `CFMutableArray::remove_all_values`"]
#[inline]
pub extern "C-unwind" fn CFArrayRemoveAllValues(the_array: Option<&CFMutableArray>) {
    extern "C-unwind" {
        fn CFArrayRemoveAllValues(the_array: Option<&CFMutableArray>);
    }
    unsafe { CFArrayRemoveAllValues(the_array) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableArray::replace_values`"]
    pub fn CFArrayReplaceValues(
        the_array: Option<&CFMutableArray>,
        range: CFRange,
        new_values: *mut *const c_void,
        new_count: CFIndex,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableArray::exchange_values_at_indices`"]
    pub fn CFArrayExchangeValuesAtIndices(
        the_array: Option<&CFMutableArray>,
        idx1: CFIndex,
        idx2: CFIndex,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableArray::sort_values`"]
    pub fn CFArraySortValues(
        the_array: Option<&CFMutableArray>,
        range: CFRange,
        comparator: CFComparatorFunction,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableArray::append_array`"]
    pub fn CFArrayAppendArray(
        the_array: Option<&CFMutableArray>,
        other_array: Option<&CFArray>,
        other_range: CFRange,
    );
}
