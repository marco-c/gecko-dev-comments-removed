

use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;












pub type CFSetRetainCallBack =
    Option<unsafe extern "C-unwind" fn(*const CFAllocator, *const c_void) -> *const c_void>;








pub type CFSetReleaseCallBack =
    Option<unsafe extern "C-unwind" fn(*const CFAllocator, *const c_void)>;








pub type CFSetCopyDescriptionCallBack =
    Option<unsafe extern "C-unwind" fn(*const c_void) -> *const CFString>;










pub type CFSetEqualCallBack =
    Option<unsafe extern "C-unwind" fn(*const c_void, *const c_void) -> Boolean>;








pub type CFSetHashCallBack = Option<unsafe extern "C-unwind" fn(*const c_void) -> CFHashCode>;
























#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFSetCallBacks {
    pub version: CFIndex,
    pub retain: CFSetRetainCallBack,
    pub release: CFSetReleaseCallBack,
    pub copyDescription: CFSetCopyDescriptionCallBack,
    pub equal: CFSetEqualCallBack,
    pub hash: CFSetHashCallBack,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFSetCallBacks {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <CFSetRetainCallBack>::ENCODING,
            <CFSetReleaseCallBack>::ENCODING,
            <CFSetCopyDescriptionCallBack>::ENCODING,
            <CFSetEqualCallBack>::ENCODING,
            <CFSetHashCallBack>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFSetCallBacks {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    
    
    
    
    pub static kCFTypeSetCallBacks: CFSetCallBacks;
}

extern "C" {
    
    
    
    
    
    pub static kCFCopyStringSetCallBacks: CFSetCallBacks;
}










pub type CFSetApplierFunction = Option<unsafe extern "C-unwind" fn(*const c_void, *mut c_void)>;






#[doc(alias = "CFSetRef")]
#[repr(C)]
pub struct CFSet<T: ?Sized = Opaque> {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
    _generics: PhantomData<(*mut T,)>,
}

cf_type!(
    unsafe impl<T: ?Sized> CFSet<T> {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl<T: ?Sized> RefEncode<"__CFSet"> for CFSet<T> {}
);

impl<T: ?Sized> CFSet<T> {
    
    
    
    
    
    #[inline]
    pub unsafe fn cast_unchecked<NewT: ?Sized>(&self) -> &CFSet<NewT> {
        unsafe { &*((self as *const Self).cast()) }
    }

    
    #[inline]
    pub fn as_opaque(&self) -> &CFSet {
        unsafe { self.cast_unchecked() }
    }
}






#[doc(alias = "CFMutableSetRef")]
#[repr(C)]
pub struct CFMutableSet<T: ?Sized = Opaque> {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
    _generics: PhantomData<(*mut T,)>,
}

cf_type!(
    unsafe impl<T: ?Sized> CFMutableSet<T>: CFSet<T> {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl<T: ?Sized> RefEncode<"__CFSet"> for CFMutableSet<T> {}
);

impl<T: ?Sized> CFMutableSet<T> {
    
    
    
    
    
    #[inline]
    pub unsafe fn cast_unchecked<NewT: ?Sized>(&self) -> &CFMutableSet<NewT> {
        unsafe { &*((self as *const Self).cast()) }
    }

    
    #[inline]
    pub fn as_opaque(&self) -> &CFMutableSet {
        unsafe { self.cast_unchecked() }
    }
}

unsafe impl ConcreteType for CFSet {
    
    #[doc(alias = "CFSetGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFSetGetTypeID() -> CFTypeID;
        }
        unsafe { CFSetGetTypeID() }
    }
}

impl CFSet {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetCreate")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        values: *mut *const c_void,
        num_values: CFIndex,
        call_backs: *const CFSetCallBacks,
    ) -> Option<CFRetained<CFSet>> {
        extern "C-unwind" {
            fn CFSetCreate(
                allocator: Option<&CFAllocator>,
                values: *mut *const c_void,
                num_values: CFIndex,
                call_backs: *const CFSetCallBacks,
            ) -> Option<NonNull<CFSet>>;
        }
        let ret = unsafe { CFSetCreate(allocator, values, num_values, call_backs) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetCreateCopy")]
    #[inline]
    pub fn new_copy(
        allocator: Option<&CFAllocator>,
        the_set: Option<&CFSet>,
    ) -> Option<CFRetained<CFSet>> {
        extern "C-unwind" {
            fn CFSetCreateCopy(
                allocator: Option<&CFAllocator>,
                the_set: Option<&CFSet>,
            ) -> Option<NonNull<CFSet>>;
        }
        let ret = unsafe { CFSetCreateCopy(allocator, the_set) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFMutableSet {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetCreateMutable")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        capacity: CFIndex,
        call_backs: *const CFSetCallBacks,
    ) -> Option<CFRetained<CFMutableSet>> {
        extern "C-unwind" {
            fn CFSetCreateMutable(
                allocator: Option<&CFAllocator>,
                capacity: CFIndex,
                call_backs: *const CFSetCallBacks,
            ) -> Option<NonNull<CFMutableSet>>;
        }
        let ret = unsafe { CFSetCreateMutable(allocator, capacity, call_backs) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetCreateMutableCopy")]
    #[inline]
    pub unsafe fn new_copy(
        allocator: Option<&CFAllocator>,
        capacity: CFIndex,
        the_set: Option<&CFSet>,
    ) -> Option<CFRetained<CFMutableSet>> {
        extern "C-unwind" {
            fn CFSetCreateMutableCopy(
                allocator: Option<&CFAllocator>,
                capacity: CFIndex,
                the_set: Option<&CFSet>,
            ) -> Option<NonNull<CFMutableSet>>;
        }
        let ret = unsafe { CFSetCreateMutableCopy(allocator, capacity, the_set) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFSet {
    
    
    
    
    
    
    #[doc(alias = "CFSetGetCount")]
    #[inline]
    pub fn count(&self) -> CFIndex {
        extern "C-unwind" {
            fn CFSetGetCount(the_set: &CFSet) -> CFIndex;
        }
        unsafe { CFSetGetCount(self) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetGetCountOfValue")]
    #[inline]
    pub unsafe fn count_of_value(&self, value: *const c_void) -> CFIndex {
        extern "C-unwind" {
            fn CFSetGetCountOfValue(the_set: &CFSet, value: *const c_void) -> CFIndex;
        }
        unsafe { CFSetGetCountOfValue(self, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetContainsValue")]
    #[inline]
    pub unsafe fn contains_value(&self, value: *const c_void) -> bool {
        extern "C-unwind" {
            fn CFSetContainsValue(the_set: &CFSet, value: *const c_void) -> Boolean;
        }
        let ret = unsafe { CFSetContainsValue(self, value) };
        ret != 0
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetGetValue")]
    #[inline]
    pub unsafe fn value(&self, value: *const c_void) -> *const c_void {
        extern "C-unwind" {
            fn CFSetGetValue(the_set: &CFSet, value: *const c_void) -> *const c_void;
        }
        unsafe { CFSetGetValue(self, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetGetValueIfPresent")]
    #[inline]
    pub unsafe fn value_if_present(
        &self,
        candidate: *const c_void,
        value: *mut *const c_void,
    ) -> bool {
        extern "C-unwind" {
            fn CFSetGetValueIfPresent(
                the_set: &CFSet,
                candidate: *const c_void,
                value: *mut *const c_void,
            ) -> Boolean;
        }
        let ret = unsafe { CFSetGetValueIfPresent(self, candidate, value) };
        ret != 0
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetGetValues")]
    #[inline]
    pub unsafe fn values(&self, values: *mut *const c_void) {
        extern "C-unwind" {
            fn CFSetGetValues(the_set: &CFSet, values: *mut *const c_void);
        }
        unsafe { CFSetGetValues(self, values) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetApplyFunction")]
    #[inline]
    pub unsafe fn apply_function(&self, applier: CFSetApplierFunction, context: *mut c_void) {
        extern "C-unwind" {
            fn CFSetApplyFunction(
                the_set: &CFSet,
                applier: CFSetApplierFunction,
                context: *mut c_void,
            );
        }
        unsafe { CFSetApplyFunction(self, applier, context) }
    }
}

impl CFMutableSet {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetAddValue")]
    #[inline]
    pub unsafe fn add_value(the_set: Option<&CFMutableSet>, value: *const c_void) {
        extern "C-unwind" {
            fn CFSetAddValue(the_set: Option<&CFMutableSet>, value: *const c_void);
        }
        unsafe { CFSetAddValue(the_set, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetReplaceValue")]
    #[inline]
    pub unsafe fn replace_value(the_set: Option<&CFMutableSet>, value: *const c_void) {
        extern "C-unwind" {
            fn CFSetReplaceValue(the_set: Option<&CFMutableSet>, value: *const c_void);
        }
        unsafe { CFSetReplaceValue(the_set, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetSetValue")]
    #[inline]
    pub unsafe fn set_value(the_set: Option<&CFMutableSet>, value: *const c_void) {
        extern "C-unwind" {
            fn CFSetSetValue(the_set: Option<&CFMutableSet>, value: *const c_void);
        }
        unsafe { CFSetSetValue(the_set, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFSetRemoveValue")]
    #[inline]
    pub unsafe fn remove_value(the_set: Option<&CFMutableSet>, value: *const c_void) {
        extern "C-unwind" {
            fn CFSetRemoveValue(the_set: Option<&CFMutableSet>, value: *const c_void);
        }
        unsafe { CFSetRemoveValue(the_set, value) }
    }

    
    
    
    
    
    #[doc(alias = "CFSetRemoveAllValues")]
    #[inline]
    pub fn remove_all_values(the_set: Option<&CFMutableSet>) {
        extern "C-unwind" {
            fn CFSetRemoveAllValues(the_set: Option<&CFMutableSet>);
        }
        unsafe { CFSetRemoveAllValues(the_set) }
    }
}

#[deprecated = "renamed to `CFSet::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFSetCreate(
    allocator: Option<&CFAllocator>,
    values: *mut *const c_void,
    num_values: CFIndex,
    call_backs: *const CFSetCallBacks,
) -> Option<CFRetained<CFSet>> {
    extern "C-unwind" {
        fn CFSetCreate(
            allocator: Option<&CFAllocator>,
            values: *mut *const c_void,
            num_values: CFIndex,
            call_backs: *const CFSetCallBacks,
        ) -> Option<NonNull<CFSet>>;
    }
    let ret = unsafe { CFSetCreate(allocator, values, num_values, call_backs) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFSet::new_copy`"]
#[inline]
pub extern "C-unwind" fn CFSetCreateCopy(
    allocator: Option<&CFAllocator>,
    the_set: Option<&CFSet>,
) -> Option<CFRetained<CFSet>> {
    extern "C-unwind" {
        fn CFSetCreateCopy(
            allocator: Option<&CFAllocator>,
            the_set: Option<&CFSet>,
        ) -> Option<NonNull<CFSet>>;
    }
    let ret = unsafe { CFSetCreateCopy(allocator, the_set) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFMutableSet::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFSetCreateMutable(
    allocator: Option<&CFAllocator>,
    capacity: CFIndex,
    call_backs: *const CFSetCallBacks,
) -> Option<CFRetained<CFMutableSet>> {
    extern "C-unwind" {
        fn CFSetCreateMutable(
            allocator: Option<&CFAllocator>,
            capacity: CFIndex,
            call_backs: *const CFSetCallBacks,
        ) -> Option<NonNull<CFMutableSet>>;
    }
    let ret = unsafe { CFSetCreateMutable(allocator, capacity, call_backs) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFMutableSet::new_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFSetCreateMutableCopy(
    allocator: Option<&CFAllocator>,
    capacity: CFIndex,
    the_set: Option<&CFSet>,
) -> Option<CFRetained<CFMutableSet>> {
    extern "C-unwind" {
        fn CFSetCreateMutableCopy(
            allocator: Option<&CFAllocator>,
            capacity: CFIndex,
            the_set: Option<&CFSet>,
        ) -> Option<NonNull<CFMutableSet>>;
    }
    let ret = unsafe { CFSetCreateMutableCopy(allocator, capacity, the_set) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFSet::count`"]
#[inline]
pub extern "C-unwind" fn CFSetGetCount(the_set: &CFSet) -> CFIndex {
    extern "C-unwind" {
        fn CFSetGetCount(the_set: &CFSet) -> CFIndex;
    }
    unsafe { CFSetGetCount(the_set) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFSet::count_of_value`"]
    pub fn CFSetGetCountOfValue(the_set: &CFSet, value: *const c_void) -> CFIndex;
}

#[deprecated = "renamed to `CFSet::contains_value`"]
#[inline]
pub unsafe extern "C-unwind" fn CFSetContainsValue(the_set: &CFSet, value: *const c_void) -> bool {
    extern "C-unwind" {
        fn CFSetContainsValue(the_set: &CFSet, value: *const c_void) -> Boolean;
    }
    let ret = unsafe { CFSetContainsValue(the_set, value) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFSet::value`"]
    pub fn CFSetGetValue(the_set: &CFSet, value: *const c_void) -> *const c_void;
}

#[deprecated = "renamed to `CFSet::value_if_present`"]
#[inline]
pub unsafe extern "C-unwind" fn CFSetGetValueIfPresent(
    the_set: &CFSet,
    candidate: *const c_void,
    value: *mut *const c_void,
) -> bool {
    extern "C-unwind" {
        fn CFSetGetValueIfPresent(
            the_set: &CFSet,
            candidate: *const c_void,
            value: *mut *const c_void,
        ) -> Boolean;
    }
    let ret = unsafe { CFSetGetValueIfPresent(the_set, candidate, value) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFSet::values`"]
    pub fn CFSetGetValues(the_set: &CFSet, values: *mut *const c_void);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFSet::apply_function`"]
    pub fn CFSetApplyFunction(the_set: &CFSet, applier: CFSetApplierFunction, context: *mut c_void);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableSet::add_value`"]
    pub fn CFSetAddValue(the_set: Option<&CFMutableSet>, value: *const c_void);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableSet::replace_value`"]
    pub fn CFSetReplaceValue(the_set: Option<&CFMutableSet>, value: *const c_void);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableSet::set_value`"]
    pub fn CFSetSetValue(the_set: Option<&CFMutableSet>, value: *const c_void);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableSet::remove_value`"]
    pub fn CFSetRemoveValue(the_set: Option<&CFMutableSet>, value: *const c_void);
}

#[deprecated = "renamed to `CFMutableSet::remove_all_values`"]
#[inline]
pub extern "C-unwind" fn CFSetRemoveAllValues(the_set: Option<&CFMutableSet>) {
    extern "C-unwind" {
        fn CFSetRemoveAllValues(the_set: Option<&CFMutableSet>);
    }
    unsafe { CFSetRemoveAllValues(the_set) }
}
