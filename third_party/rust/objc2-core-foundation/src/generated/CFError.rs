

use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;



pub type CFErrorDomain = CFString;






#[doc(alias = "CFErrorRef")]
#[repr(C)]
pub struct CFError {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFError {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFError"> for CFError {}
);

unsafe impl ConcreteType for CFError {
    
    #[doc(alias = "CFErrorGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFErrorGetTypeID() -> CFTypeID;
        }
        unsafe { CFErrorGetTypeID() }
    }
}

extern "C" {
    
    pub static kCFErrorDomainPOSIX: Option<&'static CFErrorDomain>;
}

extern "C" {
    
    pub static kCFErrorDomainOSStatus: Option<&'static CFErrorDomain>;
}

extern "C" {
    
    pub static kCFErrorDomainMach: Option<&'static CFErrorDomain>;
}

extern "C" {
    
    pub static kCFErrorDomainCocoa: Option<&'static CFErrorDomain>;
}

extern "C" {
    
    pub static kCFErrorLocalizedDescriptionKey: Option<&'static CFString>;
}

extern "C" {
    
    pub static kCFErrorLocalizedFailureKey: Option<&'static CFString>;
}

extern "C" {
    
    pub static kCFErrorLocalizedFailureReasonKey: Option<&'static CFString>;
}

extern "C" {
    
    pub static kCFErrorLocalizedRecoverySuggestionKey: Option<&'static CFString>;
}

extern "C" {
    
    pub static kCFErrorDescriptionKey: Option<&'static CFString>;
}

extern "C" {
    
    pub static kCFErrorUnderlyingErrorKey: Option<&'static CFString>;
}

extern "C" {
    
    pub static kCFErrorURLKey: Option<&'static CFString>;
}

extern "C" {
    
    pub static kCFErrorFilePathKey: Option<&'static CFString>;
}

impl CFError {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFErrorCreate")]
    #[cfg(feature = "CFDictionary")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        domain: Option<&CFErrorDomain>,
        code: CFIndex,
        user_info: Option<&CFDictionary>,
    ) -> Option<CFRetained<CFError>> {
        extern "C-unwind" {
            fn CFErrorCreate(
                allocator: Option<&CFAllocator>,
                domain: Option<&CFErrorDomain>,
                code: CFIndex,
                user_info: Option<&CFDictionary>,
            ) -> Option<NonNull<CFError>>;
        }
        let ret = unsafe { CFErrorCreate(allocator, domain, code, user_info) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFErrorCreateWithUserInfoKeysAndValues")]
    #[inline]
    pub unsafe fn with_user_info_keys_and_values(
        allocator: Option<&CFAllocator>,
        domain: Option<&CFErrorDomain>,
        code: CFIndex,
        user_info_keys: *const *const c_void,
        user_info_values: *const *const c_void,
        num_user_info_values: CFIndex,
    ) -> Option<CFRetained<CFError>> {
        extern "C-unwind" {
            fn CFErrorCreateWithUserInfoKeysAndValues(
                allocator: Option<&CFAllocator>,
                domain: Option<&CFErrorDomain>,
                code: CFIndex,
                user_info_keys: *const *const c_void,
                user_info_values: *const *const c_void,
                num_user_info_values: CFIndex,
            ) -> Option<NonNull<CFError>>;
        }
        let ret = unsafe {
            CFErrorCreateWithUserInfoKeysAndValues(
                allocator,
                domain,
                code,
                user_info_keys,
                user_info_values,
                num_user_info_values,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    #[doc(alias = "CFErrorGetDomain")]
    #[inline]
    pub fn domain(&self) -> Option<CFRetained<CFErrorDomain>> {
        extern "C-unwind" {
            fn CFErrorGetDomain(err: &CFError) -> Option<NonNull<CFErrorDomain>>;
        }
        let ret = unsafe { CFErrorGetDomain(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    
    
    
    
    
    #[doc(alias = "CFErrorGetCode")]
    #[inline]
    pub fn code(&self) -> CFIndex {
        extern "C-unwind" {
            fn CFErrorGetCode(err: &CFError) -> CFIndex;
        }
        unsafe { CFErrorGetCode(self) }
    }

    
    
    
    
    
    
    
    #[doc(alias = "CFErrorCopyUserInfo")]
    #[cfg(feature = "CFDictionary")]
    #[inline]
    pub fn user_info(&self) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CFErrorCopyUserInfo(err: &CFError) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CFErrorCopyUserInfo(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFErrorCopyDescription")]
    #[inline]
    pub fn description(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFErrorCopyDescription(err: &CFError) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFErrorCopyDescription(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFErrorCopyFailureReason")]
    #[inline]
    pub fn failure_reason(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFErrorCopyFailureReason(err: &CFError) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFErrorCopyFailureReason(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFErrorCopyRecoverySuggestion")]
    #[inline]
    pub fn recovery_suggestion(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFErrorCopyRecoverySuggestion(err: &CFError) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFErrorCopyRecoverySuggestion(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

#[cfg(feature = "CFDictionary")]
#[deprecated = "renamed to `CFError::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFErrorCreate(
    allocator: Option<&CFAllocator>,
    domain: Option<&CFErrorDomain>,
    code: CFIndex,
    user_info: Option<&CFDictionary>,
) -> Option<CFRetained<CFError>> {
    extern "C-unwind" {
        fn CFErrorCreate(
            allocator: Option<&CFAllocator>,
            domain: Option<&CFErrorDomain>,
            code: CFIndex,
            user_info: Option<&CFDictionary>,
        ) -> Option<NonNull<CFError>>;
    }
    let ret = unsafe { CFErrorCreate(allocator, domain, code, user_info) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFError::with_user_info_keys_and_values`"]
#[inline]
pub unsafe extern "C-unwind" fn CFErrorCreateWithUserInfoKeysAndValues(
    allocator: Option<&CFAllocator>,
    domain: Option<&CFErrorDomain>,
    code: CFIndex,
    user_info_keys: *const *const c_void,
    user_info_values: *const *const c_void,
    num_user_info_values: CFIndex,
) -> Option<CFRetained<CFError>> {
    extern "C-unwind" {
        fn CFErrorCreateWithUserInfoKeysAndValues(
            allocator: Option<&CFAllocator>,
            domain: Option<&CFErrorDomain>,
            code: CFIndex,
            user_info_keys: *const *const c_void,
            user_info_values: *const *const c_void,
            num_user_info_values: CFIndex,
        ) -> Option<NonNull<CFError>>;
    }
    let ret = unsafe {
        CFErrorCreateWithUserInfoKeysAndValues(
            allocator,
            domain,
            code,
            user_info_keys,
            user_info_values,
            num_user_info_values,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFError::domain`"]
#[inline]
pub extern "C-unwind" fn CFErrorGetDomain(err: &CFError) -> Option<CFRetained<CFErrorDomain>> {
    extern "C-unwind" {
        fn CFErrorGetDomain(err: &CFError) -> Option<NonNull<CFErrorDomain>>;
    }
    let ret = unsafe { CFErrorGetDomain(err) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CFError::code`"]
#[inline]
pub extern "C-unwind" fn CFErrorGetCode(err: &CFError) -> CFIndex {
    extern "C-unwind" {
        fn CFErrorGetCode(err: &CFError) -> CFIndex;
    }
    unsafe { CFErrorGetCode(err) }
}

#[cfg(feature = "CFDictionary")]
#[deprecated = "renamed to `CFError::user_info`"]
#[inline]
pub extern "C-unwind" fn CFErrorCopyUserInfo(err: &CFError) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CFErrorCopyUserInfo(err: &CFError) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CFErrorCopyUserInfo(err) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFError::description`"]
#[inline]
pub extern "C-unwind" fn CFErrorCopyDescription(err: &CFError) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFErrorCopyDescription(err: &CFError) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFErrorCopyDescription(err) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFError::failure_reason`"]
#[inline]
pub extern "C-unwind" fn CFErrorCopyFailureReason(err: &CFError) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFErrorCopyFailureReason(err: &CFError) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFErrorCopyFailureReason(err) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFError::recovery_suggestion`"]
#[inline]
pub extern "C-unwind" fn CFErrorCopyRecoverySuggestion(
    err: &CFError,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFErrorCopyRecoverySuggestion(err: &CFError) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFErrorCopyRecoverySuggestion(err) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}
