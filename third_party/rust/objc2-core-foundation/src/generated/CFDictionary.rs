

use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

























pub type CFDictionaryRetainCallBack =
    Option<unsafe extern "C-unwind" fn(*const CFAllocator, *const c_void) -> *const c_void>;


pub type CFDictionaryReleaseCallBack =
    Option<unsafe extern "C-unwind" fn(*const CFAllocator, *const c_void)>;


pub type CFDictionaryCopyDescriptionCallBack =
    Option<unsafe extern "C-unwind" fn(*const c_void) -> *const CFString>;


pub type CFDictionaryEqualCallBack =
    Option<unsafe extern "C-unwind" fn(*const c_void, *const c_void) -> Boolean>;


pub type CFDictionaryHashCallBack =
    Option<unsafe extern "C-unwind" fn(*const c_void) -> CFHashCode>;


#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFDictionaryKeyCallBacks {
    pub version: CFIndex,
    pub retain: CFDictionaryRetainCallBack,
    pub release: CFDictionaryReleaseCallBack,
    pub copyDescription: CFDictionaryCopyDescriptionCallBack,
    pub equal: CFDictionaryEqualCallBack,
    pub hash: CFDictionaryHashCallBack,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFDictionaryKeyCallBacks {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <CFDictionaryRetainCallBack>::ENCODING,
            <CFDictionaryReleaseCallBack>::ENCODING,
            <CFDictionaryCopyDescriptionCallBack>::ENCODING,
            <CFDictionaryEqualCallBack>::ENCODING,
            <CFDictionaryHashCallBack>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFDictionaryKeyCallBacks {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    
    
    
    
    
    pub static kCFTypeDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
}

extern "C" {
    
    
    
    
    
    
    
    pub static kCFCopyStringDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
}























#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFDictionaryValueCallBacks {
    pub version: CFIndex,
    pub retain: CFDictionaryRetainCallBack,
    pub release: CFDictionaryReleaseCallBack,
    pub copyDescription: CFDictionaryCopyDescriptionCallBack,
    pub equal: CFDictionaryEqualCallBack,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFDictionaryValueCallBacks {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <CFDictionaryRetainCallBack>::ENCODING,
            <CFDictionaryReleaseCallBack>::ENCODING,
            <CFDictionaryCopyDescriptionCallBack>::ENCODING,
            <CFDictionaryEqualCallBack>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFDictionaryValueCallBacks {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    
    
    
    
    
    pub static kCFTypeDictionaryValueCallBacks: CFDictionaryValueCallBacks;
}












pub type CFDictionaryApplierFunction =
    Option<unsafe extern "C-unwind" fn(*const c_void, *const c_void, *mut c_void)>;






#[doc(alias = "CFDictionaryRef")]
#[repr(C)]
pub struct CFDictionary<K: ?Sized = Opaque, V: ?Sized = Opaque> {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
    _generics: PhantomData<(*mut K, *mut V)>,
}

cf_type!(
    unsafe impl<K: ?Sized, V: ?Sized> CFDictionary<K, V> {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl<K: ?Sized, V: ?Sized> RefEncode<"__CFDictionary"> for CFDictionary<K, V> {}
);

impl<K: ?Sized, V: ?Sized> CFDictionary<K, V> {
    
    
    
    
    
    #[inline]
    pub unsafe fn cast_unchecked<NewK: ?Sized, NewV: ?Sized>(&self) -> &CFDictionary<NewK, NewV> {
        unsafe { &*((self as *const Self).cast()) }
    }

    
    #[inline]
    pub fn as_opaque(&self) -> &CFDictionary {
        unsafe { self.cast_unchecked() }
    }
}






#[doc(alias = "CFMutableDictionaryRef")]
#[repr(C)]
pub struct CFMutableDictionary<K: ?Sized = Opaque, V: ?Sized = Opaque> {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
    _generics: PhantomData<(*mut K, *mut V)>,
}

cf_type!(
    unsafe impl<K: ?Sized, V: ?Sized> CFMutableDictionary<K, V>: CFDictionary<K, V> {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl<K: ?Sized, V: ?Sized> RefEncode<"__CFDictionary"> for CFMutableDictionary<K, V> {}
);

impl<K: ?Sized, V: ?Sized> CFMutableDictionary<K, V> {
    
    
    
    
    
    #[inline]
    pub unsafe fn cast_unchecked<NewK: ?Sized, NewV: ?Sized>(
        &self,
    ) -> &CFMutableDictionary<NewK, NewV> {
        unsafe { &*((self as *const Self).cast()) }
    }

    
    #[inline]
    pub fn as_opaque(&self) -> &CFMutableDictionary {
        unsafe { self.cast_unchecked() }
    }
}

unsafe impl ConcreteType for CFDictionary {
    
    #[doc(alias = "CFDictionaryGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFDictionaryGetTypeID() -> CFTypeID;
        }
        unsafe { CFDictionaryGetTypeID() }
    }
}

impl CFDictionary {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryCreate")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        keys: *mut *const c_void,
        values: *mut *const c_void,
        num_values: CFIndex,
        key_call_backs: *const CFDictionaryKeyCallBacks,
        value_call_backs: *const CFDictionaryValueCallBacks,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CFDictionaryCreate(
                allocator: Option<&CFAllocator>,
                keys: *mut *const c_void,
                values: *mut *const c_void,
                num_values: CFIndex,
                key_call_backs: *const CFDictionaryKeyCallBacks,
                value_call_backs: *const CFDictionaryValueCallBacks,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe {
            CFDictionaryCreate(
                allocator,
                keys,
                values,
                num_values,
                key_call_backs,
                value_call_backs,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryCreateCopy")]
    #[inline]
    pub fn new_copy(
        allocator: Option<&CFAllocator>,
        the_dict: Option<&CFDictionary>,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CFDictionaryCreateCopy(
                allocator: Option<&CFAllocator>,
                the_dict: Option<&CFDictionary>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CFDictionaryCreateCopy(allocator, the_dict) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFMutableDictionary {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryCreateMutable")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        capacity: CFIndex,
        key_call_backs: *const CFDictionaryKeyCallBacks,
        value_call_backs: *const CFDictionaryValueCallBacks,
    ) -> Option<CFRetained<CFMutableDictionary>> {
        extern "C-unwind" {
            fn CFDictionaryCreateMutable(
                allocator: Option<&CFAllocator>,
                capacity: CFIndex,
                key_call_backs: *const CFDictionaryKeyCallBacks,
                value_call_backs: *const CFDictionaryValueCallBacks,
            ) -> Option<NonNull<CFMutableDictionary>>;
        }
        let ret = unsafe {
            CFDictionaryCreateMutable(allocator, capacity, key_call_backs, value_call_backs)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryCreateMutableCopy")]
    #[inline]
    pub unsafe fn new_copy(
        allocator: Option<&CFAllocator>,
        capacity: CFIndex,
        the_dict: Option<&CFDictionary>,
    ) -> Option<CFRetained<CFMutableDictionary>> {
        extern "C-unwind" {
            fn CFDictionaryCreateMutableCopy(
                allocator: Option<&CFAllocator>,
                capacity: CFIndex,
                the_dict: Option<&CFDictionary>,
            ) -> Option<NonNull<CFMutableDictionary>>;
        }
        let ret = unsafe { CFDictionaryCreateMutableCopy(allocator, capacity, the_dict) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFDictionary {
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryGetCount")]
    #[inline]
    pub fn count(&self) -> CFIndex {
        extern "C-unwind" {
            fn CFDictionaryGetCount(the_dict: &CFDictionary) -> CFIndex;
        }
        unsafe { CFDictionaryGetCount(self) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryGetCountOfKey")]
    #[inline]
    pub unsafe fn count_of_key(&self, key: *const c_void) -> CFIndex {
        extern "C-unwind" {
            fn CFDictionaryGetCountOfKey(the_dict: &CFDictionary, key: *const c_void) -> CFIndex;
        }
        unsafe { CFDictionaryGetCountOfKey(self, key) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryGetCountOfValue")]
    #[inline]
    pub unsafe fn count_of_value(&self, value: *const c_void) -> CFIndex {
        extern "C-unwind" {
            fn CFDictionaryGetCountOfValue(
                the_dict: &CFDictionary,
                value: *const c_void,
            ) -> CFIndex;
        }
        unsafe { CFDictionaryGetCountOfValue(self, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryContainsKey")]
    #[inline]
    pub unsafe fn contains_ptr_key(&self, key: *const c_void) -> bool {
        extern "C-unwind" {
            fn CFDictionaryContainsKey(the_dict: &CFDictionary, key: *const c_void) -> Boolean;
        }
        let ret = unsafe { CFDictionaryContainsKey(self, key) };
        ret != 0
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryContainsValue")]
    #[inline]
    pub unsafe fn contains_ptr_value(&self, value: *const c_void) -> bool {
        extern "C-unwind" {
            fn CFDictionaryContainsValue(the_dict: &CFDictionary, value: *const c_void) -> Boolean;
        }
        let ret = unsafe { CFDictionaryContainsValue(self, value) };
        ret != 0
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryGetValue")]
    #[inline]
    pub unsafe fn value(&self, key: *const c_void) -> *const c_void {
        extern "C-unwind" {
            fn CFDictionaryGetValue(the_dict: &CFDictionary, key: *const c_void) -> *const c_void;
        }
        unsafe { CFDictionaryGetValue(self, key) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryGetValueIfPresent")]
    #[inline]
    pub unsafe fn value_if_present(&self, key: *const c_void, value: *mut *const c_void) -> bool {
        extern "C-unwind" {
            fn CFDictionaryGetValueIfPresent(
                the_dict: &CFDictionary,
                key: *const c_void,
                value: *mut *const c_void,
            ) -> Boolean;
        }
        let ret = unsafe { CFDictionaryGetValueIfPresent(self, key, value) };
        ret != 0
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryGetKeysAndValues")]
    #[inline]
    pub unsafe fn keys_and_values(&self, keys: *mut *const c_void, values: *mut *const c_void) {
        extern "C-unwind" {
            fn CFDictionaryGetKeysAndValues(
                the_dict: &CFDictionary,
                keys: *mut *const c_void,
                values: *mut *const c_void,
            );
        }
        unsafe { CFDictionaryGetKeysAndValues(self, keys, values) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryApplyFunction")]
    #[inline]
    pub unsafe fn apply_function(
        &self,
        applier: CFDictionaryApplierFunction,
        context: *mut c_void,
    ) {
        extern "C-unwind" {
            fn CFDictionaryApplyFunction(
                the_dict: &CFDictionary,
                applier: CFDictionaryApplierFunction,
                context: *mut c_void,
            );
        }
        unsafe { CFDictionaryApplyFunction(self, applier, context) }
    }
}

impl CFMutableDictionary {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryAddValue")]
    #[inline]
    pub unsafe fn add_value(
        the_dict: Option<&CFMutableDictionary>,
        key: *const c_void,
        value: *const c_void,
    ) {
        extern "C-unwind" {
            fn CFDictionaryAddValue(
                the_dict: Option<&CFMutableDictionary>,
                key: *const c_void,
                value: *const c_void,
            );
        }
        unsafe { CFDictionaryAddValue(the_dict, key, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionarySetValue")]
    #[inline]
    pub unsafe fn set_value(
        the_dict: Option<&CFMutableDictionary>,
        key: *const c_void,
        value: *const c_void,
    ) {
        extern "C-unwind" {
            fn CFDictionarySetValue(
                the_dict: Option<&CFMutableDictionary>,
                key: *const c_void,
                value: *const c_void,
            );
        }
        unsafe { CFDictionarySetValue(the_dict, key, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryReplaceValue")]
    #[inline]
    pub unsafe fn replace_value(
        the_dict: Option<&CFMutableDictionary>,
        key: *const c_void,
        value: *const c_void,
    ) {
        extern "C-unwind" {
            fn CFDictionaryReplaceValue(
                the_dict: Option<&CFMutableDictionary>,
                key: *const c_void,
                value: *const c_void,
            );
        }
        unsafe { CFDictionaryReplaceValue(the_dict, key, value) }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFDictionaryRemoveValue")]
    #[inline]
    pub unsafe fn remove_value(the_dict: Option<&CFMutableDictionary>, key: *const c_void) {
        extern "C-unwind" {
            fn CFDictionaryRemoveValue(the_dict: Option<&CFMutableDictionary>, key: *const c_void);
        }
        unsafe { CFDictionaryRemoveValue(the_dict, key) }
    }

    
    
    
    
    
    #[doc(alias = "CFDictionaryRemoveAllValues")]
    #[inline]
    pub fn remove_all_values(the_dict: Option<&CFMutableDictionary>) {
        extern "C-unwind" {
            fn CFDictionaryRemoveAllValues(the_dict: Option<&CFMutableDictionary>);
        }
        unsafe { CFDictionaryRemoveAllValues(the_dict) }
    }
}

#[deprecated = "renamed to `CFDictionary::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFDictionaryCreate(
    allocator: Option<&CFAllocator>,
    keys: *mut *const c_void,
    values: *mut *const c_void,
    num_values: CFIndex,
    key_call_backs: *const CFDictionaryKeyCallBacks,
    value_call_backs: *const CFDictionaryValueCallBacks,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CFDictionaryCreate(
            allocator: Option<&CFAllocator>,
            keys: *mut *const c_void,
            values: *mut *const c_void,
            num_values: CFIndex,
            key_call_backs: *const CFDictionaryKeyCallBacks,
            value_call_backs: *const CFDictionaryValueCallBacks,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe {
        CFDictionaryCreate(
            allocator,
            keys,
            values,
            num_values,
            key_call_backs,
            value_call_backs,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFDictionary::new_copy`"]
#[inline]
pub extern "C-unwind" fn CFDictionaryCreateCopy(
    allocator: Option<&CFAllocator>,
    the_dict: Option<&CFDictionary>,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CFDictionaryCreateCopy(
            allocator: Option<&CFAllocator>,
            the_dict: Option<&CFDictionary>,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CFDictionaryCreateCopy(allocator, the_dict) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFMutableDictionary::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFDictionaryCreateMutable(
    allocator: Option<&CFAllocator>,
    capacity: CFIndex,
    key_call_backs: *const CFDictionaryKeyCallBacks,
    value_call_backs: *const CFDictionaryValueCallBacks,
) -> Option<CFRetained<CFMutableDictionary>> {
    extern "C-unwind" {
        fn CFDictionaryCreateMutable(
            allocator: Option<&CFAllocator>,
            capacity: CFIndex,
            key_call_backs: *const CFDictionaryKeyCallBacks,
            value_call_backs: *const CFDictionaryValueCallBacks,
        ) -> Option<NonNull<CFMutableDictionary>>;
    }
    let ret =
        unsafe { CFDictionaryCreateMutable(allocator, capacity, key_call_backs, value_call_backs) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFMutableDictionary::new_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFDictionaryCreateMutableCopy(
    allocator: Option<&CFAllocator>,
    capacity: CFIndex,
    the_dict: Option<&CFDictionary>,
) -> Option<CFRetained<CFMutableDictionary>> {
    extern "C-unwind" {
        fn CFDictionaryCreateMutableCopy(
            allocator: Option<&CFAllocator>,
            capacity: CFIndex,
            the_dict: Option<&CFDictionary>,
        ) -> Option<NonNull<CFMutableDictionary>>;
    }
    let ret = unsafe { CFDictionaryCreateMutableCopy(allocator, capacity, the_dict) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFDictionary::count`"]
#[inline]
pub extern "C-unwind" fn CFDictionaryGetCount(the_dict: &CFDictionary) -> CFIndex {
    extern "C-unwind" {
        fn CFDictionaryGetCount(the_dict: &CFDictionary) -> CFIndex;
    }
    unsafe { CFDictionaryGetCount(the_dict) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFDictionary::count_of_key`"]
    pub fn CFDictionaryGetCountOfKey(the_dict: &CFDictionary, key: *const c_void) -> CFIndex;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFDictionary::count_of_value`"]
    pub fn CFDictionaryGetCountOfValue(the_dict: &CFDictionary, value: *const c_void) -> CFIndex;
}

#[deprecated = "renamed to `CFDictionary::contains_ptr_key`"]
#[inline]
pub unsafe extern "C-unwind" fn CFDictionaryContainsKey(
    the_dict: &CFDictionary,
    key: *const c_void,
) -> bool {
    extern "C-unwind" {
        fn CFDictionaryContainsKey(the_dict: &CFDictionary, key: *const c_void) -> Boolean;
    }
    let ret = unsafe { CFDictionaryContainsKey(the_dict, key) };
    ret != 0
}

#[deprecated = "renamed to `CFDictionary::contains_ptr_value`"]
#[inline]
pub unsafe extern "C-unwind" fn CFDictionaryContainsValue(
    the_dict: &CFDictionary,
    value: *const c_void,
) -> bool {
    extern "C-unwind" {
        fn CFDictionaryContainsValue(the_dict: &CFDictionary, value: *const c_void) -> Boolean;
    }
    let ret = unsafe { CFDictionaryContainsValue(the_dict, value) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFDictionary::value`"]
    pub fn CFDictionaryGetValue(the_dict: &CFDictionary, key: *const c_void) -> *const c_void;
}

#[deprecated = "renamed to `CFDictionary::value_if_present`"]
#[inline]
pub unsafe extern "C-unwind" fn CFDictionaryGetValueIfPresent(
    the_dict: &CFDictionary,
    key: *const c_void,
    value: *mut *const c_void,
) -> bool {
    extern "C-unwind" {
        fn CFDictionaryGetValueIfPresent(
            the_dict: &CFDictionary,
            key: *const c_void,
            value: *mut *const c_void,
        ) -> Boolean;
    }
    let ret = unsafe { CFDictionaryGetValueIfPresent(the_dict, key, value) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFDictionary::keys_and_values`"]
    pub fn CFDictionaryGetKeysAndValues(
        the_dict: &CFDictionary,
        keys: *mut *const c_void,
        values: *mut *const c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFDictionary::apply_function`"]
    pub fn CFDictionaryApplyFunction(
        the_dict: &CFDictionary,
        applier: CFDictionaryApplierFunction,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableDictionary::add_value`"]
    pub fn CFDictionaryAddValue(
        the_dict: Option<&CFMutableDictionary>,
        key: *const c_void,
        value: *const c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableDictionary::set_value`"]
    pub fn CFDictionarySetValue(
        the_dict: Option<&CFMutableDictionary>,
        key: *const c_void,
        value: *const c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableDictionary::replace_value`"]
    pub fn CFDictionaryReplaceValue(
        the_dict: Option<&CFMutableDictionary>,
        key: *const c_void,
        value: *const c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableDictionary::remove_value`"]
    pub fn CFDictionaryRemoveValue(the_dict: Option<&CFMutableDictionary>, key: *const c_void);
}

#[deprecated = "renamed to `CFMutableDictionary::remove_all_values`"]
#[inline]
pub extern "C-unwind" fn CFDictionaryRemoveAllValues(the_dict: Option<&CFMutableDictionary>) {
    extern "C-unwind" {
        fn CFDictionaryRemoveAllValues(the_dict: Option<&CFMutableDictionary>);
    }
    unsafe { CFDictionaryRemoveAllValues(the_dict) }
}
