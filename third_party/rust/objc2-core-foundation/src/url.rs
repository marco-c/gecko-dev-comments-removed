#[allow(unused_imports)]
use crate::{CFIndex, CFRetained, CFURL};


#[cfg(feature = "std")]
#[cfg(unix)] 
impl CFURL {
    #[inline]
    fn from_path(
        path: &std::path::Path,
        is_directory: bool,
        base: Option<&CFURL>,
    ) -> Option<CFRetained<CFURL>> {
        use std::os::unix::ffi::OsStrExt;

        
        
        
        
        let bytes = path.as_os_str().as_bytes();

        
        debug_assert!(bytes.len() < CFIndex::MAX as usize);
        let len = bytes.len() as CFIndex;

        if let Some(base) = base {
            
            
            
            
            unsafe {
                Self::from_file_system_representation_relative_to_base(
                    None,
                    bytes.as_ptr(),
                    len,
                    is_directory,
                    Some(base),
                )
            }
        } else {
            unsafe {
                Self::from_file_system_representation(None, bytes.as_ptr(), len, is_directory)
            }
        }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "CFURLCreateFromFileSystemRepresentation")]
    pub fn from_file_path<P: AsRef<std::path::Path>>(path: P) -> Option<CFRetained<CFURL>> {
        Self::from_path(path.as_ref(), false, None)
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "CFURLCreateFromFileSystemRepresentation")]
    pub fn from_directory_path<P: AsRef<std::path::Path>>(path: P) -> Option<CFRetained<CFURL>> {
        Self::from_path(path.as_ref(), true, None)
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFURLGetFileSystemRepresentation")]
    pub fn to_file_path(&self) -> Option<std::path::PathBuf> {
        use std::os::unix::ffi::OsStrExt;

        const PATH_MAX: usize = 1024;

        
        
        
        
        
        
        
        let mut buf = [0u8; PATH_MAX];
        let result = unsafe {
            self.file_system_representation(true, buf.as_mut_ptr(), buf.len() as CFIndex)
        };
        if !result {
            return None;
        }

        
        
        let cstr = unsafe { core::ffi::CStr::from_bytes_until_nul(&buf).unwrap_unchecked() };

        let path = std::ffi::OsStr::from_bytes(cstr.to_bytes());
        Some(path.into())
    }
}


impl CFURL {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "CFURLCreateWithString")]
    pub fn from_string(
        allocator: Option<&crate::CFAllocator>,
        url_string: &crate::CFString,
        base_url: Option<&CFURL>,
    ) -> Option<CFRetained<Self>> {
        Self::__from_string(allocator, Some(url_string), base_url)
    }

    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[cfg(feature = "CFString")]
    #[doc(alias = "CFURLCreateWithBytes")]
    pub unsafe fn from_str_unchecked(s: &str) -> Option<CFRetained<Self>> {
        let ptr = s.as_ptr();

        
        debug_assert!(s.len() < CFIndex::MAX as usize);
        let len = s.len() as CFIndex;

        let encoding = crate::CFStringBuiltInEncodings::EncodingUTF8;
        
        
        
        
        
        
        
        unsafe { Self::with_bytes(None, ptr, len, encoding.0, None) }
    }

    
    
    
    
    
    #[doc(alias = "CFURLGetString")]
    pub fn string(&self) -> CFRetained<crate::CFString> {
        
        
        self.__string().expect("failed getting string from CFURL")
    }
}

#[cfg(unix)]
#[cfg(test)]
#[cfg(feature = "CFString")]
#[cfg(feature = "std")]
mod tests {
    use std::ffi::OsStr;
    use std::os::unix::ffi::OsStrExt;
    use std::path::Path;
    use std::{env::current_dir, string::ToString};

    use crate::{CFString, CFURLPathStyle};

    use super::*;

    #[test]
    fn from_string() {
        let url =
            CFURL::from_string(None, &CFString::from_str("https://example.com/xyz"), None).unwrap();
        assert_eq!(url.to_file_path().unwrap(), Path::new("/xyz"));
        assert_eq!(url.string().to_string(), "https://example.com/xyz");

        
        let url = CFURL::from_string(None, &CFString::from_str("\0"), None);
        assert_eq!(url, None);

        
        let url = CFURL::from_string(None, &CFString::from_str("http://example.com/%a"), None);
        assert_eq!(url, None);

        
        let url = unsafe { CFURL::from_str_unchecked("http://example.com/%a") }.unwrap();
        assert_eq!(url.string().to_string(), "http://example.com/%25a");
        assert_eq!(url.to_file_path().unwrap(), Path::new("/%a"));

        let url = unsafe { CFURL::from_str_unchecked("/\0a\0") }.unwrap();
        assert_eq!(url.string().to_string(), "/%00a%00");
        assert_eq!(url.to_file_path(), None);
    }

    #[test]
    fn to_string_may_extra_percent_encode() {
        let url = CFURL::from_string(None, &CFString::from_str("["), None).unwrap();
        assert_eq!(url.string().to_string(), "%5B");
    }

    #[test]
    #[cfg(feature = "objc2")]
    fn invalid_with_nul_bytes() {
        
        
        let url = unsafe { CFURL::from_str_unchecked("a\0aaaaaa") };
        if objc2::available!(macos = 12.0, ios = 15.0, watchos = 8.0, tvos = 15.0, ..) {
            assert_eq!(url, None);
        } else {
            assert_eq!(url.unwrap().string().to_string(), "a%00aaaaaa");
        }
    }

    #[test]
    fn to_from_path() {
        let url = CFURL::from_file_path("/").unwrap();
        assert_eq!(url.to_file_path().unwrap(), Path::new("/"));

        let url = CFURL::from_file_path("/abc/def").unwrap();
        assert_eq!(url.to_file_path().unwrap(), Path::new("/abc/def"));

        let url = CFURL::from_directory_path("/abc/def").unwrap();
        assert_eq!(url.to_file_path().unwrap(), Path::new("/abc/def/"));

        let url = CFURL::from_file_path("relative.txt").unwrap();
        assert_eq!(
            url.to_file_path(),
            Some(current_dir().unwrap().join("relative.txt"))
        );
        assert_eq!(
            url.absolute_url().unwrap().to_file_path(),
            Some(current_dir().unwrap().join("relative.txt"))
        );

        let str = "/with space and wÃ©ird UTF-8 chars: ðŸ˜€";
        let url = CFURL::from_file_path(str).unwrap();
        assert_eq!(url.to_file_path().unwrap(), Path::new(str));
    }

    #[test]
    fn invalid_path() {
        assert_eq!(CFURL::from_file_path(""), None);
        assert_eq!(CFURL::from_file_path("/\0/a"), None);
    }

    #[test]
    fn from_dir_strips_dot() {
        let url = CFURL::from_directory_path("/Library/.").unwrap();
        assert_eq!(url.to_file_path().unwrap(), Path::new("/Library/"));
    }

    
    #[test]
    #[cfg_attr(
        not(target_os = "macos"),
        ignore = "seems to work differently in the simulator"
    )]
    fn path_with_trailing_nul() {
        let url = CFURL::from_file_path("/abc/def\0\0\0").unwrap();
        assert_eq!(url.to_file_path().unwrap(), Path::new("/abc/def"));

        let path = url
            .file_system_path(CFURLPathStyle::CFURLPOSIXPathStyle)
            .unwrap();
        assert_eq!(path.to_string(), "/abc/def");
        #[allow(deprecated)]
        let path = url
            .file_system_path(CFURLPathStyle::CFURLHFSPathStyle)
            .unwrap();
        assert!(path.to_string().ends_with(":abc:def")); 
        let path = url
            .file_system_path(CFURLPathStyle::CFURLWindowsPathStyle)
            .unwrap();
        assert_eq!(path.to_string(), "\\abc\\def");
    }

    #[test]
    fn path_with_base() {
        let base = CFURL::from_directory_path("/abc/").unwrap();
        let url = CFURL::from_path(Path::new("def"), false, Some(&base)).unwrap();
        assert_eq!(url.to_file_path().unwrap(), Path::new("/abc/def"));
        let url = CFURL::from_path(Path::new("def/"), false, Some(&base)).unwrap();
        assert_eq!(url.to_file_path().unwrap(), Path::new("/abc/def/"));
        let url = CFURL::from_path(Path::new("/def"), false, Some(&base)).unwrap();
        assert_eq!(url.to_file_path().unwrap(), Path::new("/def"));
    }

    #[test]
    fn path_invalid_utf8() {
        
        let url = CFURL::from_file_path(OsStr::from_bytes(b"abc\xd4def/xyz")).unwrap();
        assert_eq!(url.to_file_path().unwrap(), current_dir().unwrap()); 
        assert!(url
            .file_system_path(CFURLPathStyle::CFURLPOSIXPathStyle)
            .is_none());
        assert_eq!(url.string().to_string(), "abc%D4def/xyz");
        assert_eq!(url.path().unwrap().to_string(), "abc%D4def/xyz");

        
        
        let url = CFURL::from_file_path(OsStr::from_bytes(b"/\xf8a/b/c")).unwrap();
        assert_eq!(
            url.to_file_path().unwrap(),
            OsStr::from_bytes(b"/\xf8a/b/c")
        );
        assert_eq!(url.string().to_string(), "file:///%F8a/b/c");
        assert_eq!(url.path().unwrap().to_string(), "/%F8a/b/c");

        
        let url = CFURL::from_path(
            Path::new(OsStr::from_bytes(b"sub\xd4/%D4")),
            false,
            Some(&url),
        )
        .unwrap();
        assert_eq!(url.to_file_path(), None);
        assert_eq!(url.string().to_string(), "sub%D4/%25D4");
        assert_eq!(url.path().unwrap().to_string(), "sub%D4/%25D4");
        let abs = url.absolute_url().unwrap();
        assert_eq!(abs.to_file_path(), None);
        assert_eq!(abs.string().to_string(), "file:///%F8a/b/sub%D4/%25D4");
        assert_eq!(abs.path().unwrap().to_string(), "/%F8a/b/sub%D4/%25D4");
    }

    #[test]
    fn path_percent_encoded() {
        let url = CFURL::from_file_path("/%D4").unwrap();
        assert_eq!(url.path().unwrap().to_string(), "/%25D4");
        assert_eq!(url.to_file_path().unwrap(), Path::new("/%D4"));

        let url = CFURL::from_file_path("/%invalid").unwrap();
        assert_eq!(url.path().unwrap().to_string(), "/%25invalid");
        assert_eq!(url.to_file_path().unwrap(), Path::new("/%invalid"));
    }

    #[test]
    fn path_percent_encoded_eq() {
        let normal = CFURL::from_file_path(OsStr::from_bytes(b"\xf8")).unwrap();
        let percent = CFURL::from_file_path("%F8").unwrap();
        
        assert_ne!(normal, percent);
    }

    #[test]
    #[allow(deprecated)]
    #[ignore = "TODO: Crashes - is this unsound?"]
    fn hfs_invalid_utf8() {
        let url = CFURL::from_file_path(OsStr::from_bytes(b"\xd4")).unwrap();
        assert!(url
            .file_system_path(CFURLPathStyle::CFURLHFSPathStyle)
            .is_none());
    }
}
