use core::slice;

#[cfg(feature = "alloc")]
use alloc::vec::Vec;

use crate::{CFData, CFIndex};

fn get_len(bytes: &[u8]) -> CFIndex {
    
    
    let len = bytes.len();
    debug_assert!(len < CFIndex::MAX as usize);
    len as CFIndex
}

impl CFData {
    
    #[inline]
    #[doc(alias = "CFDataCreate")]
    pub fn from_bytes(bytes: &[u8]) -> crate::CFRetained<Self> {
        let len = get_len(bytes);
        unsafe { crate::CFData::new(None, bytes.as_ptr(), len) }.expect("failed creating CFData")
    }

    
    #[inline]
    #[deprecated = "renamed to CFData::from_bytes"]
    pub fn from_buffer(bytes: &[u8]) -> crate::CFRetained<Self> {
        Self::from_bytes(bytes)
    }

    
    
    
    
    
    #[inline]
    #[doc(alias = "CFDataCreateWithBytesNoCopy")]
    pub fn from_static_bytes(bytes: &'static [u8]) -> crate::CFRetained<Self> {
        let len = get_len(bytes);
        
        unsafe { CFData::with_bytes_no_copy(None, bytes.as_ptr(), len, crate::kCFAllocatorNull) }
            .expect("failed creating CFData")
    }

    
    #[inline]
    #[doc(alias = "CFDataGetLength")]
    pub fn len(&self) -> usize {
        self.length() as usize
    }

    
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "CFDataGetBytePtr")]
    pub unsafe fn as_bytes_unchecked(&self) -> &[u8] {
        let ptr = self.byte_ptr();
        if !ptr.is_null() {
            
            
            
            
            unsafe { slice::from_raw_parts(ptr, self.len()) }
        } else {
            
            &[]
        }
    }

    
    #[cfg(feature = "alloc")]
    #[doc(alias = "CFDataGetBytePtr")]
    pub fn to_vec(&self) -> Vec<u8> {
        
        
        

        let mut vec = Vec::with_capacity(self.len());
        
        
        vec.extend_from_slice(unsafe { self.as_bytes_unchecked() });
        vec
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn roundtrip() {
        let data = CFData::from_bytes(&[1, 2, 3]);
        assert_eq!(data.to_vec(), [1, 2, 3]);
    }

    #[test]
    fn empty() {
        let data = CFData::from_bytes(&[]);
        assert!(data.is_empty());
        assert_eq!(data.to_vec(), []);
    }
}
