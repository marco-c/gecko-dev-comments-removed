use core::cmp::Ordering;
use core::ffi::c_char;
use core::fmt::Write;
use core::ptr::NonNull;
use core::{fmt, slice, str};

use crate::{
    kCFAllocatorNull, CFIndex, CFRange, CFRetained, CFString, CFStringBuiltInEncodings,
    CFStringCompareFlags,
};

#[track_caller]
unsafe fn debug_checked_utf8_unchecked(bytes: &[u8]) -> &str {
    if cfg!(debug_assertions) {
        match str::from_utf8(bytes) {
            Ok(s) => s,
            Err(err) => panic!(
                "unsafe precondition violated: CF function did not return valid UTF-8: {err}"
            ),
        }
    } else {
        
        unsafe { str::from_utf8_unchecked(bytes) }
    }
}

impl CFString {
    
    #[inline]
    #[doc(alias = "CFStringCreateWithBytes")]
    #[allow(clippy::should_implement_trait)] 
    pub fn from_str(string: &str) -> CFRetained<Self> {
        
        debug_assert!(string.len() < CFIndex::MAX as usize);
        let len = string.len() as CFIndex;
        let s = unsafe {
            Self::with_bytes(
                None,
                string.as_ptr(),
                len,
                CFStringBuiltInEncodings::EncodingUTF8.0,
                false,
            )
        };
        
        
        s.expect("failed creating CFString")
    }

    
    #[inline]
    #[deprecated = "renamed to CFString::from_str"]
    pub fn new(string: &str) -> CFRetained<Self> {
        Self::from_str(string)
    }

    
    
    
    
    
    #[inline]
    #[doc(alias = "CFStringCreateWithBytesNoCopy")]
    pub fn from_static_str(string: &'static str) -> CFRetained<Self> {
        debug_assert!(string.len() < CFIndex::MAX as usize);
        let len = string.len() as CFIndex;
        
        
        
        
        let s = unsafe {
            Self::with_bytes_no_copy(
                None,
                string.as_ptr(),
                len,
                CFStringBuiltInEncodings::EncodingUTF8.0,
                false,
                kCFAllocatorNull,
            )
        };
        s.expect("failed creating CFString")
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "CFStringGetCStringPtr")]
    pub unsafe fn as_str_unchecked(&self) -> Option<&str> {
        
        let bytes = self.c_string_ptr(CFStringBuiltInEncodings::EncodingASCII.0);
        NonNull::new(bytes as *mut c_char).map(|bytes| {
            
            
            
            
            
            
            
            
            
            
            
            let len = self.length() as usize;

            
            
            
            let bytes = unsafe { slice::from_raw_parts(bytes.as_ptr().cast(), len) };

            
            
            
            unsafe { debug_checked_utf8_unchecked(bytes) }
        })
    }
}

impl fmt::Display for CFString {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        
        
        
        
        
        
        

        
        
        
        
        let mut buf = [0u8; 32];

        let mut location_utf16 = 0;

        loop {
            let len_utf16 = self.length();
            let mut read_utf8 = 0;
            let read_utf16 = unsafe {
                self.bytes(
                    CFRange {
                        location: location_utf16,
                        length: len_utf16 - location_utf16,
                    },
                    CFStringBuiltInEncodings::EncodingUTF8.0,
                    0, 
                    false,
                    buf.as_mut_ptr(),
                    buf.len() as _,
                    &mut read_utf8,
                )
            };
            if read_utf16 <= 0 {
                if location_utf16 < len_utf16 {
                    
                    
                    f.write_char(char::REPLACEMENT_CHARACTER)?;
                    location_utf16 += 1;
                    continue;
                }
                break;
            }
            location_utf16 += read_utf16;

            
            
            
            
            
            let s = unsafe { debug_checked_utf8_unchecked(&buf[0..read_utf8 as usize]) };

            
            f.write_str(s)?;
        }

        Ok(())
    }
}

impl PartialOrd for CFString {
    #[inline]
    #[doc(alias = "CFStringCompare")]
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for CFString {
    #[inline]
    #[doc(alias = "CFStringCompare")]
    fn cmp(&self, other: &Self) -> Ordering {
        
        let flags = CFStringCompareFlags::empty();
        self.compare(Some(other), flags).into()
    }
}

#[cfg(test)]
mod tests {
    use alloc::string::ToString;
    use core::ffi::CStr;

    use super::*;

    #[test]
    fn basic_conversion() {
        let s = CFString::from_str("abc");
        assert_eq!(s.to_string(), "abc");
        let s = CFString::from_str("aâ™¥ðŸ˜€");
        assert_eq!(s.to_string(), "aâ™¥ðŸ˜€");
    }

    #[test]
    fn cstr_conversion() {
        let table = [
            (
                b"abc\xf8xyz\0" as &[u8],
                CFStringBuiltInEncodings::EncodingISOLatin1,
                "abcÃ¸xyz",
            ),
            (
                b"\x26\x65\0",
                CFStringBuiltInEncodings::EncodingUTF16BE,
                "â™¥",
            ),
            (
                b"\x65\x26\0",
                CFStringBuiltInEncodings::EncodingUTF16LE,
                "â™¥",
            ),
        ];
        for (cstr, encoding, expected) in table {
            let cstr = CStr::from_bytes_with_nul(cstr).unwrap();
            let s = unsafe { CFString::with_c_string(None, cstr.as_ptr(), encoding.0) }.unwrap();
            assert_eq!(s.to_string(), expected);
        }
    }

    #[test]
    fn from_incomplete() {
        let s = unsafe {
            CFString::with_bytes(
                None,
                b"\xd8\x3d\xde".as_ptr(),
                3,
                CFStringBuiltInEncodings::EncodingUTF16BE.0,
                false,
            )
            .unwrap()
        };
        assert_eq!(s.to_string(), "ï¿½"); 
        assert_eq!(s.length(), 1);
    }

    #[test]
    fn internal_nul_byte() {
        let s = CFString::from_str("a\0b\0c\0d");
        
        assert_eq!(s.to_string(), "a\0b\0c\0d");
        
        
        if cfg!(target_pointer_width = "64") {
            assert_eq!(unsafe { s.as_str_unchecked() }, None);
        } else {
            assert_eq!(unsafe { s.as_str_unchecked() }, Some("a\0b\0c\0d"));
        }

        
        let mut buf = [0u8; 10];
        assert!(unsafe {
            s.c_string(
                buf.as_mut_ptr().cast(),
                buf.len() as _,
                CFStringBuiltInEncodings::EncodingUTF8.0,
            )
        });
        
        assert_eq!(&buf[0..10], b"a\0b\0c\0d\0\0\0");

        
        
        let cstr = CStr::from_bytes_until_nul(&buf).unwrap();
        assert_eq!(cstr.to_bytes(), b"a");

        
        
        let s = CFString::from_str("a\0aaaaaaaaaaaaaaa");
        
        assert_eq!(s.to_string(), "a\0aaaaaaaaaaaaaaa");
        
        assert_eq!(unsafe { s.as_str_unchecked() }, Some("a\0aaaaaaaaaaaaaaa"));
    }

    #[test]
    fn as_str_correct_on_unicode() {
        let s = CFString::from_static_str("ðŸ˜€");
        assert_eq!(unsafe { s.as_str_unchecked() }, None);
        let s = CFString::from_static_str("â™¥");
        assert_eq!(unsafe { s.as_str_unchecked() }, None);
    }

    #[test]
    fn utf8_on_boundary() {
        
        let s = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaðŸ˜€"; 
        assert_eq!(CFString::from_str(s).to_string(), s);
        let s = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaðŸ˜€"; 
        assert_eq!(CFString::from_str(s).to_string(), s);
        let s = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaðŸ˜€"; 
        assert_eq!(CFString::from_str(s).to_string(), s);
    }

    #[test]
    fn create_with_cstring_broken_on_non_8_bit() {
        
        
        
        
        
        
        
        
        let s = unsafe {
            CFString::with_c_string(
                None,
                b"\x65\x26\0".as_ptr().cast(),
                CFStringBuiltInEncodings::EncodingUnicode.0,
            )
        }
        .unwrap();

        
        assert_eq!(s.to_string(), "â™¥");

        
        let mut buf = [0u8; 20];
        assert!(unsafe {
            s.c_string(
                buf.as_mut_ptr().cast(),
                buf.len() as _,
                CFStringBuiltInEncodings::EncodingUTF8.0,
            )
        });
        let cstr = CStr::from_bytes_until_nul(&buf).unwrap();
        assert_eq!(cstr.to_bytes(), "â™¥".as_bytes());

        
        assert_eq!(unsafe { s.as_str_unchecked() }, Some("e"));
        assert_eq!(
            unsafe { CStr::from_ptr(s.c_string_ptr(CFStringBuiltInEncodings::EncodingUTF8.0,)) },
            CStr::from_bytes_with_nul(b"e&\0").unwrap()
        );
    }

    #[test]
    fn test_static() {
        let cf = CFString::from_static_str("xyz");
        assert_eq!(cf.to_string(), "xyz");
    }

    #[test]
    fn eq() {
        assert_eq!(CFString::from_str("abc"), CFString::from_str("abc"));
        assert_ne!(CFString::from_str("abc"), CFString::from_str("xyz"));
        
        assert_ne!(
            **CFString::from_str("abc"),
            **unsafe { kCFAllocatorNull }.unwrap()
        );
    }

    
}
