#[cfg(feature = "objc2")]
use objc2::encode::{Encode, Encoding, RefEncode};

use crate::{CGAffineTransform, CGVector};

#[cfg(target_pointer_width = "64")]
type InnerFloat = f64;
#[cfg(not(target_pointer_width = "64"))]
type InnerFloat = f32;








pub type CGFloat = InnerFloat;






#[cfg(not(any(
    not(target_vendor = "apple"),
    all(target_os = "macos", target_pointer_width = "32")
)))]
#[cfg(feature = "objc2")]
mod names {
    pub(super) const POINT: &str = "CGPoint";
    pub(super) const SIZE: &str = "CGSize";
    pub(super) const RECT: &str = "CGRect";
}

#[cfg(any(
    not(target_vendor = "apple"),
    all(target_os = "macos", target_pointer_width = "32")
))]
#[cfg(feature = "objc2")]
mod names {
    pub(super) const POINT: &str = "_NSPoint";
    pub(super) const SIZE: &str = "_NSSize";
    pub(super) const RECT: &str = "_NSRect";
}




#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct CGPoint {
    
    pub x: CGFloat,
    
    pub y: CGFloat,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGPoint {
    const ENCODING: Encoding =
        Encoding::Struct(names::POINT, &[CGFloat::ENCODING, CGFloat::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGPoint {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CGPoint {
    
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "NSMakePoint")]
    #[doc(alias = "CGPointMake")]
    pub const fn new(x: CGFloat, y: CGFloat) -> Self {
        Self { x, y }
    }

    
    
    
    
    
    
    
    
    
    #[doc(alias = "NSZeroPoint")]
    #[doc(alias = "CGPointZero")]
    #[doc(alias = "ORIGIN")]
    pub const ZERO: Self = Self::new(0.0, 0.0);
}









#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct CGSize {
    
    pub width: CGFloat,
    
    pub height: CGFloat,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGSize {
    const ENCODING: Encoding =
        Encoding::Struct(names::SIZE, &[CGFloat::ENCODING, CGFloat::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGSize {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CGSize {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "NSMakeSize")]
    #[doc(alias = "CGSizeMake")]
    pub const fn new(width: CGFloat, height: CGFloat) -> Self {
        
        
        
        
        
        
        Self { width, height }
    }

    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[cfg(feature = "std")] 
    pub fn abs(self) -> Self {
        Self::new(self.width.abs(), self.height.abs())
    }

    
    
    
    
    
    
    
    
    
    #[doc(alias = "NSZeroSize")]
    #[doc(alias = "CGSizeZero")]
    pub const ZERO: Self = Self::new(0.0, 0.0);
}












#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct CGRect {
    
    pub origin: CGPoint,
    
    pub size: CGSize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGRect {
    const ENCODING: Encoding =
        Encoding::Struct(names::RECT, &[CGPoint::ENCODING, CGSize::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGRect {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CGRect {
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "NSMakeRect")]
    #[doc(alias = "CGRectMake")]
    pub const fn new(origin: CGPoint, size: CGSize) -> Self {
        Self { origin, size }
    }

    
    #[doc(alias = "NSZeroRect")]
    #[doc(alias = "CGRectZero")]
    pub const ZERO: Self = Self::new(CGPoint::ZERO, CGSize::ZERO);

    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "CGRectStandardize")]
    #[cfg(feature = "std")] 
    pub fn standardize(self) -> Self {
        Self::new(self.origin, self.size.abs())
    }

    
    #[inline]
    #[doc(alias = "CGRectGetMinX")]
    #[doc(alias = "CGRectGetMinY")]
    #[doc(alias = "NSMinX")]
    #[doc(alias = "NSMinY")]
    pub fn min(self) -> CGPoint {
        self.origin
    }

    
    #[inline]
    #[doc(alias = "CGRectGetMidX")]
    #[doc(alias = "CGRectGetMidY")]
    #[doc(alias = "NSMidX")]
    #[doc(alias = "NSMidY")]
    pub fn mid(self) -> CGPoint {
        CGPoint::new(
            self.origin.x + (self.size.width * 0.5),
            self.origin.y + (self.size.height * 0.5),
        )
    }

    
    #[inline]
    #[doc(alias = "CGRectGetMaxX")]
    #[doc(alias = "CGRectGetMaxY")]
    #[doc(alias = "NSMaxX")]
    #[doc(alias = "NSMaxY")]
    pub fn max(self) -> CGPoint {
        CGPoint::new(
            self.origin.x + self.size.width,
            self.origin.y + self.size.height,
        )
    }

    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "CGRectIsEmpty")]
    pub fn is_empty(self) -> bool {
        !(self.size.width > 0.0 && self.size.height > 0.0)
        
        
    }

    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    
}


impl Default for CGVector {
    fn default() -> Self {
        Self { dx: 0.0, dy: 0.0 }
    }
}

impl CGVector {
    #[inline]
    #[doc(alias = "CGVectorMake")]
    pub const fn new(dx: CGFloat, dy: CGFloat) -> Self {
        Self { dx, dy }
    }
}


impl Default for CGAffineTransform {
    fn default() -> Self {
        Self {
            a: 0.0,
            b: 0.0,
            c: 0.0,
            d: 0.0,
            tx: 0.0,
            ty: 0.0,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cgsize_new() {
        CGSize::new(1.0, 1.0);
        CGSize::new(0.0, -0.0);
        CGSize::new(-0.0, 0.0);
        CGSize::new(-0.0, -0.0);
        CGSize::new(-1.0, -1.0);
        CGSize::new(-1.0, 1.0);
        CGSize::new(1.0, -1.0);
    }
}
