







use core::{marker::PhantomData, mem, ops::Range, ptr::NonNull};

pub use _def::PtrInner;

#[allow(unused_imports)]
use crate::util::polyfills::NumExt as _;
use crate::{
    layout::{CastType, MetadataCastError},
    util::AsAddress,
    AlignmentError, CastError, KnownLayout, MetadataOf, SizeError, SplitAt,
};

mod _def {
    use super::*;
    
    
    
    
    
    #[allow(missing_debug_implementations)]
    pub struct PtrInner<'a, T>
    where
        T: ?Sized,
    {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        ptr: NonNull<T>,
        
        
        
        
        
        _marker: PhantomData<&'a core::cell::UnsafeCell<T>>,
    }

    impl<'a, T: 'a + ?Sized> Copy for PtrInner<'a, T> {}
    impl<'a, T: 'a + ?Sized> Clone for PtrInner<'a, T> {
        #[inline(always)]
        fn clone(&self) -> PtrInner<'a, T> {
            
            
            *self
        }
    }

    impl<'a, T: 'a + ?Sized> PtrInner<'a, T> {
        
        
        
        
        
        
        
        
        
        
        
        #[inline(always)]
        #[must_use]
        pub const unsafe fn new(ptr: NonNull<T>) -> PtrInner<'a, T> {
            
            
            Self { ptr, _marker: PhantomData }
        }

        
        
        
        
        
        #[inline(always)]
        #[must_use]
        pub const fn as_non_null(&self) -> NonNull<T> {
            self.ptr
        }
    }
}

impl<'a, T: ?Sized> PtrInner<'a, T> {
    
    #[inline]
    pub(crate) fn from_ref(ptr: &'a T) -> Self {
        let ptr = NonNull::from(ptr);
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        unsafe { Self::new(ptr) }
    }

    
    #[inline]
    pub(crate) fn from_mut(ptr: &'a mut T) -> Self {
        let ptr = NonNull::from(ptr);
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        unsafe { Self::new(ptr) }
    }

    #[must_use]
    #[inline(always)]
    pub fn cast_sized<U>(self) -> PtrInner<'a, U>
    where
        T: Sized,
    {
        static_assert!(T, U => mem::size_of::<T>() >= mem::size_of::<U>());
        
        
        unsafe { self.cast() }
    }

    
    
    
    #[must_use]
    #[inline(always)]
    pub unsafe fn cast<U>(self) -> PtrInner<'a, U> {
        let ptr = self.as_non_null().cast::<U>();

        
        
        
        
        
        
        
        
        
        
        unsafe { PtrInner::new(ptr) }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a, T> PtrInner<'a, T>
where
    T: ?Sized + KnownLayout,
{
    
    pub(crate) fn meta(self) -> MetadataOf<T> {
        let meta = T::pointer_to_metadata(self.as_non_null().as_ptr());
        
        
        unsafe { MetadataOf::new_unchecked(meta) }
    }

    
    
    
    
    
    
    
    
    #[inline]
    pub(crate) unsafe fn with_meta(self, meta: T::PointerMetadata) -> Self
    where
        T: KnownLayout,
    {
        let raw = T::raw_from_ptr_len(self.as_non_null().cast(), meta);

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        unsafe { PtrInner::new(raw) }
    }

    pub(crate) fn as_bytes(self) -> PtrInner<'a, [u8]> {
        let ptr = self.as_non_null();
        let bytes = match T::size_of_val_raw(ptr) {
            Some(bytes) => bytes,
            
            
            
            
            
            None => unsafe { core::hint::unreachable_unchecked() },
        };

        let ptr = core::ptr::slice_from_raw_parts_mut(ptr.cast::<u8>().as_ptr(), bytes);

        
        
        let ptr = unsafe { NonNull::new_unchecked(ptr) };

        
        
        
        
        
        
        
        
        
        
        unsafe { PtrInner::new(ptr) }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a, T> PtrInner<'a, T>
where
    T: ?Sized + KnownLayout<PointerMetadata = usize>,
{
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub(crate) unsafe fn split_at_unchecked(
        self,
        l_len: crate::util::MetadataOf<T>,
    ) -> (Self, PtrInner<'a, [T::Elem]>)
    where
        T: SplitAt,
    {
        let l_len = l_len.get();

        
        
        let left = unsafe { self.with_meta(l_len) };

        let right = self.trailing_slice();
        
        
        let right = unsafe { right.slice_unchecked(l_len..self.meta().get()) };

        
        
        
        
        
        
        
        
        
        
        
        
        
        (left, right)
    }

    
    pub(crate) fn trailing_slice(self) -> PtrInner<'a, [T::Elem]>
    where
        T: SplitAt,
    {
        let offset = crate::trailing_slice_layout::<T>().offset;

        let bytes = self.as_non_null().cast::<u8>().as_ptr();

        
        
        
        
        
        
        
        
        
        
        
        
        let bytes = unsafe { bytes.add(offset) };

        
        
        
        let bytes = unsafe { NonNull::new_unchecked(bytes) };

        let ptr = KnownLayout::raw_from_ptr_len(bytes, self.meta().get());

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        unsafe { PtrInner::new(ptr) }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a, T> PtrInner<'a, [T]> {
    
    
    
    
    
    pub(crate) unsafe fn slice_unchecked(self, range: Range<usize>) -> Self {
        let base = self.as_non_null().cast::<T>().as_ptr();

        
        
        
        
        
        
        
        
        
        
        let base = unsafe { base.add(range.start) };

        
        
        #[allow(unstable_name_collisions)]
        let len = unsafe { range.end.unchecked_sub(range.start) };

        let ptr = core::ptr::slice_from_raw_parts_mut(base, len);

        
        
        
        let ptr = unsafe { NonNull::new_unchecked(ptr) };

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        unsafe { PtrInner::new(ptr) }
    }

    
    pub(crate) fn iter(&self) -> impl Iterator<Item = PtrInner<'a, T>> {
        
        
        let base = self.as_non_null().cast::<T>().as_ptr();
        (0..self.meta().get()).map(move |i| {
            
            

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            let elem = unsafe { base.add(i) };

            
            
            
            
            
            
            let elem = unsafe { NonNull::new_unchecked(elem) };

            
            
            
            
            
            
            
            
            
            
            
            
            unsafe { PtrInner::new(elem) }
        })
    }
}

impl<'a, T, const N: usize> PtrInner<'a, [T; N]> {
    
    
    
    
    
    
    #[allow(clippy::wrong_self_convention)]
    pub(crate) fn as_slice(self) -> PtrInner<'a, [T]> {
        let start = self.as_non_null().cast::<T>().as_ptr();
        let slice = core::ptr::slice_from_raw_parts_mut(start, N);
        
        
        let slice = unsafe { NonNull::new_unchecked(slice) };
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        unsafe { PtrInner::new(slice) }
    }
}

impl<'a> PtrInner<'a, [u8]> {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    pub(crate) fn try_cast_into<U>(
        self,
        cast_type: CastType,
        meta: Option<U::PointerMetadata>,
    ) -> Result<(PtrInner<'a, U>, PtrInner<'a, [u8]>), CastError<Self, U>>
    where
        U: 'a + ?Sized + KnownLayout,
    {
        
        
        
        
        
        
        
        let maybe_metadata = MetadataOf::<U>::validate_cast_and_convert_metadata(
            AsAddress::addr(self.as_non_null().as_ptr()),
            self.meta(),
            cast_type,
            meta,
        );

        let (elems, split_at) = match maybe_metadata {
            Ok((elems, split_at)) => (elems, split_at),
            Err(MetadataCastError::Alignment) => {
                
                
                
                let err = unsafe { AlignmentError::<_, U>::new_unchecked(self) };
                return Err(CastError::Alignment(err));
            }
            Err(MetadataCastError::Size) => return Err(CastError::Size(SizeError::new(self))),
        };

        
        
        
        
        
        
        let (l_slice, r_slice) = unsafe { self.split_at_unchecked(split_at) };

        let (target, remainder) = match cast_type {
            CastType::Prefix => (l_slice, r_slice),
            CastType::Suffix => (r_slice, l_slice),
        };

        let base = target.as_non_null().cast::<u8>();

        let ptr = U::raw_from_ptr_len(base, elems.get());

        
        
        
        
        
        
        
        
        
        
        
        
        Ok((unsafe { PtrInner::new(ptr) }, remainder))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::*;

    #[test]
    fn test_meta() {
        let arr = [1; 16];
        let dst = <[u8]>::ref_from_bytes(&arr[..]).unwrap();
        let ptr = PtrInner::from_ref(dst);
        assert_eq!(ptr.meta().get(), 16);

        
        let ptr = unsafe { ptr.with_meta(8) };

        assert_eq!(ptr.meta().get(), 8);
    }

    #[test]
    fn test_split_at() {
        fn test_split_at<const OFFSET: usize, const BUFFER_SIZE: usize>() {
            #[derive(FromBytes, KnownLayout, SplitAt, Immutable)]
            #[repr(C)]
            struct SliceDst<const OFFSET: usize> {
                prefix: [u8; OFFSET],
                trailing: [u8],
            }

            let n: usize = BUFFER_SIZE - OFFSET;
            let arr = [1; BUFFER_SIZE];
            let dst = SliceDst::<OFFSET>::ref_from_bytes(&arr[..]).unwrap();
            let ptr = PtrInner::from_ref(dst);
            for i in 0..=n {
                assert_eq!(ptr.meta().get(), n);
                
                let i = unsafe { MetadataOf::new_unchecked(i) };
                
                let (l, r) = unsafe { ptr.split_at_unchecked(i) };
                
                #[allow(clippy::undocumented_unsafe_blocks, clippy::as_conversions)]
                
                let l_sum: usize = l
                    .trailing_slice()
                    .iter()
                    .map(|ptr| unsafe { core::ptr::read_unaligned(ptr.as_non_null().as_ptr()) }
                        as usize)
                    .sum();
                
                #[allow(clippy::undocumented_unsafe_blocks, clippy::as_conversions)]
                
                let r_sum: usize = r
                    .iter()
                    .map(|ptr| unsafe { core::ptr::read_unaligned(ptr.as_non_null().as_ptr()) }
                        as usize)
                    .sum();
                assert_eq!(l_sum, i.get());
                assert_eq!(r_sum, n - i.get());
                assert_eq!(l_sum + r_sum, n);
            }
        }

        test_split_at::<0, 16>();
        test_split_at::<1, 17>();
        test_split_at::<2, 18>();
    }

    #[test]
    fn test_trailing_slice() {
        fn test_trailing_slice<const OFFSET: usize, const BUFFER_SIZE: usize>() {
            #[derive(FromBytes, KnownLayout, SplitAt, Immutable)]
            #[repr(C)]
            struct SliceDst<const OFFSET: usize> {
                prefix: [u8; OFFSET],
                trailing: [u8],
            }

            let n: usize = BUFFER_SIZE - OFFSET;
            let arr = [1; BUFFER_SIZE];
            let dst = SliceDst::<OFFSET>::ref_from_bytes(&arr[..]).unwrap();
            let ptr = PtrInner::from_ref(dst);

            assert_eq!(ptr.meta().get(), n);
            let trailing = ptr.trailing_slice();
            assert_eq!(trailing.meta().get(), n);

            assert_eq!(
                // SAFETY: We assume this to be sound for the sake of this test,
                // which will fail, here, in miri, if the safety precondition of
                // `offset_of` is not satisfied.
                unsafe {
                    #[allow(clippy::as_conversions)]
                    let offset = (trailing.as_non_null().as_ptr() as *mut u8)
                        .offset_from(ptr.as_non_null().as_ptr() as *mut _);
                    offset
                },
                isize::try_from(OFFSET).unwrap(),
            );

            
            #[allow(clippy::undocumented_unsafe_blocks, clippy::as_conversions)]
            
            let trailing: usize =
                trailing
                    .iter()
                    .map(|ptr| unsafe { core::ptr::read_unaligned(ptr.as_non_null().as_ptr()) }
                        as usize)
                    .sum();

            assert_eq!(trailing, n);
        }

        test_trailing_slice::<0, 16>();
        test_trailing_slice::<1, 17>();
        test_trailing_slice::<2, 18>();
    }
}
