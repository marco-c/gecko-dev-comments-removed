







#![allow(missing_copy_implementations, missing_debug_implementations)]







pub trait Invariants: Sealed {
    type Aliasing: Aliasing;
    type Alignment: Alignment;
    type Validity: Validity;
}

impl<A: Aliasing, AA: Alignment, V: Validity> Invariants for (A, AA, V) {
    type Aliasing = A;
    type Alignment = AA;
    type Validity = V;
}







pub trait Aliasing: Sealed {
    
    #[doc(hidden)]
    const IS_EXCLUSIVE: bool;
}


pub trait Alignment: Sealed {}











































pub unsafe trait Validity: Sealed {}







pub trait Reference: Aliasing + Sealed {}











pub enum Shared {}
impl Aliasing for Shared {
    const IS_EXCLUSIVE: bool = false;
}
impl Reference for Shared {}






pub enum Exclusive {}
impl Aliasing for Exclusive {
    const IS_EXCLUSIVE: bool = true;
}
impl Reference for Exclusive {}


pub enum Unaligned {}

impl Alignment for Unaligned {}



pub enum Aligned {}
impl Alignment for Aligned {}



pub enum Uninit {}




unsafe impl Validity for Uninit {}




























pub enum AsInitialized {}


unsafe impl Validity for AsInitialized {}



pub enum Initialized {}




unsafe impl Validity for Initialized {}



pub enum Valid {}


unsafe impl Validity for Valid {}





pub unsafe trait CastableFrom<ST: ?Sized, SV, DV> {}


unsafe impl<ST: ?Sized, DT: ?Sized> CastableFrom<ST, Uninit, Uninit> for DT {}

unsafe impl<ST: ?Sized, DT: ?Sized> CastableFrom<ST, Initialized, Initialized> for DT {}















pub trait Read<A: Aliasing, R> {}

impl<A: Aliasing, T: ?Sized + crate::Immutable> Read<A, BecauseImmutable> for T {}
impl<T: ?Sized> Read<Exclusive, BecauseExclusive> for T {}



#[derive(Copy, Clone, Debug)]
#[doc(hidden)]
pub enum BecauseExclusive {}



#[derive(Copy, Clone, Debug)]
#[doc(hidden)]
pub enum BecauseImmutable {}

use sealed::Sealed;
mod sealed {
    use super::*;

    pub trait Sealed {}

    impl Sealed for Shared {}
    impl Sealed for Exclusive {}

    impl Sealed for Unaligned {}
    impl Sealed for Aligned {}

    impl Sealed for Uninit {}
    impl Sealed for AsInitialized {}
    impl Sealed for Initialized {}
    impl Sealed for Valid {}

    impl<A: Sealed, AA: Sealed, V: Sealed> Sealed for (A, AA, V) {}

    impl Sealed for BecauseImmutable {}
    impl Sealed for BecauseExclusive {}
}
