




#![cfg_attr(not(any(test, doc)), no_std)]
#![cfg_attr(
    not(test),
    deny(
        clippy::indexing_slicing,
        clippy::unwrap_used,
        clippy::expect_used,
        clippy::panic,
        clippy::exhaustive_structs,
        clippy::exhaustive_enums,
        clippy::trivially_copy_pass_by_ref,
        missing_debug_implementations,
    )
)]



























































#[cfg(feature = "alloc")]
extern crate alloc;

mod cmp;
#[cfg(feature = "either")]
mod either;
mod impls;
mod ops;
mod parts_write_adapter;
#[cfg(feature = "alloc")]
mod testing;
#[cfg(feature = "alloc")]
mod to_string_or_borrow;
mod try_writeable;

#[cfg(feature = "alloc")]
use alloc::borrow::Cow;

#[cfg(feature = "alloc")]
use alloc::string::String;
use core::fmt;

pub use cmp::{cmp_str, cmp_utf8};
#[cfg(feature = "alloc")]
pub use to_string_or_borrow::to_string_or_borrow;
pub use try_writeable::TryWriteable;


pub mod adapters {
    use super::*;

    pub use parts_write_adapter::CoreWriteAsPartsWrite;
    pub use parts_write_adapter::WithPart;
    pub use try_writeable::TryWriteableInfallibleAsWriteable;
    pub use try_writeable::WriteableAsTryWriteableInfallible;

    #[derive(Debug)]
    #[allow(clippy::exhaustive_structs)] 
    pub struct LossyWrap<T>(pub T);

    impl<T: TryWriteable> Writeable for LossyWrap<T> {
        fn write_to<W: fmt::Write + ?Sized>(&self, sink: &mut W) -> fmt::Result {
            let _ = self.0.try_write_to(sink)?;
            Ok(())
        }

        fn writeable_length_hint(&self) -> LengthHint {
            self.0.writeable_length_hint()
        }
    }

    impl<T: TryWriteable> fmt::Display for LossyWrap<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let _ = self.0.try_write_to(f)?;
            Ok(())
        }
    }
}

#[doc(hidden)] 
pub mod _internal {
    #[cfg(feature = "alloc")]
    pub use super::testing::try_writeable_to_parts_for_test;
    #[cfg(feature = "alloc")]
    pub use super::testing::writeable_to_parts_for_test;
    #[cfg(feature = "alloc")]
    pub use alloc::string::String;
}











#[derive(Debug, PartialEq, Eq, Copy, Clone)]
#[non_exhaustive]
pub struct LengthHint(pub usize, pub Option<usize>);

impl LengthHint {
    pub fn undefined() -> Self {
        Self(0, None)
    }

    
    pub fn exact(n: usize) -> Self {
        Self(n, Some(n))
    }

    
    pub fn at_least(n: usize) -> Self {
        Self(n, None)
    }

    
    pub fn at_most(n: usize) -> Self {
        Self(0, Some(n))
    }

    
    pub fn between(n: usize, m: usize) -> Self {
        Self(Ord::min(n, m), Some(Ord::max(n, m)))
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    pub fn capacity(&self) -> usize {
        self.1.unwrap_or(self.0)
    }

    
    pub fn is_zero(&self) -> bool {
        self.1 == Some(0)
    }
}

























#[derive(Clone, Copy, Debug, PartialEq)]
#[allow(clippy::exhaustive_structs)] 
pub struct Part {
    pub category: &'static str,
    pub value: &'static str,
}

impl Part {
    
    
    
    pub const ERROR: Part = Part {
        category: "writeable",
        value: "error",
    };
}


pub trait PartsWrite: fmt::Write {
    type SubPartsWrite: PartsWrite + ?Sized;

    
    fn with_part(
        &mut self,
        part: Part,
        f: impl FnMut(&mut Self::SubPartsWrite) -> fmt::Result,
    ) -> fmt::Result;
}


pub trait Writeable {
    
    
    
    fn write_to<W: fmt::Write + ?Sized>(&self, sink: &mut W) -> fmt::Result {
        self.write_to_parts(&mut parts_write_adapter::CoreWriteAsPartsWrite(sink))
    }

    
    
    
    fn write_to_parts<S: PartsWrite + ?Sized>(&self, sink: &mut S) -> fmt::Result {
        self.write_to(sink)
    }

    
    
    
    fn writeable_length_hint(&self) -> LengthHint {
        LengthHint::undefined()
    }

    
    
    
    fn writeable_borrow(&self) -> Option<&str> {
        None
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[cfg(feature = "alloc")]
    fn write_to_string(&self) -> Cow<'_, str> {
        if let Some(borrow) = self.writeable_borrow() {
            return Cow::Borrowed(borrow);
        }
        let hint = self.writeable_length_hint();
        if hint.is_zero() {
            return Cow::Borrowed("");
        }
        let mut output = String::with_capacity(hint.capacity());
        let _ = self.write_to(&mut output);
        Cow::Owned(output)
    }
}










#[macro_export]
macro_rules! impl_display_with_writeable {
    (@display, $type:ty) => {
        /// This trait is implemented for compatibility with [`fmt!`](alloc::fmt).
        /// To create a string, [`Writeable::write_to_string`] is usually more efficient.
        impl core::fmt::Display for $type {
            #[inline]
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                $crate::Writeable::write_to(&self, f)
            }
        }
    };
    ($type:ty $(, #[$alloc_feature:meta])? ) => {
        $crate::impl_display_with_writeable!(@display, $type);
        $(#[$alloc_feature])?
        impl $type {
            /// Converts the given value to a `String`.
            ///
            /// Under the hood, this uses an efficient [`Writeable`] implementation.
            /// However, in order to avoid allocating a string, it is more efficient
            /// to use [`Writeable`] directly.
            pub fn to_string(&self) -> $crate::_internal::String {
                $crate::Writeable::write_to_string(self).into_owned()
            }
        }
    };
}





























































#[macro_export]
#[cfg(feature = "alloc")]
macro_rules! assert_writeable_eq {
    ($actual_writeable:expr, $expected_str:expr $(,)?) => {
        $crate::assert_writeable_eq!($actual_writeable, $expected_str, "")
    };
    ($actual_writeable:expr, $expected_str:expr, $($arg:tt)+) => {{
        $crate::assert_writeable_eq!(@internal, $actual_writeable, $expected_str, $($arg)*);
    }};
    (@internal, $actual_writeable:expr, $expected_str:expr, $($arg:tt)+) => {{
        let actual_writeable = &$actual_writeable;
        let (actual_str, actual_parts) = $crate::_internal::writeable_to_parts_for_test(actual_writeable);
        let actual_len = actual_str.len();
        assert_eq!(actual_str, $expected_str, $($arg)*);
        let cow = $crate::Writeable::write_to_string(actual_writeable);
        assert_eq!(actual_str, cow, $($arg)+);
        if let Some(borrowed) = ($crate::Writeable::writeable_borrow(&actual_writeable)) {
            assert_eq!(borrowed, $expected_str, $($arg)*);
            assert!(matches!(cow, std::borrow::Cow::Borrowed(_)), $($arg)*);
        }
        let length_hint = $crate::Writeable::writeable_length_hint(actual_writeable);
        let lower = length_hint.0;
        assert!(
            lower <= actual_len,
            "hint lower bound {lower} larger than actual length {actual_len}: {}",
            format!($($arg)*),
        );
        if let Some(upper) = length_hint.1 {
            assert!(
                actual_len <= upper,
                "hint upper bound {upper} smaller than actual length {actual_len}: {}",
                format!($($arg)*),
            );
        }
        assert_eq!(actual_writeable.to_string(), $expected_str, $($arg)*);
        actual_parts // return for assert_writeable_parts_eq
    }};
}


#[macro_export]
#[cfg(feature = "alloc")]
macro_rules! assert_writeable_parts_eq {
    ($actual_writeable:expr, $expected_str:expr, $expected_parts:expr $(,)?) => {
        $crate::assert_writeable_parts_eq!($actual_writeable, $expected_str, $expected_parts, "")
    };
    ($actual_writeable:expr, $expected_str:expr, $expected_parts:expr, $($arg:tt)+) => {{
        let actual_parts = $crate::assert_writeable_eq!(@internal, $actual_writeable, $expected_str, $($arg)*);
        assert_eq!(actual_parts, $expected_parts, $($arg)+);
    }};
}
