use core::ffi::c_void;
use objc2::rc::{Retained, Weak};
use objc2::runtime::{AnyClass, AnyObject};
use objc2::{define_class, msg_send, AllocAnyThread, ClassType, DefinedClass};
use objc2_foundation::{
    ns_string, NSDictionary, NSKeyValueChangeKey, NSKeyValueChangeNewKey,
    NSKeyValueObservingOptions, NSNumber, NSObjectNSKeyValueObserverRegistration, NSString,
    NSValue,
};
use objc2_quartz_core::{CALayer, CAMetalLayer};

define_class!(
    /// A `CAMetalLayer` layer that will automatically update its bounds and scale factor to match
    /// its super layer.
    ///
    /// We do this by subclassing, to allow the user to just store the layer as
    /// `Retained<CAMetalLayer>`, and still have our observers work.
    ///
    /// See the documentation on Key-Value Observing for details on how this works in general:
    /// <https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html>
    //
    // SAFETY:
    // - The superclass CAMetalLayer does not have any subclassing requirements.
    // - CustomLayer implements `Drop` and ensures that:
    //   - It does not call an overridden method.
    //   - It does not `retain` itself.
    #[unsafe(super(CAMetalLayer))]
    #[name = "RawWindowMetalLayer"]
    #[ivars = Weak<CALayer>]
    pub(crate) struct ObserverLayer;

    // `NSKeyValueObserving` category.
    //
    // SAFETY: The method is correctly defined.
    impl ObserverLayer {
        #[unsafe(method(observeValueForKeyPath:ofObject:change:context:))]
        fn _observe_value(
            &self,
            key_path: Option<&NSString>,
            object: Option<&AnyObject>,
            change: Option<&NSDictionary<NSKeyValueChangeKey, AnyObject>>,
            context: *mut c_void,
        ) {
            self.observe_value(key_path, object, change, context);
        }
    }
);

impl Drop for ObserverLayer {
    fn drop(&mut self) {
        
        
        
        
        
        
        if let Some(root_layer) = self.ivars().load() {
            
            unsafe {
                root_layer.removeObserver_forKeyPath(self, ns_string!("contentsScale"));
                root_layer.removeObserver_forKeyPath(self, ns_string!("bounds"));
            }
        }
    }
}

impl ObserverLayer {
    
    
    fn context() -> *mut c_void {
        ObserverLayer::class() as *const AnyClass as *mut c_void
    }

    
    pub fn new(root_layer: &CALayer) -> Retained<Self> {
        let this = Self::alloc().set_ivars(Weak::new(root_layer));
        
        let this: Retained<Self> = unsafe { msg_send![super(this), init] };

        
        root_layer.addSublayer(&this);

        
        
        
        
        
        
        
        
        
        

        
        
        
        
        
        
        
        
        
        
        
        
        
        unsafe {
            root_layer.addObserver_forKeyPath_options_context(
                &this,
                ns_string!("contentsScale"),
                NSKeyValueObservingOptions::New | NSKeyValueObservingOptions::Initial,
                ObserverLayer::context(),
            );
            root_layer.addObserver_forKeyPath_options_context(
                &this,
                ns_string!("bounds"),
                NSKeyValueObservingOptions::New | NSKeyValueObservingOptions::Initial,
                ObserverLayer::context(),
            );
        }

        
        
        
        
        
        
        
        

        this
    }

    fn observe_value(
        &self,
        key_path: Option<&NSString>,
        object: Option<&AnyObject>,
        change: Option<&NSDictionary<NSKeyValueChangeKey, AnyObject>>,
        context: *mut c_void,
    ) {
        
        if context != ObserverLayer::context() {
            
            
            return unsafe {
                msg_send![
                    super(self),
                    observeValueForKeyPath: key_path,
                    ofObject: object,
                    change: change,
                    context: context,
                ]
            };
        }

        let change =
            change.expect("requested a change dictionary in `addObserver`, but none was provided");
        
        let key = unsafe { NSKeyValueChangeNewKey };
        let new = change
            .objectForKey(key)
            .expect("requested change dictionary did not contain `NSKeyValueChangeNewKey`");

        
        
        
        
        

        if key_path == Some(ns_string!("contentsScale")) {
            
            let new = new.downcast::<NSNumber>().unwrap();
            let scale_factor = new.as_cgfloat();

            
            
            self.setContentsScale(scale_factor);
        } else if key_path == Some(ns_string!("bounds")) {
            
            let new = new.downcast::<NSValue>().unwrap();
            let bounds = new.get_rect().expect("new bounds value was not CGRect");

            
            
            
            
            self.setFrame(bounds);
        } else {
            panic!("unknown observed keypath {key_path:?}");
        }
    }
}

#[cfg(test)]
mod tests {
    use objc2_core_foundation::{CGPoint, CGRect, CGSize};

    use super::*;

    #[test]
    fn release_order_does_not_matter() {
        let root_layer = CALayer::new();
        let layer = ObserverLayer::new(&root_layer);
        drop(root_layer);
        drop(layer);

        let root_layer = CALayer::new();
        let layer = ObserverLayer::new(&root_layer);
        drop(layer);
        drop(root_layer);
    }

    #[test]
    fn scale_factor_propagates() {
        let root_layer = CALayer::new();
        let layer = ObserverLayer::new(&root_layer);

        root_layer.setContentsScale(3.0);
        assert_eq!(layer.contentsScale(), 3.0);
    }

    #[test]
    fn bounds_propagates() {
        let root_layer = CALayer::new();
        let layer = ObserverLayer::new(&root_layer);

        root_layer.setBounds(CGRect::new(
            CGPoint::new(10.0, 20.0),
            CGSize::new(30.0, 40.0),
        ));
        assert_eq!(layer.position(), CGPoint::new(25.0, 40.0));
        assert_eq!(
            layer.bounds(),
            CGRect::new(CGPoint::new(0.0, 0.0), CGSize::new(30.0, 40.0),)
        );
    }

    #[test]
    fn superlayer_can_remove_all_sublayers() {
        let root_layer = CALayer::new();
        let layer = ObserverLayer::new(&root_layer);
        layer.removeFromSuperlayer();
        drop(layer);
        root_layer.setContentsScale(3.0);
    }
}
