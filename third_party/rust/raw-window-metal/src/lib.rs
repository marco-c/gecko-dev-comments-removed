































































































































#![no_std]
#![cfg(target_vendor = "apple")]
#![cfg_attr(docsrs, feature(doc_auto_cfg, doc_cfg_hide), doc(cfg_hide(doc)))]
#![deny(unsafe_op_in_unsafe_fn)]
#![warn(clippy::undocumented_unsafe_blocks)]

#![doc(html_root_url = "https://docs.rs/raw-window-metal/1.1.0")]

mod observer;

use core::ffi::{c_void, CStr};
use core::hash;
use core::panic::{RefUnwindSafe, UnwindSafe};
use core::ptr::NonNull;

use objc2::rc::Retained;
use objc2::runtime::AnyClass;
use objc2::{msg_send, ClassType, MainThreadMarker, Message};
use objc2_foundation::{NSObject, NSObjectProtocol};
use objc2_quartz_core::{CALayer, CAMetalLayer};

use crate::observer::ObserverLayer;

#[cfg(not(feature = "alloc"))]
compile_error!("The `alloc` feature must currently be enabled.");

#[cfg(not(feature = "std"))]
compile_error!("The `std` feature must currently be enabled.");


#[doc(alias = "CAMetalLayer")]
#[derive(Debug, Clone)]
pub struct Layer {
    layer: Retained<CAMetalLayer>,
    pre_existing: bool,
}

impl PartialEq for Layer {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.layer.eq(&other.layer)
    }
}

impl Eq for Layer {}

impl hash::Hash for Layer {
    #[inline]
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.layer.hash(state);
    }
}






unsafe impl Send for Layer {}

unsafe impl Sync for Layer {}




impl UnwindSafe for Layer {}
impl RefUnwindSafe for Layer {}

impl Layer {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    pub fn as_ptr(&self) -> NonNull<c_void> {
        let ptr: *const CAMetalLayer = Retained::as_ptr(&self.layer);
        
        NonNull::new(ptr as *mut _).unwrap()
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    pub fn into_raw(self) -> NonNull<c_void> {
        
        NonNull::new(Retained::into_raw(self.layer).cast()).unwrap()
    }

    
    
    
    
    
    
    
    
    #[inline]
    pub fn pre_existing(&self) -> bool {
        self.pre_existing
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub unsafe fn from_ca_layer(layer_ptr: NonNull<c_void>) -> Self {
        
        let root_layer: &CALayer = unsafe { layer_ptr.cast().as_ref() };

        
        if cfg!(debug_assertions) {
            assert!(
                root_layer.isKindOfClass(CALayer::class()),
                "view was not a valid CALayer"
            );
        }

        if let Some(layer) = root_layer.downcast_ref::<CAMetalLayer>() {
            Layer {
                layer: layer.retain(),
                pre_existing: true,
            }
        } else {
            let layer = ObserverLayer::new(root_layer);
            Layer {
                layer: layer.into_super(),
                pre_existing: false,
            }
        }
    }

    fn from_retained_layer(root_layer: Retained<CALayer>) -> Self {
        match root_layer.downcast::<CAMetalLayer>() {
            Ok(layer) => Layer {
                layer,
                pre_existing: true,
            },
            Err(root_layer) => {
                let layer = ObserverLayer::new(&root_layer);
                Layer {
                    layer: layer.into_super(),
                    pre_existing: false,
                }
            }
        }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub unsafe fn from_ns_view(ns_view_ptr: NonNull<c_void>) -> Self {
        let _mtm = MainThreadMarker::new().expect("can only access NSView on the main thread");

        
        
        
        let ns_view: &NSObject = unsafe { ns_view_ptr.cast().as_ref() };

        
        if cfg!(debug_assertions) {
            
            
            let cls = AnyClass::get(CStr::from_bytes_with_nul(b"NSView\0").unwrap()).unwrap();
            assert!(ns_view.isKindOfClass(cls), "view was not a valid NSView");
        }

        
        
        let _: () = unsafe { msg_send![ns_view, setWantsLayer: true] };

        
        let root_layer: Option<Retained<CALayer>> = unsafe { msg_send![ns_view, layer] };
        let root_layer = root_layer.expect("failed making the view layer-backed");

        Self::from_retained_layer(root_layer)
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub unsafe fn from_ui_view(ui_view_ptr: NonNull<c_void>) -> Self {
        let _mtm = MainThreadMarker::new().expect("can only access UIView on the main thread");

        
        
        
        let ui_view: &NSObject = unsafe { ui_view_ptr.cast().as_ref() };

        
        if cfg!(debug_assertions) {
            
            
            let cls = AnyClass::get(CStr::from_bytes_with_nul(b"UIView\0").unwrap()).unwrap();
            assert!(ui_view.isKindOfClass(cls), "view was not a valid UIView");
        }

        
        let root_layer: Retained<CALayer> = unsafe { msg_send![ui_view, layer] };

        
        
        Self::from_retained_layer(root_layer)
    }
}
