



use icu_normalizer::{ComposingNormalizerBorrowed, DecomposingNormalizerBorrowed};

use criterion::{black_box, Criterion, Throughput};

use smallvec::SmallVec;





const INPUT_SIZE: usize = 2048;

fn generate_bmp_input_nfc(s: &str) -> Vec<u16> {
    ComposingNormalizerBorrowed::new_nfc()
        .normalize_iter(s.chars().cycle())
        .take(INPUT_SIZE)
        .map(|c| {
            if c <= '\u{FFFF}' {
                c as u16
            } else {
                unreachable!("Data should stay on the BMP!")
            }
        })
        .collect()
}

fn generate_bmp_input_nfd(s: &str) -> Vec<u16> {
    DecomposingNormalizerBorrowed::new_nfd()
        .normalize_iter(s.chars().cycle())
        .take(INPUT_SIZE)
        .map(|c| {
            if c <= '\u{FFFF}' {
                c as u16
            } else {
                unreachable!("Data should stay on the BMP!")
            }
        })
        .collect()
}



fn prepare_file_contents(content: &str) -> String {
    content
        .lines()
        .filter(|&s| !s.starts_with('#'))
        .map(|s| s.to_owned())
        .collect::<Vec<String>>()
        .join(" ")
}

fn slice_as_slice(s: &[u16]) -> &[u16] {
    black_box(s)
}

fn bench_lang(name: &str, data: &str, c: &mut Criterion) {
    let input_nfc = generate_bmp_input_nfc(data);
    let input_nfd = generate_bmp_input_nfd(data);
    let nfc = ComposingNormalizerBorrowed::new_nfc();
    let nfd = DecomposingNormalizerBorrowed::new_nfd();

    
    
    
    let mut output: SmallVec<[u16; INPUT_SIZE * 2]> = SmallVec::new();
    {
        let mut group_name = "utf16_throughput_nfc_".to_string();
        group_name.push_str(name);

        let mut group = c.benchmark_group(&group_name);
        group.throughput(Throughput::Elements(input_nfc.len() as u64));

        group.bench_function("read", |b| {
            b.iter(|| {
                let _ = black_box(
                    nfc.split_normalized_utf16(slice_as_slice(&input_nfc))
                        .0
                        .len(),
                );
            })
        });

        group.bench_function("writing_to_nfc", |b| {
            b.iter(|| {
                output.clear(); 
                let _ = black_box(
                    nfc.normalize_utf16_to(slice_as_slice(&input_nfc), black_box(&mut output)),
                );
            })
        });
        group.bench_function("writing_to_nfd", |b| {
            b.iter(|| {
                output.clear(); 
                let _ = black_box(
                    nfd.normalize_utf16_to(slice_as_slice(&input_nfc), black_box(&mut output)),
                );
            })
        });
        group.finish();
    }
    {
        let mut group_name = "utf16_throughput_nfd_".to_string();
        group_name.push_str(name);

        let mut group = c.benchmark_group(&group_name);
        group.throughput(Throughput::Elements(input_nfd.len() as u64));

        group.bench_function("read", |b| {
            b.iter(|| {
                let _ = black_box(
                    nfd.split_normalized_utf16(slice_as_slice(&input_nfd))
                        .0
                        .len(),
                );
            })
        });

        group.bench_function("writing_to_nfd", |b| {
            b.iter(|| {
                output.clear(); 
                let _ = black_box(
                    nfd.normalize_utf16_to(slice_as_slice(&input_nfd), black_box(&mut output)),
                );
            })
        });
        group.bench_function("writing_to_nfc", |b| {
            b.iter(|| {
                output.clear(); 
                let _ = black_box(
                    nfc.normalize_utf16_to(slice_as_slice(&input_nfd), black_box(&mut output)),
                );
            })
        });
        group.finish();
    }
}

static EL: &str = include_str!("./data/TestRandomWordsUDHR_el.txt");
static EN: &str = "The ICU4X normalizer is an implementation of Unicode Normalization Forms. ";
static FR: &str = include_str!("./data/TestRandomWordsUDHR_fr.txt");
static VI: &str = include_str!("./data/wotw.txt");
static ZH: &str = "單父人呂公善沛令，辟仇，從之客，因家焉。沛中豪傑吏聞令有重客，皆往賀。";

















pub fn criterion_benchmark(c: &mut Criterion) {
    bench_lang("el", prepare_file_contents(EL).as_str(), c);
    bench_lang("en", EN, c);
    bench_lang("fr", prepare_file_contents(FR).as_str(), c);
    bench_lang("vi", prepare_file_contents(VI).as_str(), c);
    bench_lang("zh", ZH, c);
}
