



use crate::codepointtrie::error::Error;
use crate::codepointtrie::impl_const::*;

#[cfg(feature = "alloc")]
use crate::codepointinvlist::CodePointInversionList;
use core::char::CharTryFromError;
use core::convert::Infallible;
use core::convert::TryFrom;
use core::fmt::Display;
#[cfg(feature = "alloc")]
use core::iter::FromIterator;
use core::num::TryFromIntError;
use core::ops::RangeInclusive;
use yoke::Yokeable;
use zerofrom::ZeroFrom;
use zerovec::ule::AsULE;
#[cfg(feature = "alloc")]
use zerovec::ule::UleError;
use zerovec::ZeroSlice;
use zerovec::ZeroVec;

















#[derive(Clone, Copy, PartialEq, Debug, Eq)]
#[cfg_attr(feature = "serde", derive(serde::Deserialize, serde::Serialize))]
#[cfg_attr(feature = "databake", derive(databake::Bake))]
#[cfg_attr(feature = "databake", databake(path = icu_collections::codepointtrie))]
pub enum TrieType {
    
    
    Fast = 0,
    
    
    Small = 1,
}









pub trait TrieValue: Copy + Eq + PartialEq + zerovec::ule::AsULE + 'static {
    
    
    
    
    
    type TryFromU32Error: Display;
    
    
    
    fn try_from_u32(i: u32) -> Result<Self, Self::TryFromU32Error>;

    
    
    
    
    
    
    fn to_u32(self) -> u32;
}

macro_rules! impl_primitive_trie_value {
    ($primitive:ty, $error:ty) => {
        impl TrieValue for $primitive {
            type TryFromU32Error = $error;
            fn try_from_u32(i: u32) -> Result<Self, Self::TryFromU32Error> {
                Self::try_from(i)
            }

            fn to_u32(self) -> u32 {
                // bitcast when the same size, zero-extend/sign-extend
                // when not the same size
                self as u32
            }
        }
    };
}

impl_primitive_trie_value!(u8, TryFromIntError);
impl_primitive_trie_value!(u16, TryFromIntError);
impl_primitive_trie_value!(u32, Infallible);
impl_primitive_trie_value!(i8, TryFromIntError);
impl_primitive_trie_value!(i16, TryFromIntError);
impl_primitive_trie_value!(i32, TryFromIntError);
impl_primitive_trie_value!(char, CharTryFromError);









fn maybe_filter_value<T: TrieValue>(value: T, trie_null_value: T, null_value: T) -> T {
    if value == trie_null_value {
        null_value
    } else {
        value
    }
}








#[derive(Debug, Eq, PartialEq, Yokeable, ZeroFrom)]
pub struct CodePointTrie<'trie, T: TrieValue> {
    
    
    
    pub(crate) header: CodePointTrieHeader,
    
    
    
    
    
    
    
    
    pub(crate) index: ZeroVec<'trie, u16>,
    
    
    
    
    
    
    
    
    
    pub(crate) data: ZeroVec<'trie, T>,
    
    #[zerofrom(clone)] 
    
    pub(crate) error_value: T,
}









#[cfg_attr(feature = "serde", derive(serde::Deserialize, serde::Serialize))]
#[cfg_attr(feature = "databake", derive(databake::Bake))]
#[cfg_attr(feature = "databake", databake(path = icu_collections::codepointtrie))]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Yokeable, ZeroFrom)]
pub struct CodePointTrieHeader {
    
    
    
    
    
    
    
    
    
    
    
    pub high_start: u32,
    
    
    
    pub shifted12_high_start: u16,
    
    
    
    pub index3_null_offset: u16,
    
    
    
    pub data_null_offset: u32,
    
    
    pub null_value: u32,
    
    
    
    
    
    
    pub trie_type: TrieType,
}

impl TryFrom<u8> for TrieType {
    type Error = crate::codepointtrie::error::Error;

    fn try_from(trie_type_int: u8) -> Result<TrieType, crate::codepointtrie::error::Error> {
        match trie_type_int {
            0 => Ok(TrieType::Fast),
            1 => Ok(TrieType::Small),
            _ => Err(crate::codepointtrie::error::Error::FromDeserialized {
                reason: "Cannot parse value for trie_type",
            }),
        }
    }
}








macro_rules! w(
    
    
    ($a:tt + $b:expr) => {
        {
            #[allow(unused_parens)]
            let a = $a;
            let b = $b;
            debug_assert!(a.checked_add(b).is_some());
            $a.wrapping_add($b)
        }
    };
    ($a:tt - $b:expr) => {

        {
            #[allow(unused_parens)]
            let a = $a;
            let b = $b;
            debug_assert!(a.checked_sub(b).is_some());
            $a.wrapping_sub($b)
        }
    };
    ($a:tt * $b:expr) => {
        {
            #[allow(unused_parens)]
            let a = $a;
            let b = $b;
            debug_assert!(a.checked_mul(b).is_some());
            $a.wrapping_mul($b)
        }
    };
);

impl<'trie, T: TrieValue> CodePointTrie<'trie, T> {
    #[doc(hidden)] 
    
    
    
    
    
    pub const unsafe fn from_parts_unstable_unchecked_v1(
        header: CodePointTrieHeader,
        index: ZeroVec<'trie, u16>,
        data: ZeroVec<'trie, T>,
        error_value: T,
    ) -> Self {
        
        
        
        
        Self {
            header,
            index,
            data,
            error_value,
        }
    }

    
    
    pub fn try_new(
        header: CodePointTrieHeader,
        index: ZeroVec<'trie, u16>,
        data: ZeroVec<'trie, T>,
    ) -> Result<CodePointTrie<'trie, T>, Error> {
        let error_value = Self::validate_fields(&header, &index, &data)?;
        
        let trie: CodePointTrie<'trie, T> = CodePointTrie {
            header,
            index,
            data,
            error_value,
        };
        Ok(trie)
    }

    
    
    
    
    
    
    
    
    
    pub(crate) fn validate_fields(
        header: &CodePointTrieHeader,
        index: &ZeroSlice<u16>,
        data: &ZeroSlice<T>,
    ) -> Result<T, Error> {
        let error_value = data.last().ok_or(Error::EmptyDataVector)?;

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

        
        let fast_max = match header.trie_type {
            TrieType::Fast => FAST_TYPE_FAST_INDEXING_MAX,
            TrieType::Small => SMALL_TYPE_FAST_INDEXING_MAX,
        };
        
        let max_bit_prefix = fast_max >> FAST_TYPE_SHIFT;
        
        
        
        
        let fast_index = index
            .get_subslice(0..(max_bit_prefix as usize) + 1)
            .ok_or(Error::IndexTooShortForFastAccess)?;
        
        
        

        
        
        
        
        let max_offset = fast_index
            .iter()
            .max()
            .ok_or(Error::IndexTooShortForFastAccess)?;
        
        
        
        if (max_offset) as usize + (FAST_TYPE_DATA_MASK as usize) >= data.len() {
            return Err(Error::DataTooShortForFastAccess);
        }

        
        
        
        

        Ok(error_value)
    }

    
    #[inline]
    pub fn to_typed(self) -> Typed<FastCodePointTrie<'trie, T>, SmallCodePointTrie<'trie, T>> {
        match self.header.trie_type {
            TrieType::Fast => Typed::Fast(FastCodePointTrie { inner: self }),
            TrieType::Small => Typed::Small(SmallCodePointTrie { inner: self }),
        }
    }

    
    #[inline]
    pub fn as_typed_ref(
        &self,
    ) -> Typed<&FastCodePointTrie<'trie, T>, &SmallCodePointTrie<'trie, T>> {
        
        
        
        match self.header.trie_type {
            TrieType::Fast => Typed::Fast(unsafe {
                core::mem::transmute::<&CodePointTrie<'trie, T>, &FastCodePointTrie<'trie, T>>(self)
            }),
            TrieType::Small => Typed::Small(unsafe {
                core::mem::transmute::<&CodePointTrie<'trie, T>, &SmallCodePointTrie<'trie, T>>(
                    self,
                )
            }),
        }
    }

    
    
    #[inline(always)] 
    fn trie_error_val_index(&self) -> u32 {
        
        
        
        debug_assert!(self.data.len() as u32 >= ERROR_VALUE_NEG_DATA_OFFSET);
        w!((self.data.len() as u32) - ERROR_VALUE_NEG_DATA_OFFSET)
    }

    fn internal_small_index(&self, code_point: u32) -> u32 {
        
        
        
        let mut index1_pos: u32 = code_point >> SHIFT_1;
        if self.header.trie_type == TrieType::Fast {
            debug_assert!(
                FAST_TYPE_FAST_INDEXING_MAX < code_point && code_point < self.header.high_start
            );
            index1_pos = w!(index1_pos + BMP_INDEX_LENGTH - OMITTED_BMP_INDEX_1_LENGTH);
        } else {
            assert!(code_point < self.header.high_start && self.header.high_start > SMALL_LIMIT);
            index1_pos = w!(index1_pos + SMALL_INDEX_LENGTH);
        }
        let index1_val = if let Some(index1_val) = self.index.get(index1_pos as usize) {
            index1_val
        } else {
            return self.trie_error_val_index();
        };
        let index3_block_idx: u32 =
            w!((index1_val as u32) + (code_point >> SHIFT_2) & INDEX_2_MASK);
        let mut index3_block: u32 =
            if let Some(index3_block) = self.index.get(index3_block_idx as usize) {
                index3_block as u32
            } else {
                return self.trie_error_val_index();
            };
        let mut index3_pos: u32 = (code_point >> SHIFT_3) & INDEX_3_MASK;
        let mut data_block: u32;
        if index3_block & 0x8000 == 0 {
            
            data_block =
                if let Some(data_block) = self.index.get(w!(index3_block + index3_pos) as usize) {
                    data_block as u32
                } else {
                    return self.trie_error_val_index();
                };
        } else {
            
            index3_block = w!((index3_block & 0x7fff) + w!((index3_pos & !7) + index3_pos >> 3));
            index3_pos &= 7;
            data_block = if let Some(data_block) = self.index.get(index3_block as usize) {
                data_block as u32
            } else {
                return self.trie_error_val_index();
            };
            data_block = (data_block << w!(2u32 + w!(2u32 * index3_pos))) & 0x30000;
            index3_block += 1;
            data_block =
                if let Some(index3_val) = self.index.get(w!(index3_block + index3_pos) as usize) {
                    data_block | (index3_val as u32)
                } else {
                    return self.trie_error_val_index();
                };
        }
        
        
        w!(data_block + code_point & SMALL_DATA_MASK)
    }

    
    
    
    
    
    
    
    
    
    
    fn small_index(&self, code_point: u32) -> u32 {
        if code_point >= self.header.high_start {
            w!((self.data.len() as u32) - HIGH_VALUE_NEG_DATA_OFFSET)
        } else {
            self.internal_small_index(code_point) 
        }
    }

    
    
    
    
    
    
    
    
    
    
    
    fn fast_index(&self, code_point: u32) -> u32 {
        let index_array_pos: u32 = code_point >> FAST_TYPE_SHIFT;
        let index_array_val: u16 =
            if let Some(index_array_val) = self.index.get(index_array_pos as usize) {
                index_array_val
            } else {
                return self.trie_error_val_index();
            };
        let masked_cp = code_point & FAST_TYPE_DATA_MASK;
        let index_array_val = index_array_val as u32;
        let fast_index_val: u32 = w!(index_array_val + masked_cp);
        fast_index_val
    }

    
    
    
    #[inline(always)] 
    fn get32_by_fast_index(&self, code_point: u32) -> Option<T> {
        let fast_max = match self.header.trie_type {
            TrieType::Fast => FAST_TYPE_FAST_INDEXING_MAX,
            TrieType::Small => SMALL_TYPE_FAST_INDEXING_MAX,
        };
        if code_point <= fast_max {
            
            
            
            
            
            
            Some(unsafe { self.get32_assuming_fast_index(code_point) })
        } else {
            
            
            None
        }
    }

    
    
    
    
    
    
    
    #[inline(always)]
    unsafe fn get32_assuming_fast_index(&self, code_point: u32) -> T {
        
        debug_assert!(
            code_point
                <= match self.header.trie_type {
                    TrieType::Fast => FAST_TYPE_FAST_INDEXING_MAX,
                    TrieType::Small => SMALL_TYPE_FAST_INDEXING_MAX,
                }
        );

        let bit_prefix = (code_point as usize) >> FAST_TYPE_SHIFT;
        debug_assert!(bit_prefix < self.index.len());
        
        
        
        let base_offset_to_data: usize = usize::from(u16::from_unaligned(*unsafe {
            self.index.as_ule_slice().get_unchecked(bit_prefix)
        }));
        let bit_suffix = (code_point & FAST_TYPE_DATA_MASK) as usize;
        
        
        
        
        
        let offset_to_data = w!(base_offset_to_data + bit_suffix);
        debug_assert!(offset_to_data < self.data.len());
        
        
        
        T::from_unaligned(*unsafe { self.data.as_ule_slice().get_unchecked(offset_to_data) })
    }

    
    
    #[cold]
    #[inline(always)]
    fn get32_by_small_index_cold(&self, code_point: u32) -> T {
        self.get32_by_small_index(code_point)
    }

    
    
    
    
    
    
    
    
    
    
    
    
    #[inline(never)]
    fn get32_by_small_index(&self, code_point: u32) -> T {
        debug_assert!(code_point <= CODE_POINT_MAX);
        debug_assert!(
            code_point
                > match self.header.trie_type {
                    TrieType::Fast => FAST_TYPE_FAST_INDEXING_MAX,
                    TrieType::Small => SMALL_TYPE_FAST_INDEXING_MAX,
                }
        );
        self.data
            .get(self.small_index(code_point) as usize)
            .unwrap_or(self.error_value)
    }

    
    
    
    
    
    
    
    
    
    
    
    
    #[inline(always)] 
    pub fn get32(&self, code_point: u32) -> T {
        if let Some(v) = self.get32_by_fast_index(code_point) {
            v
        } else if code_point <= CODE_POINT_MAX {
            self.get32_by_small_index_cold(code_point)
        } else {
            self.error_value
        }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    #[inline(always)]
    pub fn get(&self, c: char) -> T {
        
        
        
        let code_point = u32::from(c);
        if let Some(v) = self.get32_by_fast_index(code_point) {
            v
        } else {
            self.get32_by_small_index_cold(code_point)
        }
    }

    
    #[inline(always)]
    pub fn get16(&self, bmp: u16) -> T {
        
        
        
        let code_point = u32::from(bmp);
        if let Some(v) = self.get32_by_fast_index(code_point) {
            v
        } else {
            self.get32_by_small_index_cold(code_point)
        }
    }

    
    
    
    
    
    #[inline(always)]
    pub fn get32_supplementary(&self, supplementary: u32) -> T {
        debug_assert!(supplementary > 0xFFFF);
        debug_assert!(supplementary <= CODE_POINT_MAX);
        self.get32_by_small_index(supplementary)
    }

    
    
    
    
    
    
    
    
    
    
    
    
    #[inline(always)] 
    pub fn get32_ule(&self, code_point: u32) -> Option<&T::ULE> {
        
        
        
        
        let fast_max = match self.header.trie_type {
            TrieType::Fast => FAST_TYPE_FAST_INDEXING_MAX,
            TrieType::Small => SMALL_TYPE_FAST_INDEXING_MAX,
        };
        let data_pos: u32 = if code_point <= fast_max {
            Self::fast_index(self, code_point)
        } else if code_point <= CODE_POINT_MAX {
            Self::small_index(self, code_point)
        } else {
            self.trie_error_val_index()
        };
        
        self.data.as_ule_slice().get(data_pos as usize)
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[cfg(feature = "alloc")]
    pub fn try_into_converted<P>(self) -> Result<CodePointTrie<'trie, P>, UleError>
    where
        P: TrieValue,
    {
        let converted_data = self.data.try_into_converted()?;
        let error_ule = self.error_value.to_unaligned();
        let slice = &[error_ule];
        let error_vec = ZeroVec::<T>::new_borrowed(slice);
        let error_converted = error_vec.try_into_converted::<P>()?;
        #[expect(clippy::expect_used)] 
        Ok(CodePointTrie {
            header: self.header,
            index: self.index,
            data: converted_data,
            error_value: error_converted
                .get(0)
                .expect("vector known to have one element"),
        })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[cfg(feature = "alloc")]
    pub fn try_alloc_map_value<P, E>(
        &self,
        mut f: impl FnMut(T) -> Result<P, E>,
    ) -> Result<CodePointTrie<'trie, P>, E>
    where
        P: TrieValue,
    {
        let error_converted = f(self.error_value)?;
        let converted_data = self.data.iter().map(f).collect::<Result<ZeroVec<P>, E>>()?;
        Ok(CodePointTrie {
            header: self.header,
            index: self.index.clone(),
            data: converted_data,
            error_value: error_converted,
        })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub fn get_range(&self, start: u32) -> Option<CodePointMapRange<T>> {
        
        
        
        if CODE_POINT_MAX < start {
            return None;
        }
        if start >= self.header.high_start {
            let di: usize = self.data.len() - (HIGH_VALUE_NEG_DATA_OFFSET as usize);
            let value: T = self.data.get(di)?;
            return Some(CodePointMapRange {
                range: start..=CODE_POINT_MAX,
                value,
            });
        }

        let null_value: T = T::try_from_u32(self.header.null_value).ok()?;

        let mut prev_i3_block: u32 = u32::MAX; 
        let mut prev_block: u32 = u32::MAX; 
        let mut c: u32 = start;
        let mut trie_value: T = self.error_value();
        let mut value: T = self.error_value();
        let mut have_value: bool = false;

        loop {
            let i3_block: u32;
            let mut i3: u32;
            let i3_block_length: u32;
            let data_block_length: u32;

            
            
            
            
            
            
            
            
            
            
            
            
            if c <= 0xffff
                && (self.header.trie_type == TrieType::Fast || c <= SMALL_TYPE_FAST_INDEXING_MAX)
            {
                i3_block = 0;
                i3 = c >> FAST_TYPE_SHIFT;
                i3_block_length = if self.header.trie_type == TrieType::Fast {
                    BMP_INDEX_LENGTH
                } else {
                    SMALL_INDEX_LENGTH
                };
                data_block_length = FAST_TYPE_DATA_BLOCK_LENGTH;
            } else {
                
                let mut i1: u32 = c >> SHIFT_1;
                if self.header.trie_type == TrieType::Fast {
                    debug_assert!(0xffff < c && c < self.header.high_start);
                    i1 = i1 + BMP_INDEX_LENGTH - OMITTED_BMP_INDEX_1_LENGTH;
                } else {
                    debug_assert!(
                        c < self.header.high_start && self.header.high_start > SMALL_LIMIT
                    );
                    i1 += SMALL_INDEX_LENGTH;
                }
                let i2: u16 = self.index.get(i1 as usize)?;
                let i3_block_idx: u32 = (i2 as u32) + ((c >> SHIFT_2) & INDEX_2_MASK);
                i3_block = if let Some(i3b) = self.index.get(i3_block_idx as usize) {
                    i3b as u32
                } else {
                    return None;
                };
                if i3_block == prev_i3_block && (c - start) >= CP_PER_INDEX_2_ENTRY {
                    
                    debug_assert!((c & (CP_PER_INDEX_2_ENTRY - 1)) == 0);
                    c += CP_PER_INDEX_2_ENTRY;

                    if c >= self.header.high_start {
                        break;
                    } else {
                        continue;
                    }
                }
                prev_i3_block = i3_block;
                if i3_block == self.header.index3_null_offset as u32 {
                    
                    
                    
                    
                    
                    
                    if have_value {
                        if null_value != value {
                            return Some(CodePointMapRange {
                                range: start..=(c - 1),
                                value,
                            });
                        }
                    } else {
                        trie_value = T::try_from_u32(self.header.null_value).ok()?;
                        value = null_value;
                        have_value = true;
                    }
                    prev_block = self.header.data_null_offset;
                    c = (c + CP_PER_INDEX_2_ENTRY) & !(CP_PER_INDEX_2_ENTRY - 1);

                    if c >= self.header.high_start {
                        break;
                    } else {
                        continue;
                    }
                }
                i3 = (c >> SHIFT_3) & INDEX_3_MASK;
                i3_block_length = INDEX_3_BLOCK_LENGTH;
                data_block_length = SMALL_DATA_BLOCK_LENGTH;
            }

            
            loop {
                let mut block: u32;
                if (i3_block & 0x8000) == 0 {
                    block = if let Some(b) = self.index.get((i3_block + i3) as usize) {
                        b as u32
                    } else {
                        return None;
                    };
                } else {
                    
                    let mut group: u32 = (i3_block & 0x7fff) + (i3 & !7) + (i3 >> 3);
                    let gi: u32 = i3 & 7;
                    let gi_val: u32 = if let Some(giv) = self.index.get(group as usize) {
                        giv.into()
                    } else {
                        return None;
                    };
                    block = (gi_val << (2 + (2 * gi))) & 0x30000;
                    group += 1;
                    let ggi_val: u32 = if let Some(ggiv) = self.index.get((group + gi) as usize) {
                        ggiv as u32
                    } else {
                        return None;
                    };
                    block |= ggi_val;
                }

                
                
                
                
                
                
                
                if block == prev_block && (c - start) >= data_block_length {
                    
                    debug_assert!((c & (data_block_length - 1)) == 0);
                    c += data_block_length;
                } else {
                    let data_mask: u32 = data_block_length - 1;
                    prev_block = block;
                    if block == self.header.data_null_offset {
                        
                        
                        
                        
                        if have_value {
                            if null_value != value {
                                return Some(CodePointMapRange {
                                    range: start..=(c - 1),
                                    value,
                                });
                            }
                        } else {
                            trie_value = T::try_from_u32(self.header.null_value).ok()?;
                            value = null_value;
                            have_value = true;
                        }
                        c = (c + data_block_length) & !data_mask;
                    } else {
                        let mut di: u32 = block + (c & data_mask);
                        let mut trie_value_2: T = self.data.get(di as usize)?;
                        if have_value {
                            if trie_value_2 != trie_value {
                                if maybe_filter_value(
                                    trie_value_2,
                                    T::try_from_u32(self.header.null_value).ok()?,
                                    null_value,
                                ) != value
                                {
                                    return Some(CodePointMapRange {
                                        range: start..=(c - 1),
                                        value,
                                    });
                                }
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                trie_value = trie_value_2; 
                            }
                        } else {
                            trie_value = trie_value_2;
                            value = maybe_filter_value(
                                trie_value_2,
                                T::try_from_u32(self.header.null_value).ok()?,
                                null_value,
                            );
                            have_value = true;
                        }

                        c += 1;
                        while (c & data_mask) != 0 {
                            di += 1;
                            trie_value_2 = self.data.get(di as usize)?;
                            if trie_value_2 != trie_value {
                                if maybe_filter_value(
                                    trie_value_2,
                                    T::try_from_u32(self.header.null_value).ok()?,
                                    null_value,
                                ) != value
                                {
                                    return Some(CodePointMapRange {
                                        range: start..=(c - 1),
                                        value,
                                    });
                                }
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                trie_value = trie_value_2; 
                            }

                            c += 1;
                        }
                    }
                }

                i3 += 1;
                if i3 >= i3_block_length {
                    break;
                }
            }

            if c >= self.header.high_start {
                break;
            }
        }

        debug_assert!(have_value);

        
        
        
        
        let di: u32 = self.data.len() as u32 - HIGH_VALUE_NEG_DATA_OFFSET;
        let high_value: T = self.data.get(di as usize)?;
        if maybe_filter_value(
            high_value,
            T::try_from_u32(self.header.null_value).ok()?,
            null_value,
        ) != value
        {
            c -= 1;
        } else {
            c = CODE_POINT_MAX;
        }
        Some(CodePointMapRange {
            range: start..=c,
            value,
        })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub fn iter_ranges(&self) -> CodePointMapRangeIterator<'_, T> {
        let init_range = Some(CodePointMapRange {
            range: u32::MAX..=u32::MAX,
            value: self.error_value(),
        });
        CodePointMapRangeIterator::<T> {
            cpt: self,
            cpm_range: init_range,
        }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub fn iter_ranges_for_value(
        &self,
        value: T,
    ) -> impl Iterator<Item = RangeInclusive<u32>> + '_ {
        self.iter_ranges()
            .filter(move |cpm_range| cpm_range.value == value)
            .map(|cpm_range| cpm_range.range)
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub fn iter_ranges_mapped<'a, U: Eq + 'a>(
        &'a self,
        mut map: impl FnMut(T) -> U + Copy + 'a,
    ) -> impl Iterator<Item = CodePointMapRange<U>> + 'a {
        crate::iterator_utils::RangeListIteratorCoalescer::new(self.iter_ranges().map(
            move |range| CodePointMapRange {
                range: range.range,
                value: map(range.value),
            },
        ))
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[cfg(feature = "alloc")]
    pub fn get_set_for_value(&self, value: T) -> CodePointInversionList<'static> {
        let value_ranges = self.iter_ranges_for_value(value);
        CodePointInversionList::from_iter(value_ranges)
    }

    
    #[inline]
    pub fn error_value(&self) -> T {
        self.error_value
    }
}

#[cfg(feature = "databake")]
impl<T: TrieValue + databake::Bake> databake::Bake for CodePointTrie<'_, T> {
    fn bake(&self, env: &databake::CrateEnv) -> databake::TokenStream {
        let header = self.header.bake(env);
        let index = self.index.bake(env);
        let data = self.data.bake(env);
        let error_value = self.error_value.bake(env);
        databake::quote! { unsafe { icu_collections::codepointtrie::CodePointTrie::from_parts_unstable_unchecked_v1(#header, #index, #data, #error_value) } }
    }
}

#[cfg(feature = "databake")]
impl<T: TrieValue + databake::Bake> databake::BakeSize for CodePointTrie<'_, T> {
    fn borrows_size(&self) -> usize {
        self.header.borrows_size() + self.index.borrows_size() + self.data.borrows_size()
    }
}

impl<T: TrieValue + Into<u32>> CodePointTrie<'_, T> {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub fn get32_u32(&self, code_point: u32) -> u32 {
        self.get32(code_point).into()
    }
}

impl<T: TrieValue> Clone for CodePointTrie<'_, T>
where
    <T as zerovec::ule::AsULE>::ULE: Clone,
{
    fn clone(&self) -> Self {
        CodePointTrie {
            header: self.header,
            index: self.index.clone(),
            data: self.data.clone(),
            error_value: self.error_value,
        }
    }
}






#[derive(PartialEq, Eq, Debug, Clone)]
pub struct CodePointMapRange<T> {
    
    pub range: RangeInclusive<u32>,
    
    pub value: T,
}



pub struct CodePointMapRangeIterator<'a, T: TrieValue> {
    cpt: &'a CodePointTrie<'a, T>,
    
    
    
    
    
    
    cpm_range: Option<CodePointMapRange<T>>,
}

impl<T: TrieValue> Iterator for CodePointMapRangeIterator<'_, T> {
    type Item = CodePointMapRange<T>;

    fn next(&mut self) -> Option<Self::Item> {
        self.cpm_range = match &self.cpm_range {
            Some(cpmr) => {
                if *cpmr.range.start() == u32::MAX {
                    self.cpt.get_range(0)
                } else {
                    self.cpt.get_range(cpmr.range.end() + 1)
                }
            }
            None => None,
        };
        
        self.cpm_range.clone()
    }
}






trait Seal {}



#[allow(private_bounds)] 
pub trait TypedCodePointTrie<'trie, T: TrieValue>: Seal {
    
    
    
    
    
    const TRIE_TYPE: TrieType;

    
    #[inline(always)]
    fn get32_u32(&self, code_point: u32) -> u32 {
        self.get32(code_point).to_u32()
    }

    
    #[inline(always)]
    fn get16(&self, bmp: u16) -> T {
        
        
        
        let code_point = u32::from(bmp);
        if let Some(v) = self.get32_by_fast_index(code_point) {
            v
        } else {
            self.as_untyped_ref().get32_by_small_index_cold(code_point)
        }
    }

    
    #[inline(always)]
    fn get32_supplementary(&self, supplementary: u32) -> T {
        self.as_untyped_ref().get32_supplementary(supplementary)
    }

    
    #[inline(always)]
    fn get(&self, c: char) -> T {
        
        
        
        let code_point = u32::from(c);
        if let Some(v) = self.get32_by_fast_index(code_point) {
            v
        } else {
            self.as_untyped_ref().get32_by_small_index_cold(code_point)
        }
    }

    
    #[inline(always)]
    fn get32(&self, code_point: u32) -> T {
        if let Some(v) = self.get32_by_fast_index(code_point) {
            v
        } else if code_point <= CODE_POINT_MAX {
            self.as_untyped_ref().get32_by_small_index_cold(code_point)
        } else {
            self.as_untyped_ref().error_value
        }
    }

    
    
    
    #[inline(always)] 
    fn get32_by_fast_index(&self, code_point: u32) -> Option<T> {
        debug_assert_eq!(Self::TRIE_TYPE, self.as_untyped_ref().header.trie_type);
        let fast_max = match Self::TRIE_TYPE {
            TrieType::Fast => FAST_TYPE_FAST_INDEXING_MAX,
            TrieType::Small => SMALL_TYPE_FAST_INDEXING_MAX,
        };
        if code_point <= fast_max {
            
            
            
            
            
            
            
            
            
            
            Some(unsafe { self.as_untyped_ref().get32_assuming_fast_index(code_point) })
        } else {
            
            
            None
        }
    }

    
    fn as_untyped_ref(&self) -> &CodePointTrie<'trie, T>;

    
    fn to_untyped(self) -> CodePointTrie<'trie, T>;
}





#[derive(Debug)]
#[repr(transparent)]
pub struct FastCodePointTrie<'trie, T: TrieValue> {
    inner: CodePointTrie<'trie, T>,
}

impl<'trie, T: TrieValue> TypedCodePointTrie<'trie, T> for FastCodePointTrie<'trie, T> {
    const TRIE_TYPE: TrieType = TrieType::Fast;

    
    #[inline(always)]
    fn as_untyped_ref(&self) -> &CodePointTrie<'trie, T> {
        &self.inner
    }

    
    #[inline(always)]
    fn to_untyped(self) -> CodePointTrie<'trie, T> {
        self.inner
    }

    
    #[inline(always)]
    fn get16(&self, bmp: u16) -> T {
        debug_assert!(u32::from(u16::MAX) <= FAST_TYPE_FAST_INDEXING_MAX);
        debug_assert_eq!(Self::TRIE_TYPE, TrieType::Fast);
        debug_assert_eq!(self.as_untyped_ref().header.trie_type, TrieType::Fast);
        let code_point = u32::from(bmp);
        
        
        
        
        
        
        
        
        unsafe { self.as_untyped_ref().get32_assuming_fast_index(code_point) }
    }
}

impl<'trie, T: TrieValue> Seal for FastCodePointTrie<'trie, T> {}

impl<'trie, T: TrieValue> TryFrom<&'trie CodePointTrie<'trie, T>>
    for &'trie FastCodePointTrie<'trie, T>
{
    type Error = TypedCodePointTrieError;

    fn try_from(
        reference: &'trie CodePointTrie<'trie, T>,
    ) -> Result<&'trie FastCodePointTrie<'trie, T>, TypedCodePointTrieError> {
        match reference.as_typed_ref() {
            Typed::Fast(trie) => Ok(trie),
            Typed::Small(_) => Err(TypedCodePointTrieError),
        }
    }
}

impl<'trie, T: TrieValue> TryFrom<CodePointTrie<'trie, T>> for FastCodePointTrie<'trie, T> {
    type Error = TypedCodePointTrieError;

    fn try_from(
        value: CodePointTrie<'trie, T>,
    ) -> Result<FastCodePointTrie<'trie, T>, TypedCodePointTrieError> {
        match value.to_typed() {
            Typed::Fast(trie) => Ok(trie),
            Typed::Small(_) => Err(TypedCodePointTrieError),
        }
    }
}



#[derive(Debug)]
#[repr(transparent)]
pub struct SmallCodePointTrie<'trie, T: TrieValue> {
    inner: CodePointTrie<'trie, T>,
}

impl<'trie, T: TrieValue> TypedCodePointTrie<'trie, T> for SmallCodePointTrie<'trie, T> {
    const TRIE_TYPE: TrieType = TrieType::Small;

    
    #[inline(always)]
    fn as_untyped_ref(&self) -> &CodePointTrie<'trie, T> {
        &self.inner
    }

    
    #[inline(always)]
    fn to_untyped(self) -> CodePointTrie<'trie, T> {
        self.inner
    }
}

impl<'trie, T: TrieValue> Seal for SmallCodePointTrie<'trie, T> {}

impl<'trie, T: TrieValue> TryFrom<&'trie CodePointTrie<'trie, T>>
    for &'trie SmallCodePointTrie<'trie, T>
{
    type Error = TypedCodePointTrieError;

    fn try_from(
        reference: &'trie CodePointTrie<'trie, T>,
    ) -> Result<&'trie SmallCodePointTrie<'trie, T>, TypedCodePointTrieError> {
        match reference.as_typed_ref() {
            Typed::Fast(_) => Err(TypedCodePointTrieError),
            Typed::Small(trie) => Ok(trie),
        }
    }
}

impl<'trie, T: TrieValue> TryFrom<CodePointTrie<'trie, T>> for SmallCodePointTrie<'trie, T> {
    type Error = TypedCodePointTrieError;

    fn try_from(
        value: CodePointTrie<'trie, T>,
    ) -> Result<SmallCodePointTrie<'trie, T>, TypedCodePointTrieError> {
        match value.to_typed() {
            Typed::Fast(_) => Err(TypedCodePointTrieError),
            Typed::Small(trie) => Ok(trie),
        }
    }
}



#[derive(Debug)]
#[non_exhaustive]
pub struct TypedCodePointTrieError;



pub enum Typed<F, S> {
    
    Fast(F),
    
    Small(S),
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codepointtrie::planes;
    use alloc::vec::Vec;

    #[test]
    #[cfg(feature = "serde")]
    fn test_serde_with_postcard_roundtrip() -> Result<(), postcard::Error> {
        let trie = crate::codepointtrie::planes::get_planes_trie();
        let trie_serialized: Vec<u8> = postcard::to_allocvec(&trie).unwrap();

        
        const EXP_TRIE_SERIALIZED: &[u8] = &[
            128, 128, 64, 128, 2, 2, 0, 0, 1, 160, 18, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 136,
            2, 144, 2, 144, 2, 144, 2, 176, 2, 176, 2, 176, 2, 176, 2, 208, 2, 208, 2, 208, 2, 208,
            2, 240, 2, 240, 2, 240, 2, 240, 2, 16, 3, 16, 3, 16, 3, 16, 3, 48, 3, 48, 3, 48, 3, 48,
            3, 80, 3, 80, 3, 80, 3, 80, 3, 112, 3, 112, 3, 112, 3, 112, 3, 144, 3, 144, 3, 144, 3,
            144, 3, 176, 3, 176, 3, 176, 3, 176, 3, 208, 3, 208, 3, 208, 3, 208, 3, 240, 3, 240, 3,
            240, 3, 240, 3, 16, 4, 16, 4, 16, 4, 16, 4, 48, 4, 48, 4, 48, 4, 48, 4, 80, 4, 80, 4,
            80, 4, 80, 4, 112, 4, 112, 4, 112, 4, 112, 4, 0, 0, 16, 0, 32, 0, 48, 0, 64, 0, 80, 0,
            96, 0, 112, 0, 0, 0, 16, 0, 32, 0, 48, 0, 0, 0, 16, 0, 32, 0, 48, 0, 0, 0, 16, 0, 32,
            0, 48, 0, 0, 0, 16, 0, 32, 0, 48, 0, 0, 0, 16, 0, 32, 0, 48, 0, 0, 0, 16, 0, 32, 0, 48,
            0, 0, 0, 16, 0, 32, 0, 48, 0, 0, 0, 16, 0, 32, 0, 48, 0, 128, 0, 128, 0, 128, 0, 128,
            0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128,
            0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128,
            0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 144, 0, 144, 0, 144, 0, 144, 0, 144,
            0, 144, 0, 144, 0, 144, 0, 144, 0, 144, 0, 144, 0, 144, 0, 144, 0, 144, 0, 144, 0, 144,
            0, 144, 0, 144, 0, 144, 0, 144, 0, 144, 0, 144, 0, 144, 0, 144, 0, 144, 0, 144, 0, 144,
            0, 144, 0, 144, 0, 144, 0, 144, 0, 144, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160,
            0, 160, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160,
            0, 160, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160, 0, 160,
            0, 160, 0, 160, 0, 160, 0, 160, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176,
            0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176,
            0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176, 0, 176,
            0, 176, 0, 176, 0, 176, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192,
            0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192,
            0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192,
            0, 192, 0, 192, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208,
            0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208,
            0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208, 0, 208,
            0, 208, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224,
            0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224,
            0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224,
            0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240,
            0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240,
            0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 240, 0, 0,
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
            1, 0, 1, 0, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
            16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16,
            1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 32, 1, 32, 1, 32, 1,
            32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32,
            1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1,
            32, 1, 32, 1, 32, 1, 32, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48,
            1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1,
            48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 64, 1, 64,
            1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1,
            64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64,
            1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1,
            80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80,
            1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1,
            96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96,
            1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1,
            96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 128, 0, 136, 0, 136, 0, 136, 0, 136,
            0, 136, 0, 136, 0, 136, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
            2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2,
            0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 168, 0, 168, 0, 168, 0, 168, 0, 168, 0,
            168, 0, 168, 0, 168, 0, 168, 0, 168, 0, 168, 0, 168, 0, 168, 0, 168, 0, 168, 0, 168, 0,
            168, 0, 168, 0, 168, 0, 168, 0, 168, 0, 168, 0, 168, 0, 168, 0, 168, 0, 168, 0, 168, 0,
            168, 0, 168, 0, 168, 0, 168, 0, 168, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0,
            200, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0,
            200, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0, 200, 0,
            200, 0, 200, 0, 200, 0, 200, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0,
            232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0,
            232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0, 232, 0,
            232, 0, 232, 0, 232, 0, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
            1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
            8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40,
            1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1,
            40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40,
            1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1,
            72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72,
            1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 104, 1, 104, 1, 104, 1, 104, 1,
            104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1,
            104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1,
            104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1,
            136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1,
            136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1,
            136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1,
            168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1,
            168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1,
            168, 1, 168, 1, 168, 1, 168, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1,
            200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1,
            200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1,
            200, 1, 200, 1, 200, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1,
            232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1,
            232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1,
            232, 1, 232, 1, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2,
            8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 8,
            2, 8, 2, 8, 2, 8, 2, 8, 2, 8, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40,
            2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2,
            40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 40, 2, 72,
            2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2,
            72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72,
            2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 72, 2, 104, 2, 104, 2, 104, 2, 104, 2, 104, 2,
            104, 2, 104, 2, 104, 2, 104, 2, 104, 2, 104, 2, 104, 2, 104, 2, 104, 2, 104, 2, 104, 2,
            104, 2, 104, 2, 104, 2, 104, 2, 104, 2, 104, 2, 104, 2, 104, 2, 104, 2, 104, 2, 104, 2,
            104, 2, 104, 2, 104, 2, 104, 2, 104, 2, 244, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
            4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6,
            6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8,
            8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10,
            10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11,
            11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
            12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14,
            14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15,
            15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 0,
        ];
        assert_eq!(trie_serialized, EXP_TRIE_SERIALIZED);

        let trie_deserialized = postcard::from_bytes::<CodePointTrie<u8>>(&trie_serialized)?;

        assert_eq!(&trie.index, &trie_deserialized.index);
        assert_eq!(&trie.data, &trie_deserialized.data);

        assert!(!trie_deserialized.index.is_owned());
        assert!(!trie_deserialized.data.is_owned());

        Ok(())
    }

    #[test]
    fn test_typed() {
        let untyped = planes::get_planes_trie();
        assert_eq!(untyped.get('\u{10000}'), 1);
        let small_ref = <&SmallCodePointTrie<_>>::try_from(&untyped).unwrap();
        assert_eq!(small_ref.get('\u{10000}'), 1);
        let _ = <&FastCodePointTrie<_>>::try_from(&untyped).is_err();
        let small = <SmallCodePointTrie<_>>::try_from(untyped).unwrap();
        assert_eq!(small.get('\u{10000}'), 1);
    }

    #[test]
    fn test_get_range() {
        let planes_trie = planes::get_planes_trie();

        let first_range: Option<CodePointMapRange<u8>> = planes_trie.get_range(0x0);
        assert_eq!(
            first_range,
            Some(CodePointMapRange {
                range: 0x0..=0xffff,
                value: 0
            })
        );

        let second_range: Option<CodePointMapRange<u8>> = planes_trie.get_range(0x1_0000);
        assert_eq!(
            second_range,
            Some(CodePointMapRange {
                range: 0x10000..=0x1ffff,
                value: 1
            })
        );

        let penultimate_range: Option<CodePointMapRange<u8>> = planes_trie.get_range(0xf_0000);
        assert_eq!(
            penultimate_range,
            Some(CodePointMapRange {
                range: 0xf_0000..=0xf_ffff,
                value: 15
            })
        );

        let last_range: Option<CodePointMapRange<u8>> = planes_trie.get_range(0x10_0000);
        assert_eq!(
            last_range,
            Some(CodePointMapRange {
                range: 0x10_0000..=0x10_ffff,
                value: 16
            })
        );
    }

    #[test]
    #[allow(unused_unsafe)] 
    fn databake() {
        databake::test_bake!(
            CodePointTrie<'static, u32>,
            const,
            unsafe {
                crate::codepointtrie::CodePointTrie::from_parts_unstable_unchecked_v1(
                    crate::codepointtrie::CodePointTrieHeader {
                        high_start: 1u32,
                        shifted12_high_start: 2u16,
                        index3_null_offset: 3u16,
                        data_null_offset: 4u32,
                        null_value: 5u32,
                        trie_type: crate::codepointtrie::TrieType::Small,
                    },
                    zerovec::ZeroVec::new(),
                    zerovec::ZeroVec::new(),
                    0u32,
                )
            },
            icu_collections,
            [zerovec],
        );
    }
}
