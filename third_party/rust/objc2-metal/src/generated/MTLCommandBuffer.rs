

use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;























#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MTLCommandBufferStatus(pub NSUInteger);
impl MTLCommandBufferStatus {
    #[doc(alias = "MTLCommandBufferStatusNotEnqueued")]
    pub const NotEnqueued: Self = Self(0);
    #[doc(alias = "MTLCommandBufferStatusEnqueued")]
    pub const Enqueued: Self = Self(1);
    #[doc(alias = "MTLCommandBufferStatusCommitted")]
    pub const Committed: Self = Self(2);
    #[doc(alias = "MTLCommandBufferStatusScheduled")]
    pub const Scheduled: Self = Self(3);
    #[doc(alias = "MTLCommandBufferStatusCompleted")]
    pub const Completed: Self = Self(4);
    #[doc(alias = "MTLCommandBufferStatusError")]
    pub const Error: Self = Self(5);
}

unsafe impl Encode for MTLCommandBufferStatus {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLCommandBufferStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    
    
    
    pub static MTLCommandBufferErrorDomain: &'static NSErrorDomain;
}



































#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MTLCommandBufferError(pub NSUInteger);
impl MTLCommandBufferError {
    #[doc(alias = "MTLCommandBufferErrorNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "MTLCommandBufferErrorInternal")]
    pub const Internal: Self = Self(1);
    #[doc(alias = "MTLCommandBufferErrorTimeout")]
    pub const Timeout: Self = Self(2);
    #[doc(alias = "MTLCommandBufferErrorPageFault")]
    pub const PageFault: Self = Self(3);
    #[doc(alias = "MTLCommandBufferErrorBlacklisted")]
    #[deprecated]
    pub const Blacklisted: Self = Self(4);
    #[doc(alias = "MTLCommandBufferErrorAccessRevoked")]
    pub const AccessRevoked: Self = Self(4);
    #[doc(alias = "MTLCommandBufferErrorNotPermitted")]
    pub const NotPermitted: Self = Self(7);
    #[doc(alias = "MTLCommandBufferErrorOutOfMemory")]
    pub const OutOfMemory: Self = Self(8);
    #[doc(alias = "MTLCommandBufferErrorInvalidResource")]
    pub const InvalidResource: Self = Self(9);
    #[doc(alias = "MTLCommandBufferErrorMemoryless")]
    pub const Memoryless: Self = Self(10);
    #[doc(alias = "MTLCommandBufferErrorDeviceRemoved")]
    pub const DeviceRemoved: Self = Self(11);
    #[doc(alias = "MTLCommandBufferErrorStackOverflow")]
    pub const StackOverflow: Self = Self(12);
}

unsafe impl Encode for MTLCommandBufferError {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLCommandBufferError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    
    
    
    pub static MTLCommandBufferEncoderInfoErrorKey: &'static NSErrorUserInfoKey;
}











#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MTLCommandBufferErrorOption(pub NSUInteger);
bitflags::bitflags! {
    impl MTLCommandBufferErrorOption: NSUInteger {
        #[doc(alias = "MTLCommandBufferErrorOptionNone")]
        const None = 0;
        #[doc(alias = "MTLCommandBufferErrorOptionEncoderExecutionStatus")]
        const EncoderExecutionStatus = 1<<0;
    }
}

unsafe impl Encode for MTLCommandBufferErrorOption {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLCommandBufferErrorOption {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}




















#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MTLCommandEncoderErrorState(pub NSInteger);
impl MTLCommandEncoderErrorState {
    #[doc(alias = "MTLCommandEncoderErrorStateUnknown")]
    pub const Unknown: Self = Self(0);
    #[doc(alias = "MTLCommandEncoderErrorStateCompleted")]
    pub const Completed: Self = Self(1);
    #[doc(alias = "MTLCommandEncoderErrorStateAffected")]
    pub const Affected: Self = Self(2);
    #[doc(alias = "MTLCommandEncoderErrorStatePending")]
    pub const Pending: Self = Self(3);
    #[doc(alias = "MTLCommandEncoderErrorStateFaulted")]
    pub const Faulted: Self = Self(4);
}

unsafe impl Encode for MTLCommandEncoderErrorState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MTLCommandEncoderErrorState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that you use to configure new Metal command buffer objects.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtlcommandbufferdescriptor?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLCommandBufferDescriptor;
);

extern_conformance!(
    unsafe impl NSCopying for MTLCommandBufferDescriptor {}
);

unsafe impl CopyingHelper for MTLCommandBufferDescriptor {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLCommandBufferDescriptor {}
);

impl MTLCommandBufferDescriptor {
    extern_methods!(
        /// If YES, the created command buffer holds strong references to objects needed for it to execute. If NO, the created command buffer does not hold strong references to objects needed for it to execute.
        #[unsafe(method(retainedReferences))]
        #[unsafe(method_family = none)]
        pub fn retainedReferences(&self) -> bool;

        /// Setter for [`retainedReferences`][Self::retainedReferences].
        #[unsafe(method(setRetainedReferences:))]
        #[unsafe(method_family = none)]
        pub fn setRetainedReferences(&self, retained_references: bool);

        /// A set of options to influence the error reporting of the created command buffer. See MTLCommandBufferErrorOption.
        #[unsafe(method(errorOptions))]
        #[unsafe(method_family = none)]
        pub fn errorOptions(&self) -> MTLCommandBufferErrorOption;

        /// Setter for [`errorOptions`][Self::errorOptions].
        #[unsafe(method(setErrorOptions:))]
        #[unsafe(method_family = none)]
        pub fn setErrorOptions(&self, error_options: MTLCommandBufferErrorOption);

        #[cfg(feature = "MTLLogState")]
        /// Contains information related to shader logging.
        #[unsafe(method(logState))]
        #[unsafe(method_family = none)]
        pub fn logState(&self) -> Option<Retained<ProtocolObject<dyn MTLLogState>>>;

        #[cfg(feature = "MTLLogState")]
        /// Setter for [`logState`][Self::logState].
        #[unsafe(method(setLogState:))]
        #[unsafe(method_family = none)]
        pub fn setLogState(&self, log_state: Option<&ProtocolObject<dyn MTLLogState>>);
    );
}


impl MTLCommandBufferDescriptor {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLCommandBufferDescriptor {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_protocol!(
    /// Provides execution status information for a Metal command encoder.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtlcommandbufferencoderinfo?language=objc)
    pub unsafe trait MTLCommandBufferEncoderInfo: NSObjectProtocol {
        /// The debug label given to the associated Metal command encoder at command buffer submission.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        fn label(&self) -> Retained<NSString>;

        /// The debug signposts inserted into the associated Metal command encoder.
        #[unsafe(method(debugSignposts))]
        #[unsafe(method_family = none)]
        fn debugSignposts(&self) -> Retained<NSArray<NSString>>;

        /// The error state of the associated Metal command encoder.
        #[unsafe(method(errorState))]
        #[unsafe(method_family = none)]
        fn errorState(&self) -> MTLCommandEncoderErrorState;
    }
);


#[cfg(feature = "block2")]
pub type MTLCommandBufferHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<ProtocolObject<dyn MTLCommandBuffer>>)>;











#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MTLDispatchType(pub NSUInteger);
impl MTLDispatchType {
    #[doc(alias = "MTLDispatchTypeSerial")]
    pub const Serial: Self = Self(0);
    #[doc(alias = "MTLDispatchTypeConcurrent")]
    pub const Concurrent: Self = Self(1);
}

unsafe impl Encode for MTLDispatchType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLDispatchType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A serial list of commands for the device to execute.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtlcommandbuffer?language=objc)
    pub unsafe trait MTLCommandBuffer: NSObjectProtocol {
        #[cfg(feature = "MTLDevice")]
        /// The device this resource was created against.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        fn device(&self) -> Retained<ProtocolObject<dyn MTLDevice>>;

        #[cfg(feature = "MTLCommandQueue")]
        /// The command queue this command buffer was created from.
        #[unsafe(method(commandQueue))]
        #[unsafe(method_family = none)]
        fn commandQueue(&self) -> Retained<ProtocolObject<dyn MTLCommandQueue>>;

        /// If YES, this command buffer holds strong references to objects needed to execute this command buffer.
        #[unsafe(method(retainedReferences))]
        #[unsafe(method_family = none)]
        fn retainedReferences(&self) -> bool;

        /// The set of options configuring the error reporting of the created command buffer.
        #[unsafe(method(errorOptions))]
        #[unsafe(method_family = none)]
        fn errorOptions(&self) -> MTLCommandBufferErrorOption;

        /// A string to help identify this object.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        fn label(&self) -> Option<Retained<NSString>>;

        /// Setter for [`label`][Self::label].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLabel:))]
        #[unsafe(method_family = none)]
        fn setLabel(&self, label: Option<&NSString>);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(kernelStartTime))]
        #[unsafe(method_family = none)]
        fn kernelStartTime(&self) -> CFTimeInterval;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(kernelEndTime))]
        #[unsafe(method_family = none)]
        fn kernelEndTime(&self) -> CFTimeInterval;

        #[cfg(feature = "MTLFunctionLog")]
        /// Logs generated by the command buffer during execution of the GPU commands. Valid after GPU execution is completed
        #[unsafe(method(logs))]
        #[unsafe(method_family = none)]
        fn logs(&self) -> Retained<ProtocolObject<dyn MTLLogContainer>>;

        #[cfg(feature = "objc2-core-foundation")]
        /// The host time in seconds that GPU starts executing this command buffer. Returns zero if it has not started. This usually can be called in command buffer completion handler.
        #[unsafe(method(GPUStartTime))]
        #[unsafe(method_family = none)]
        fn GPUStartTime(&self) -> CFTimeInterval;

        #[cfg(feature = "objc2-core-foundation")]
        /// The host time in seconds that GPU finishes executing this command buffer. Returns zero if CPU has not received completion notification. This usually can be called in command buffer completion handler.
        #[unsafe(method(GPUEndTime))]
        #[unsafe(method_family = none)]
        fn GPUEndTime(&self) -> CFTimeInterval;

        /// Append this command buffer to the end of its MTLCommandQueue.
        #[unsafe(method(enqueue))]
        #[unsafe(method_family = none)]
        fn enqueue(&self);

        /// Commit a command buffer so it can be executed as soon as possible.
        #[unsafe(method(commit))]
        #[unsafe(method_family = none)]
        fn commit(&self);

        #[cfg(feature = "block2")]
        /// Adds a block to be called when this command buffer has been scheduled for execution.
        ///
        /// # Safety
        ///
        /// `block` must be a valid pointer.
        #[unsafe(method(addScheduledHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn addScheduledHandler(&self, block: MTLCommandBufferHandler);

        #[cfg(feature = "MTLDrawable")]
        /// Add a drawable present that will be invoked when this command buffer has been scheduled for execution.
        ///
        /// The submission thread will be lock stepped with present call been serviced by window server
        #[unsafe(method(presentDrawable:))]
        #[unsafe(method_family = none)]
        fn presentDrawable(&self, drawable: &ProtocolObject<dyn MTLDrawable>);

        #[cfg(all(feature = "MTLDrawable", feature = "objc2-core-foundation"))]
        /// Add a drawable present for a specific host time that will be invoked when this command buffer has been scheduled for execution.
        ///
        /// The submission thread will be lock stepped with present call been serviced by window server
        #[unsafe(method(presentDrawable:atTime:))]
        #[unsafe(method_family = none)]
        fn presentDrawable_atTime(
            &self,
            drawable: &ProtocolObject<dyn MTLDrawable>,
            presentation_time: CFTimeInterval,
        );

        #[cfg(all(feature = "MTLDrawable", feature = "objc2-core-foundation"))]
        /// Add a drawable present for a specific host time that allows previous frame to be on screen for at least duration time.
        ///
        /// Parameter `drawable`: The drawable to be presented
        ///
        /// Parameter `duration`: The minimum time that previous frame should be displayed. The time is double preceision floating point in the unit of seconds.
        ///
        /// The difference of this API versus presentDrawable:atTime is that this API defers calculation of the presentation time until the previous frame's actual presentation time is known, thus to be able to maintain a more consistent and stable frame time. This also provides an easy way to set frame rate.
        /// The submission thread will be lock stepped with present call been serviced by window server
        #[unsafe(method(presentDrawable:afterMinimumDuration:))]
        #[unsafe(method_family = none)]
        fn presentDrawable_afterMinimumDuration(
            &self,
            drawable: &ProtocolObject<dyn MTLDrawable>,
            duration: CFTimeInterval,
        );

        /// Synchronously wait for this command buffer to be scheduled.
        #[unsafe(method(waitUntilScheduled))]
        #[unsafe(method_family = none)]
        fn waitUntilScheduled(&self);

        #[cfg(feature = "block2")]
        /// Add a block to be called when this command buffer has completed execution.
        ///
        /// # Safety
        ///
        /// `block` must be a valid pointer.
        #[unsafe(method(addCompletedHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn addCompletedHandler(&self, block: MTLCommandBufferHandler);

        /// Synchronously wait for this command buffer to complete.
        #[unsafe(method(waitUntilCompleted))]
        #[unsafe(method_family = none)]
        fn waitUntilCompleted(&self);

        /// status reports the current stage in the lifetime of MTLCommandBuffer, as it proceeds to enqueued, committed, scheduled, and completed.
        #[unsafe(method(status))]
        #[unsafe(method_family = none)]
        fn status(&self) -> MTLCommandBufferStatus;

        /// If an error occurred during execution, the NSError may contain more details about the problem.
        #[unsafe(method(error))]
        #[unsafe(method_family = none)]
        fn error(&self) -> Option<Retained<NSError>>;

        #[cfg(all(feature = "MTLBlitCommandEncoder", feature = "MTLCommandEncoder"))]
        /// returns a blit command encoder to encode into this command buffer.
        #[unsafe(method(blitCommandEncoder))]
        #[unsafe(method_family = none)]
        fn blitCommandEncoder(&self)
            -> Option<Retained<ProtocolObject<dyn MTLBlitCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLCommandEncoder",
            feature = "MTLRenderCommandEncoder",
            feature = "MTLRenderPass"
        ))]
        /// returns a render command endcoder to encode into this command buffer.
        #[unsafe(method(renderCommandEncoderWithDescriptor:))]
        #[unsafe(method_family = none)]
        fn renderCommandEncoderWithDescriptor(
            &self,
            render_pass_descriptor: &MTLRenderPassDescriptor,
        ) -> Option<Retained<ProtocolObject<dyn MTLRenderCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLCommandEncoder",
            feature = "MTLComputeCommandEncoder",
            feature = "MTLComputePass"
        ))]
        /// returns a compute command endcoder to encode into this command buffer.
        #[unsafe(method(computeCommandEncoderWithDescriptor:))]
        #[unsafe(method_family = none)]
        fn computeCommandEncoderWithDescriptor(
            &self,
            compute_pass_descriptor: &MTLComputePassDescriptor,
        ) -> Option<Retained<ProtocolObject<dyn MTLComputeCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLBlitCommandEncoder",
            feature = "MTLBlitPass",
            feature = "MTLCommandEncoder"
        ))]
        /// returns a blit command endcoder to encode into this command buffer.
        #[unsafe(method(blitCommandEncoderWithDescriptor:))]
        #[unsafe(method_family = none)]
        fn blitCommandEncoderWithDescriptor(
            &self,
            blit_pass_descriptor: &MTLBlitPassDescriptor,
        ) -> Option<Retained<ProtocolObject<dyn MTLBlitCommandEncoder>>>;

        #[cfg(all(feature = "MTLCommandEncoder", feature = "MTLComputeCommandEncoder"))]
        /// returns a compute command encoder to encode into this command buffer.
        #[unsafe(method(computeCommandEncoder))]
        #[unsafe(method_family = none)]
        fn computeCommandEncoder(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn MTLComputeCommandEncoder>>>;

        #[cfg(all(feature = "MTLCommandEncoder", feature = "MTLComputeCommandEncoder"))]
        /// returns a compute command encoder to encode into this command buffer. Optionally allow this command encoder to execute dispatches concurrently.
        ///
        /// On devices that do not support concurrent command encoders, this call is equivalent to computeCommandEncoder
        #[unsafe(method(computeCommandEncoderWithDispatchType:))]
        #[unsafe(method_family = none)]
        fn computeCommandEncoderWithDispatchType(
            &self,
            dispatch_type: MTLDispatchType,
        ) -> Option<Retained<ProtocolObject<dyn MTLComputeCommandEncoder>>>;

        #[cfg(feature = "MTLEvent")]
        /// Encodes a command that pauses execution of this command buffer until the specified event reaches a given value.
        ///
        /// This method may only be called if there is no current command encoder on the receiver.
        #[unsafe(method(encodeWaitForEvent:value:))]
        #[unsafe(method_family = none)]
        fn encodeWaitForEvent_value(&self, event: &ProtocolObject<dyn MTLEvent>, value: u64);

        #[cfg(feature = "MTLEvent")]
        /// Encodes a command that signals an event with a given value.
        ///
        /// This method may only be called if there is no current command encoder on the receiver.
        #[unsafe(method(encodeSignalEvent:value:))]
        #[unsafe(method_family = none)]
        fn encodeSignalEvent_value(&self, event: &ProtocolObject<dyn MTLEvent>, value: u64);

        #[cfg(all(
            feature = "MTLCommandEncoder",
            feature = "MTLParallelRenderCommandEncoder",
            feature = "MTLRenderPass"
        ))]
        /// returns a parallel render pass encoder to encode into this command buffer.
        #[unsafe(method(parallelRenderCommandEncoderWithDescriptor:))]
        #[unsafe(method_family = none)]
        fn parallelRenderCommandEncoderWithDescriptor(
            &self,
            render_pass_descriptor: &MTLRenderPassDescriptor,
        ) -> Option<Retained<ProtocolObject<dyn MTLParallelRenderCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLCommandEncoder",
            feature = "MTLResourceStateCommandEncoder"
        ))]
        #[unsafe(method(resourceStateCommandEncoder))]
        #[unsafe(method_family = none)]
        fn resourceStateCommandEncoder(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn MTLResourceStateCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLCommandEncoder",
            feature = "MTLResourceStateCommandEncoder",
            feature = "MTLResourceStatePass"
        ))]
        #[unsafe(method(resourceStateCommandEncoderWithDescriptor:))]
        #[unsafe(method_family = none)]
        fn resourceStateCommandEncoderWithDescriptor(
            &self,
            resource_state_pass_descriptor: &MTLResourceStatePassDescriptor,
        ) -> Option<Retained<ProtocolObject<dyn MTLResourceStateCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLAccelerationStructureCommandEncoder",
            feature = "MTLCommandEncoder"
        ))]
        #[unsafe(method(accelerationStructureCommandEncoder))]
        #[unsafe(method_family = none)]
        fn accelerationStructureCommandEncoder(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn MTLAccelerationStructureCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLAccelerationStructureCommandEncoder",
            feature = "MTLCommandEncoder"
        ))]
        #[unsafe(method(accelerationStructureCommandEncoderWithDescriptor:))]
        #[unsafe(method_family = none)]
        fn accelerationStructureCommandEncoderWithDescriptor(
            &self,
            descriptor: &MTLAccelerationStructurePassDescriptor,
        ) -> Retained<ProtocolObject<dyn MTLAccelerationStructureCommandEncoder>>;

        /// Push a new named string onto a stack of string labels.
        #[unsafe(method(pushDebugGroup:))]
        #[unsafe(method_family = none)]
        fn pushDebugGroup(&self, string: &NSString);

        /// Pop the latest named string off of the stack.
        #[unsafe(method(popDebugGroup))]
        #[unsafe(method_family = none)]
        fn popDebugGroup(&self);

        #[cfg(feature = "MTLResidencySet")]
        /// Marks the residency set as part of the current command buffer execution. This ensures that the residency set is resident during execution of the command buffer.
        #[unsafe(method(useResidencySet:))]
        #[unsafe(method_family = none)]
        fn useResidencySet(&self, residency_set: &ProtocolObject<dyn MTLResidencySet>);

        #[cfg(feature = "MTLResidencySet")]
        /// Marks the residency sets as part of the current command buffer execution. This ensures that the residency sets are resident during execution of the command buffer.
        ///
        /// # Safety
        ///
        /// - `residency_sets` must be a valid pointer.
        /// - `count` might not be bounds-checked.
        #[unsafe(method(useResidencySets:count:))]
        #[unsafe(method_family = none)]
        unsafe fn useResidencySets_count(
            &self,
            residency_sets: NonNull<NonNull<ProtocolObject<dyn MTLResidencySet>>>,
            count: NSUInteger,
        );
    }
);
