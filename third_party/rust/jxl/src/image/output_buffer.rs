




use std::{fmt::Debug, marker::PhantomData, mem::MaybeUninit};

use super::{RawImageRectMut, Rect, internal::RawImageBuffer};

#[derive(Debug)]
#[repr(transparent)]
pub struct JxlOutputBuffer<'a> {
    
    inner: RawImageBuffer,
    _ph: PhantomData<&'a mut u8>,
}

impl<'a> JxlOutputBuffer<'a> {
    
    
    
    
    
    
    
    
    
    pub unsafe fn new_from_ptr(
        buf: *mut MaybeUninit<u8>,
        num_rows: usize,
        bytes_per_row: usize,
        bytes_between_rows: usize,
    ) -> Self {
        JxlOutputBuffer {
            
            
            
            inner: unsafe {
                RawImageBuffer::new_from_ptr(buf, num_rows, bytes_per_row, bytes_between_rows)
            },
            _ph: PhantomData,
        }
    }

    pub fn from_image_rect_mut(raw: RawImageRectMut<'a>) -> Self {
        Self {
            
            
            inner: raw.data,
            _ph: PhantomData,
        }
    }

    
    
    pub fn new_uninit(
        buf: &'a mut [MaybeUninit<u8>],
        num_rows: usize,
        bytes_per_row: usize,
    ) -> Self {
        assert!(buf.len() >= bytes_per_row * num_rows);
        
        
        unsafe { Self::new_from_ptr(buf.as_mut_ptr(), num_rows, bytes_per_row, bytes_per_row) }
    }

    pub fn new(buf: &'a mut [u8], num_rows: usize, bytes_per_row: usize) -> Self {
        Self::new_uninit(
            
            
            unsafe { std::slice::from_raw_parts_mut(buf.as_mut_ptr().cast(), buf.len()) },
            num_rows,
            bytes_per_row,
        )
    }

    pub(crate) fn reborrow(lender: &'a mut JxlOutputBuffer<'_>) -> JxlOutputBuffer<'a> {
        
        Self {
            _ph: PhantomData,
            ..*lender
        }
    }

    
    
    pub(crate) unsafe fn row_mut(&mut self, row: usize) -> &mut [MaybeUninit<u8>] {
        
        
        unsafe { self.inner.row_mut(row) }
    }

    #[inline]
    pub fn write_bytes(&mut self, row: usize, col: usize, bytes: &[u8]) {
        
        
        let slice = unsafe { self.inner.row_mut(row) };
        for (w, s) in slice.iter_mut().skip(col).zip(bytes.iter().copied()) {
            w.write(s);
        }
    }

    pub fn byte_size(&self) -> (usize, usize) {
        self.inner.byte_size()
    }

    pub fn rect(&mut self, rect: Rect) -> JxlOutputBuffer<'_> {
        
        
        Self {
            inner: self.inner.rect(rect),
            _ph: PhantomData,
        }
    }
}
