




use internal::{RenderPipelineShared, RunInOutStage, RunInPlaceStage};
use std::any::Any;

use crate::{
    api::JxlOutputBuffer,
    error::Result,
    image::{Image, ImageDataType},
    render::buffer_splitter::BufferSplitter,
};

pub mod buffer_splitter;
mod builder;
mod channels;
mod internal;
mod low_memory_pipeline;
mod save;
mod simd_utils;
#[cfg(test)]
mod simple_pipeline;
pub mod stages;
#[cfg(test)]
mod test;









const MAX_BORDER: usize = 9;

pub(crate) use builder::RenderPipelineBuilder;
pub(crate) use channels::{Channels, ChannelsMut};
pub(crate) use low_memory_pipeline::LowMemoryRenderPipeline;
#[cfg(test)]
pub(crate) use simple_pipeline::SimpleRenderPipeline;


pub trait RenderPipelineInPlaceStage: Any + std::fmt::Display {
    type Type: ImageDataType;

    fn process_row_chunk(
        &self,
        position: (usize, usize),
        xsize: usize,
        
        row: &mut [&mut [Self::Type]],
        state: Option<&mut dyn Any>,
    );

    fn init_local_state(&self, _thread_index: usize) -> Result<Option<Box<dyn Any>>> {
        Ok(None)
    }

    fn uses_channel(&self, c: usize) -> bool;
}













pub trait RenderPipelineInOutStage: Any + std::fmt::Display {
    type InputT: ImageDataType;
    type OutputT: ImageDataType;

    const BORDER: (u8, u8);
    const SHIFT: (u8, u8);

    fn process_row_chunk(
        &self,
        position: (usize, usize),
        xsize: usize,
        
        input_rows: &Channels<Self::InputT>,
        
        output_rows: &mut ChannelsMut<Self::OutputT>,
        state: Option<&mut dyn Any>,
    );

    fn init_local_state(&self, _thread_index: usize) -> Result<Option<Box<dyn Any>>> {
        Ok(None)
    }

    fn uses_channel(&self, c: usize) -> bool;
}



pub(crate) trait RenderPipeline: Sized {
    type Buffer: 'static;

    fn new_from_shared(shared: RenderPipelineShared<Self::Buffer>) -> Result<Self>;

    
    
    
    fn get_buffer<T: ImageDataType>(&mut self, channel: usize) -> Result<Image<T>>;

    
    
    
    fn set_buffer_for_group<T: ImageDataType>(
        &mut self,
        channel: usize,
        group_id: usize,
        num_passes: usize,
        buf: Image<T>,
        buffer_splitter: &mut BufferSplitter,
    ) -> Result<()>;

    
    fn check_buffer_sizes(&self, buffers: &mut [Option<JxlOutputBuffer>]) -> Result<()>;

    
    
    
    fn render_outside_frame(&mut self, buffer_splitter: &mut BufferSplitter) -> Result<()>;

    fn box_inout_stage<S: RenderPipelineInOutStage>(
        stage: S,
    ) -> Box<dyn RunInOutStage<Self::Buffer>>;

    fn box_inplace_stage<S: RenderPipelineInPlaceStage>(
        stage: S,
    ) -> Box<dyn RunInPlaceStage<Self::Buffer>>;
}
