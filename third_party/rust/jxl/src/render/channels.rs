




use crate::util::SmallVec;







pub struct Channels<'a, T> {
    
    pub(crate) row_data: SmallVec<&'a [T], 32>,
    num_channels: usize,
    pub(crate) rows_per_channel: usize,
}

impl<'a, T> Channels<'a, T> {
    
    
    
    
    
    
    pub fn new(
        row_data: SmallVec<&'a [T], 32>,
        num_channels: usize,
        rows_per_channel: usize,
    ) -> Self {
        debug_assert_eq!(
            row_data.len(),
            num_channels * rows_per_channel,
            "row_data length must equal num_channels * rows_per_channel"
        );
        Self {
            row_data,
            num_channels,
            rows_per_channel,
        }
    }

    
    pub fn len(&self) -> usize {
        self.num_channels
    }

    
    pub fn is_empty(&self) -> bool {
        self.num_channels == 0
    }

    
    pub fn iter(&self) -> impl Iterator<Item = &[&'a [T]]> {
        (0..self.num_channels).map(move |ch| &self[ch])
    }
}


impl<'a, T> std::ops::Index<usize> for Channels<'a, T> {
    type Output = [&'a [T]];

    fn index(&self, ch: usize) -> &[&'a [T]] {
        let start = ch * self.rows_per_channel;
        &self.row_data[start..start + self.rows_per_channel]
    }
}





pub struct ChannelsMut<'a, T> {
    
    pub(crate) row_data: SmallVec<&'a mut [T], 8>,
    num_channels: usize,
    pub(crate) rows_per_channel: usize,
}

impl<'a, T> ChannelsMut<'a, T> {
    
    
    
    
    
    
    pub fn new(
        row_data: SmallVec<&'a mut [T], 8>,
        num_channels: usize,
        rows_per_channel: usize,
    ) -> Self {
        debug_assert_eq!(
            row_data.len(),
            num_channels * rows_per_channel,
            "row_data length must equal num_channels * rows_per_channel"
        );
        Self {
            row_data,
            num_channels,
            rows_per_channel,
        }
    }

    
    pub fn len(&self) -> usize {
        self.num_channels
    }

    
    pub fn is_empty(&self) -> bool {
        self.num_channels == 0
    }

    
    
    #[allow(clippy::type_complexity)]
    pub fn split_first_3_mut(
        &mut self,
    ) -> (&mut [&'a mut [T]], &mut [&'a mut [T]], &mut [&'a mut [T]]) {
        assert!(
            3 <= self.num_channels,
            "requested 3 channels but only have {}",
            self.num_channels
        );
        let rpc = self.rows_per_channel;
        let (first, rest) = self.row_data.split_at_mut(rpc);
        let (second, rest) = rest.split_at_mut(rpc);
        let (third, _) = rest.split_at_mut(rpc);
        (first, second, third)
    }

    
    
    pub fn iter_mut(&mut self) -> impl Iterator<Item = &mut [&'a mut [T]]> {
        let rpc = self.rows_per_channel;
        self.row_data.chunks_mut(rpc)
    }
}


impl<'a, T> std::ops::Index<usize> for ChannelsMut<'a, T> {
    type Output = [&'a mut [T]];

    fn index(&self, ch: usize) -> &[&'a mut [T]] {
        let start = ch * self.rows_per_channel;
        &self.row_data[start..start + self.rows_per_channel]
    }
}


impl<'a, T> std::ops::IndexMut<usize> for ChannelsMut<'a, T> {
    fn index_mut(&mut self, ch: usize) -> &mut [&'a mut [T]] {
        let start = ch * self.rows_per_channel;
        &mut self.row_data[start..start + self.rows_per_channel]
    }
}
