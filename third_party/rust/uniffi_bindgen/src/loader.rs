



use std::{
    collections::{BTreeMap, HashMap},
    fs,
};

use anyhow::bail;
use camino::Utf8Path;
use uniffi_meta::{
    create_metadata_groups, group_metadata, Metadata, MetadataGroup, MetadataGroupMap,
    NamespaceMetadata,
};

use crate::{
    crate_name_from_cargo_toml, interface, macro_metadata, pipeline, BindgenPaths, Component,
    ComponentInterface, Result,
};




pub struct BindgenLoader {
    bindgen_paths: BindgenPaths,
}

impl BindgenLoader {
    pub fn new(bindgen_paths: BindgenPaths) -> Self {
        Self { bindgen_paths }
    }

    
    
    
    
    
    
    
    pub fn load_metadata(&self, source_path: &Utf8Path) -> Result<MetadataGroupMap> {
        self.load_metadata_specialized(source_path, |_, _| Ok(None))
    }

    
    
    
    
    
    
    
    
    pub fn load_metadata_specialized<P>(
        &self,
        source_path: &Utf8Path,
        specialized_parser: P,
    ) -> Result<MetadataGroupMap>
    where
        P: FnOnce(&Utf8Path, &[u8]) -> Result<Option<Vec<Metadata>>>,
    {
        if self.is_udl(source_path) {
            let crate_name = crate_name_from_cargo_toml(source_path)?;
            let mut group = uniffi_udl::parse_udl(&fs::read_to_string(source_path)?, &crate_name)?;
            Self::add_checksums_to_udl_group(&mut group);
            Ok(HashMap::from([(crate_name, group)]))
        } else {
            let data = fs::read(source_path)?;
            let items = match specialized_parser(source_path, &data)? {
                Some(items) => items,
                None => macro_metadata::extract_from_bytes(&data)?,
            };
            let mut metadata_groups = create_metadata_groups(&items);
            group_metadata(&mut metadata_groups, items)?;

            for group in metadata_groups.values_mut() {
                let crate_name = group.namespace.crate_name.clone();
                if let Some(mut udl_group) = self.load_udl_metadata(group, &crate_name)? {
                    Self::add_checksums_to_udl_group(&mut udl_group);
                    group.items.append(&mut udl_group.items);
                    if group.namespace_docstring.is_none() {
                        group.namespace_docstring = udl_group.namespace_docstring;
                    }
                };
            }
            Ok(metadata_groups)
        }
    }

    
    fn add_checksums_to_udl_group(metadata_group: &mut MetadataGroup) {
        
        
        let items = std::mem::take(&mut metadata_group.items);
        for mut meta in items {
            match &mut meta {
                Metadata::Func(func) if func.checksum.is_none() => {
                    func.checksum = Some(interface::Function::checksum_from_metadata(func.clone()))
                }
                Metadata::Method(meth) if meth.checksum.is_none() => {
                    meth.checksum = Some(interface::Method::checksum_from_metadata(meth.clone()))
                }
                Metadata::Constructor(cons) if cons.checksum.is_none() => {
                    cons.checksum =
                        Some(interface::Constructor::checksum_from_metadata(cons.clone()))
                }
                
                
                _ => (),
            }
            metadata_group.items.insert(meta);
        }
    }

    
    
    
    
    pub fn load_cis(&self, metadata: MetadataGroupMap) -> Result<Vec<ComponentInterface>> {
        let crate_to_namespace_map: BTreeMap<String, NamespaceMetadata> = metadata
            .iter()
            .map(|(k, v)| (k.clone(), v.namespace.clone()))
            .collect();

        let mut ci_list = metadata
            .into_values()
            .map(|group| {
                let crate_name = &group.namespace.crate_name;
                let mut ci = ComponentInterface::new(crate_name);
                ci.add_metadata(group)?;
                ci.set_crate_to_namespace_map(crate_to_namespace_map.clone());
                Ok(ci)
            })
            .collect::<Result<Vec<ComponentInterface>>>()?;

        
        
        let ci_list2 = ci_list.clone();
        ci_list
            .iter_mut()
            .for_each(|ci| ci.set_all_component_interfaces(ci_list2.clone()));
        Ok(ci_list)
    }

    fn load_udl_metadata(
        &self,
        group: &MetadataGroup,
        crate_name: &str,
    ) -> Result<Option<MetadataGroup>> {
        let udl_items = group
            .items
            .iter()
            .filter_map(|i| match i {
                Metadata::UdlFile(meta) => Some(meta),
                _ => None,
            })
            .collect::<Vec<_>>();
        
        match udl_items.len() {
            0 => Ok(None),
            1 => {
                if udl_items[0].module_path != crate_name {
                    bail!(
                        "UDL is for crate '{}' but this crate name is '{}'",
                        udl_items[0].module_path,
                        crate_name
                    );
                }
                let udl = self
                    .bindgen_paths
                    .get_udl(crate_name, &udl_items[0].file_stub)?;
                let udl_group = uniffi_udl::parse_udl(&udl, crate_name)?;
                Ok(Some(udl_group))
            }
            n => bail!("{n} UDL files found for {crate_name}"),
        }
    }

    
    
    
    
    
    
    
    
    
    pub fn load_components<P, Config>(
        &self,
        cis: Vec<ComponentInterface>,
        mut parse_config: P,
    ) -> Result<Vec<Component<Config>>>
    where
        P: FnMut(&ComponentInterface, toml::Value) -> Result<Config>,
        Config: Default,
    {
        cis.into_iter()
            .map(|ci| {
                let toml = self.bindgen_paths.get_config(ci.crate_name())?;
                let config = parse_config(&ci, toml.into())?;
                Ok(Component { ci, config })
            })
            .collect()
    }

    
    pub fn load_pipeline_initial_root(
        &self,
        source_path: &Utf8Path,
        metadata: MetadataGroupMap,
    ) -> Result<pipeline::initial::Root> {
        let mut metadata_converter = pipeline::initial::UniffiMetaConverter::default();
        for metadata_group in metadata.into_values() {
            let table = self
                .bindgen_paths
                .get_config(&metadata_group.namespace.crate_name)?;
            if !table.is_empty() {
                metadata_converter
                    .add_module_config_toml(metadata_group.namespace.name.clone(), table)?;
            }
            if let Some(docstring) = metadata_group.namespace_docstring {
                metadata_converter
                    .add_module_docstring(metadata_group.namespace.name.clone(), docstring)?;
            }
            metadata_converter.add_metadata_item(Metadata::Namespace(metadata_group.namespace))?;
            for meta in metadata_group.items {
                metadata_converter.add_metadata_item(meta)?;
            }
        }
        let mut root = metadata_converter.try_into_initial_ir()?;
        root.cdylib = self.library_name(source_path).map(str::to_string);
        Ok(root)
    }

    
    
    
    
    pub fn source_basename<'a>(&self, source_path: &'a Utf8Path) -> &'a str {
        let mut basename = match source_path.file_stem() {
            Some(stem) => stem,
            None => source_path.as_str(),
        };
        if !self.is_udl(source_path) {
            basename = match basename.strip_prefix("lib") {
                Some(name) => name,
                None => basename,
            }
        };
        basename
    }

    fn is_udl(&self, source_path: &Utf8Path) -> bool {
        matches!(
            source_path.extension(),
            Some(ext) if ext.to_lowercase() == "udl"
        )
    }

    
    pub fn library_name<'a>(&self, source_path: &'a Utf8Path) -> Option<&'a str> {
        let is_library = !self.is_udl(source_path);
        is_library.then(|| self.source_basename(source_path))
    }
}
