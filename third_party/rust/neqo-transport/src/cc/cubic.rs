







use std::{
    fmt::{self, Display},
    time::{Duration, Instant},
};

use neqo_common::{qdebug, qtrace};

use crate::cc::{classic_cc::WindowAdjustment, CongestionEvent};




pub fn convert_to_f64(v: usize) -> f64 {
    let mut f_64 = f64::from(u32::try_from(v >> 21).unwrap_or(u32::MAX));
    f_64 *= 2_097_152.0; 
    #[expect(clippy::cast_possible_truncation, reason = "The mask makes this safe.")]
    let v_trunc = (v & 0x1f_ffff) as u32;
    f_64 += f64::from(v_trunc);
    f_64
}

#[derive(Debug, Default, Clone)]
pub struct State {
    
    
    
    
    
    
    
    
    
    
    w_est: f64,
    
    
    
    
    
    
    
    
    
    
    k: f64,
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    w_max: f64,
    
    
    
    
    
    t_epoch: Option<Instant>,
    
    reno_acked_bytes: f64,
}

impl Display for State {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "state [w_max: {}, k: {}, t_epoch: {:?}]",
            self.w_max, self.k, self.t_epoch
        )?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct Cubic {
    
    current: State,
    
    
    stored: Option<State>,
}

impl Display for Cubic {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Cubic {}", self.current)
    }
}

impl Cubic {
    
    
    
    
    
    
    
    
    pub const C: f64 = 0.4;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub const ALPHA: f64 = 3.0 * (1.0 - 0.7) / (1.0 + 0.7); 

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub const BETA_USIZE_DIVISOR: usize = 100;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub const BETA_USIZE_DIVIDEND: usize = 70;

    
    
    
    
    
    
    
    
    
    pub const BETA_USIZE_DIVIDEND_ECN: usize = 85;

    
    
    
    
    
    
    
    pub const FAST_CONVERGENCE_FACTOR: f64 = f64::midpoint(1.0, 0.7);

    
    
    
    
    
    
    
    
    
    
    
    
    
    fn calc_k(&self, cwnd_epoch: f64, max_datagram_size: f64) -> f64 {
        ((self.current.w_max - cwnd_epoch) / max_datagram_size / Self::C).cbrt()
    }

    
    
    
    
    
    
    
    
    
    
    fn w_cubic(&self, t: f64, max_datagram_size: f64) -> f64 {
        (Self::C * (t - self.current.k).powi(3)).mul_add(max_datagram_size, self.current.w_max)
    }

    
    
    
    
    
    
    
    
    
    
    fn start_epoch(
        &mut self,
        curr_cwnd: f64,
        new_acked_bytes: f64,
        max_datagram_size: f64,
        now: Instant,
    ) {
        self.current.t_epoch = Some(now);
        self.current.reno_acked_bytes = new_acked_bytes;
        self.current.w_est = curr_cwnd;
        
        
        
        
        
        
        self.current.k = if self.current.w_max <= curr_cwnd {
            self.current.w_max = curr_cwnd;
            0.0
        } else {
            self.calc_k(curr_cwnd, max_datagram_size)
        };
        qtrace!("[{self}] New epoch");
    }

    #[cfg(test)]
    pub const fn w_max(&self) -> f64 {
        self.current.w_max
    }

    #[cfg(test)]
    pub const fn set_w_max(&mut self, w_max: f64) {
        self.current.w_max = w_max;
    }
}

impl WindowAdjustment for Cubic {
    #[expect(
        clippy::cast_possible_truncation,
        clippy::cast_sign_loss,
        reason = "Cast from f64 to usize."
    )]
    fn bytes_for_cwnd_increase(
        &mut self,
        curr_cwnd: usize,
        new_acked_bytes: usize,
        min_rtt: Duration,
        max_datagram_size: usize,
        now: Instant,
    ) -> usize {
        let curr_cwnd = convert_to_f64(curr_cwnd);
        let new_acked_bytes = convert_to_f64(new_acked_bytes);
        let max_datagram_size = convert_to_f64(max_datagram_size);

        let t_epoch = if let Some(t) = self.current.t_epoch {
            self.current.reno_acked_bytes += new_acked_bytes;
            t
        } else {
            
            
            
            
            
            
            
            
            
            self.start_epoch(curr_cwnd, new_acked_bytes, max_datagram_size, now);
            self.current
                .t_epoch
                .expect("unwrapping `None` value -- it should've been set by `start_epoch`")
        };

        
        
        
        
        
        
        
        
        
        
        
        let t = now.saturating_duration_since(t_epoch);
        
        let target_cubic = f64::clamp(
            self.w_cubic((t + min_rtt).as_secs_f64(), max_datagram_size),
            curr_cwnd,
            curr_cwnd * 1.5,
        );

        
        
        
        
        
        
        
        
        
        

        
        let increase = (Self::ALPHA * self.current.reno_acked_bytes / curr_cwnd).floor();

        
        if increase > 0.0 {
            self.current.w_est += increase * max_datagram_size;
            
            
            let acked_bytes_used = increase * curr_cwnd / Self::ALPHA;
            self.current.reno_acked_bytes -= acked_bytes_used;
        }

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        let target = target_cubic.max(self.current.w_est);

        let cwnd_increase = target - curr_cwnd;

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        (max_datagram_size * curr_cwnd / cwnd_increase.max(1.0)) as usize
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    fn reduce_cwnd(
        &mut self,
        curr_cwnd: usize,
        acked_bytes: usize,
        max_datagram_size: usize,
        congestion_event: CongestionEvent,
    ) -> (usize, usize) {
        let curr_cwnd_f64 = convert_to_f64(curr_cwnd);
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        self.current.w_max =
            if curr_cwnd_f64 + convert_to_f64(max_datagram_size) < self.current.w_max {
                curr_cwnd_f64 * Self::FAST_CONVERGENCE_FACTOR
            } else {
                curr_cwnd_f64
            };

        
        self.current.t_epoch = None;
        let beta_dividend = if congestion_event == CongestionEvent::Ecn {
            Self::BETA_USIZE_DIVIDEND_ECN
        } else {
            Self::BETA_USIZE_DIVIDEND
        };
        (
            curr_cwnd * beta_dividend / Self::BETA_USIZE_DIVISOR,
            acked_bytes * beta_dividend / Self::BETA_USIZE_DIVISOR,
        )
    }

    fn on_app_limited(&mut self) {
        
        
        self.current.t_epoch = None;
    }

    fn save_undo_state(&mut self) {
        self.stored = Some(self.current.clone());
    }

    fn restore_undo_state(&mut self) {
        let Some(stored) = self.stored.take() else {
            debug_assert!(false, "couldn't restore {self} specific undo state");
            return;
        };

        qdebug!(
            "Spurious cong event: recovering cubic state from {} to {stored}",
            self.current
        );
        self.current = stored;
    }
}
