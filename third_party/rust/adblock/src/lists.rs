

use std::convert::TryFrom;

use crate::filters::cosmetic::{CosmeticFilter, CosmeticFilterError};
use crate::filters::network::{NetworkFilter, NetworkFilterError};
use crate::resources::PermissionMask;

use itertools::{Either, Itertools};
use memchr::memchr as find_char;
use serde::{Deserialize, Serialize};
use thiserror::Error;


#[derive(Debug, Clone, Copy, Serialize, Deserialize, Default)]
pub enum RuleTypes {
    #[default]
    All,
    NetworkOnly,
    CosmeticOnly,
}

impl RuleTypes {
    pub fn loads_network_rules(&self) -> bool {
        matches!(self, Self::All | Self::NetworkOnly)
    }

    pub fn loads_cosmetic_rules(&self) -> bool {
        matches!(self, Self::All | Self::CosmeticOnly)
    }
}












#[derive(Copy, Clone, Deserialize)]
pub struct ParseOptions {
    
    #[serde(default)]
    pub format: FilterFormat,
    
    
    
    
    
    #[serde(default)]
    pub rule_types: RuleTypes,
    
    
    #[serde(default)]
    pub permissions: PermissionMask,
}

impl Default for ParseOptions {
    fn default() -> Self {
        ParseOptions {
            format: FilterFormat::Standard,
            rule_types: RuleTypes::All,
            permissions: PermissionMask::default(),
        }
    }
}






#[derive(Clone)]
pub struct FilterSet {
    debug: bool,
    pub(crate) network_filters: Vec<NetworkFilter>,
    pub(crate) cosmetic_filters: Vec<CosmeticFilter>,
}


pub fn read_list_metadata(list: &str) -> FilterListMetadata {
    let mut metadata = FilterListMetadata::default();

    
    let mut cutoff = list.len().min(1024);

    while !list.is_char_boundary(cutoff) {
        cutoff -= 1;
    }

    
    for line in list[0..cutoff].lines() {
        if line.starts_with('!') {
            metadata.try_add(line);
        } else if line.starts_with('[') {
            continue;
        } else {
            break;
        }
    }

    metadata
}

impl Default for FilterSet {
    
    
    fn default() -> Self {
        #[cfg(not(test))]
        let debug = false;

        #[cfg(test)]
        let debug = true;

        Self::new(debug)
    }
}


#[derive(Debug, PartialEq, Serialize)]
pub enum ExpiresInterval {
    Hours(u16),
    Days(u8),
}

impl TryFrom<&str> for ExpiresInterval {
    type Error = ();

    fn try_from(v: &str) -> Result<Self, ()> {
        const DAYS_MAX: u8 = 14;
        const HOURS_MAX: u16 = DAYS_MAX as u16 * 24;

        
        let mut v_split = v.split(' ');
        let amount = v_split.next().ok_or(())?;
        let unit = v_split.next().ok_or(())?;
        
        if amount.starts_with('+') {
            return Err(());
        }
        
        match unit {
            "hour" | "hours" => {
                let amount = amount.parse::<u16>().map_err(|_| ())?;
                if (1..=HOURS_MAX).contains(&amount) {
                    return Ok(Self::Hours(amount));
                }
            }
            "day" | "days" => {
                let amount = amount.parse::<u8>().map_err(|_| ())?;
                if (1..=DAYS_MAX).contains(&amount) {
                    return Ok(Self::Days(amount));
                }
            }
            _ => (),
        }
        Err(())
    }
}



#[derive(Default, Serialize)]
pub struct FilterListMetadata {
    
    
    pub homepage: Option<String>,
    
    
    pub title: Option<String>,
    
    
    
    
    
    pub expires: Option<ExpiresInterval>,
    
    
    
    
    
    
    pub redirect: Option<String>,
}

impl FilterListMetadata {
    
    
    
    fn try_add(&mut self, line: &str) {
        if let Some(kv) = line.strip_prefix("! ") {
            if let Some((key, value)) = kv.split_once(": ") {
                match key {
                    "Homepage" if self.homepage.is_none() => {
                        self.homepage = Some(value.to_string())
                    }
                    "Title" if self.title.is_none() => self.title = Some(value.to_string()),
                    "Expires" if self.expires.is_none() => {
                        if let Ok(expires) = ExpiresInterval::try_from(value) {
                            self.expires = Some(expires);
                        }
                    }
                    "Redirect" if self.redirect.is_none() => {
                        self.redirect = Some(value.to_string())
                    }
                    _ => (),
                }
            }
        }
    }
}

impl FilterSet {
    
    
    
    pub fn new(debug: bool) -> Self {
        Self {
            debug,
            network_filters: Vec::new(),
            cosmetic_filters: Vec::new(),
        }
    }

    
    #[doc(hidden)]
    pub fn new_with_rules(
        network_filters: Vec<NetworkFilter>,
        cosmetic_filters: Vec<CosmeticFilter>,
        debug: bool,
    ) -> Self {
        Self {
            debug,
            network_filters,
            cosmetic_filters,
        }
    }

    
    
    
    pub fn add_filter_list(&mut self, filter_list: &str, opts: ParseOptions) -> FilterListMetadata {
        self.add_filters(filter_list.lines(), opts)
    }

    
    
    pub fn add_filters(
        &mut self,
        filters: impl IntoIterator<Item = impl AsRef<str>>,
        opts: ParseOptions,
    ) -> FilterListMetadata {
        let (metadata, parsed_network_filters, parsed_cosmetic_filters) =
            parse_filters_with_metadata(filters, self.debug, opts);
        self.network_filters.extend(parsed_network_filters);
        self.cosmetic_filters.extend(parsed_cosmetic_filters);
        metadata
    }

    
    pub fn add_filter(&mut self, filter: &str, opts: ParseOptions) -> Result<(), FilterParseError> {
        let filter_parsed = parse_filter(filter, self.debug, opts);
        match filter_parsed? {
            ParsedFilter::Network(filter) => self.network_filters.push(filter),
            ParsedFilter::Cosmetic(filter) => self.cosmetic_filters.push(filter),
        }
        Ok(())
    }

    
    
    
    
    
    
    
    
    #[cfg(feature = "content-blocking")]
    #[allow(clippy::result_unit_err)]
    pub fn into_content_blocking(
        self,
    ) -> Result<(Vec<crate::content_blocking::CbRule>, Vec<String>), ()> {
        use crate::content_blocking;
        use crate::filters::network::NetworkFilterMaskHelper;
        use std::collections::HashSet;

        if !self.debug {
            return Err(());
        }

        
        let mut bad_filter_ids = HashSet::new();
        for filter in self.network_filters.iter() {
            if filter.is_badfilter() {
                bad_filter_ids.insert(filter.get_id_without_badfilter());
            }
        }

        let mut ignore_previous_rules = vec![];
        let mut other_rules = vec![];

        let mut filters_used = vec![];

        self.network_filters.into_iter().for_each(|filter| {
            
            if bad_filter_ids.contains(&filter.get_id()) || filter.is_badfilter() {
                return;
            }
            let original_rule = *filter
                .raw_line
                .clone()
                .expect("All rules should be in debug mode");
            if let Ok(equivalent) = TryInto::<content_blocking::CbRuleEquivalent>::try_into(filter)
            {
                filters_used.push(original_rule);
                equivalent
                    .into_iter()
                    .for_each(|cb_rule| match &cb_rule.action.typ {
                        content_blocking::CbType::IgnorePreviousRules => {
                            ignore_previous_rules.push(cb_rule)
                        }
                        _ => other_rules.push(cb_rule),
                    });
            }
        });

        let add_fp_document_exception = !filters_used.is_empty();

        self.cosmetic_filters.into_iter().for_each(|filter| {
            let original_rule = *filter
                .raw_line
                .clone()
                .expect("All rules should be in debug mode");
            if let Ok(cb_rule) = TryInto::<content_blocking::CbRule>::try_into(filter) {
                filters_used.push(original_rule);
                match &cb_rule.action.typ {
                    content_blocking::CbType::IgnorePreviousRules => {
                        ignore_previous_rules.push(cb_rule)
                    }
                    _ => other_rules.push(cb_rule),
                }
            }
        });

        other_rules.extend(ignore_previous_rules);

        if add_fp_document_exception {
            other_rules.push(content_blocking::ignore_previous_fp_documents());
        }

        Ok((other_rules, filters_used))
    }
}


#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum FilterFormat {
    
    Standard,
    
    
    
    
    
    
    
    
    
    
    Hosts,
}


impl Default for FilterFormat {
    fn default() -> Self {
        Self::Standard
    }
}


#[derive(Debug, PartialEq)]
pub enum FilterType {
    
    Network,
    
    Cosmetic,
    
    NotSupported,
}


pub enum ParsedFilter {
    Network(NetworkFilter),
    Cosmetic(CosmeticFilter),
}

impl From<NetworkFilter> for ParsedFilter {
    fn from(v: NetworkFilter) -> Self {
        ParsedFilter::Network(v)
    }
}

impl From<CosmeticFilter> for ParsedFilter {
    fn from(v: CosmeticFilter) -> Self {
        ParsedFilter::Cosmetic(v)
    }
}


#[derive(Debug, Error)]
pub enum FilterParseError {
    #[error("network filter error: {0}")]
    Network(#[source] NetworkFilterError),
    #[error("cosmetic filter error: {0}")]
    Cosmetic(#[source] CosmeticFilterError),
    #[error("unsupported")]
    Unsupported,
    #[error("empty")]
    Empty,
}

impl From<NetworkFilterError> for FilterParseError {
    fn from(v: NetworkFilterError) -> Self {
        FilterParseError::Network(v)
    }
}

impl From<CosmeticFilterError> for FilterParseError {
    fn from(v: CosmeticFilterError) -> Self {
        FilterParseError::Cosmetic(v)
    }
}


pub fn parse_filter(
    line: &str,
    debug: bool,
    opts: ParseOptions,
) -> Result<ParsedFilter, FilterParseError> {
    let filter = line.trim();

    if filter.is_empty() {
        return Err(FilterParseError::Empty);
    }

    match opts.format {
        FilterFormat::Standard => match (detect_filter_type(filter), opts.rule_types) {
            (FilterType::Network, RuleTypes::All | RuleTypes::NetworkOnly) => {
                NetworkFilter::parse(filter, debug, opts)
                    .map(|f| f.into())
                    .map_err(|e| e.into())
            }
            (FilterType::Cosmetic, RuleTypes::All | RuleTypes::CosmeticOnly) => {
                CosmeticFilter::parse(filter, debug, opts.permissions)
                    .map(|f| f.into())
                    .map_err(|e| e.into())
            }
            _ => Err(FilterParseError::Unsupported),
        },
        FilterFormat::Hosts => {
            
            if !opts.rule_types.loads_network_rules() {
                return Err(FilterParseError::Unsupported);
            }
            if filter.starts_with('!') {
                return Err(FilterParseError::Unsupported);
            }
            
            let filter = if let Some(hash_loc) = find_char(b'#', filter.as_bytes()) {
                let filter = &filter[..hash_loc];
                let filter = filter.trim();

                if filter.is_empty() {
                    return Err(FilterParseError::Unsupported);
                }

                filter
            } else {
                filter
            };

            
            let mut filter_parts = filter.split_whitespace();
            let hostname = match (
                filter_parts.next(),
                filter_parts.next(),
                filter_parts.next(),
            ) {
                (None, None, None) => return Err(FilterParseError::Unsupported),
                (Some(hostname), None, None) => hostname,
                (Some(_ip), Some(hostname), None) => hostname,
                (Some(_), Some(_), Some(_)) => return Err(FilterParseError::Unsupported),
                _ => unreachable!(),
            };

            
            
            
            if hostname == "localhost" {
                return Err(FilterParseError::Unsupported);
            }

            NetworkFilter::parse_hosts_style(hostname, debug)
                .map(|f| f.into())
                .map_err(|e| e.into())
        }
    }
}


pub fn parse_filters(
    list: impl IntoIterator<Item = impl AsRef<str>>,
    debug: bool,
    opts: ParseOptions,
) -> (Vec<NetworkFilter>, Vec<CosmeticFilter>) {
    let (_metadata, network_filters, cosmetic_filters) =
        parse_filters_with_metadata(list, debug, opts);

    (network_filters, cosmetic_filters)
}


pub fn parse_filters_with_metadata(
    list: impl IntoIterator<Item = impl AsRef<str>>,
    debug: bool,
    opts: ParseOptions,
) -> (FilterListMetadata, Vec<NetworkFilter>, Vec<CosmeticFilter>) {
    let mut metadata = FilterListMetadata::default();

    let list_iter = list.into_iter();

    let (network_filters, cosmetic_filters): (Vec<_>, Vec<_>) = list_iter
        .map(|line| {
            metadata.try_add(line.as_ref());
            parse_filter(line.as_ref(), debug, opts)
        })
        .filter_map(Result::ok)
        .partition_map(|filter| match filter {
            ParsedFilter::Network(f) => Either::Left(f),
            ParsedFilter::Cosmetic(f) => Either::Right(f),
        });

    (metadata, network_filters, cosmetic_filters)
}





fn detect_filter_type(filter: &str) -> FilterType {
    
    if filter.len() == 1
        || filter.starts_with('!')
        || (filter.starts_with('#') && filter[1..].starts_with(char::is_whitespace))
        || filter.starts_with("[Adblock")
    {
        return FilterType::NotSupported;
    }

    if filter.starts_with('|') || filter.starts_with("@@|") {
        return FilterType::Network;
    }

    
    if let Some(sharp_index) = find_char(b'#', filter.as_bytes()) {
        let after_sharp_index = sharp_index + 1;

        
        
        
        if find_char(
            b'#',
            &filter.as_bytes()[after_sharp_index..(after_sharp_index + 4).min(filter.len())],
        )
        .is_some()
        {
            return FilterType::Cosmetic;
        }
    }

    
    if filter.contains("$$") {
        return FilterType::NotSupported;
    }

    
    FilterType::Network
}

#[cfg(test)]
#[path = "../tests/unit/lists.rs"]
mod unit_tests;
