






use memchr::memmem;

use crate::filters::network::{NetworkFilterMask, NetworkFilterMaskHelper};
use crate::regex_manager::RegexManager;
use crate::request;
use crate::utils::{self, Hash};
use std::collections::HashMap;

fn get_url_after_hostname<'a>(url: &'a str, hostname: &str) -> &'a str {
    let start =
        memmem::find(url.as_bytes(), hostname.as_bytes()).unwrap_or(url.len() - hostname.len());
    &url[start + hostname.len()..]
}





fn is_anchored_by_hostname(
    filter_hostname: &str,
    hostname: &str,
    wildcard_filter_hostname: bool,
) -> bool {
    let filter_hostname_len = filter_hostname.len();
    
    if filter_hostname_len == 0 {
        return true;
    }
    let hostname_len = hostname.len();

    if filter_hostname_len > hostname_len {
        
        false
    } else if filter_hostname_len == hostname_len {
        
        filter_hostname == hostname
    } else if let Some(match_index) = memmem::find(hostname.as_bytes(), filter_hostname.as_bytes())
    {
        if match_index == 0 {
            
            
            
            
            
            wildcard_filter_hostname
                || filter_hostname.ends_with('.')
                || hostname[filter_hostname_len..].starts_with('.')
        } else if match_index == hostname_len - filter_hostname_len {
            
            
            
            
            
            filter_hostname.starts_with('.') || hostname[match_index - 1..].starts_with('.')
        } else {
            
            (wildcard_filter_hostname
                || filter_hostname.ends_with('.')
                || hostname[filter_hostname_len..].starts_with('.'))
                && (filter_hostname.starts_with('.')
                    || hostname[match_index - 1..].starts_with('.'))
        }
    } else {
        
        false
    }
}


fn check_pattern_plain_filter_filter<'a, FiltersIter>(
    mask: NetworkFilterMask,
    mut filters: FiltersIter,
    request: &request::Request,
) -> bool
where
    FiltersIter: Iterator<Item = &'a str> + ExactSizeIterator,
{
    if filters.len() == 0 {
        return true;
    }

    let request_url = request.get_url(mask.match_case());
    filters.any(|f| memmem::find(request_url.as_bytes(), f.as_bytes()).is_some())
}


fn check_pattern_right_anchor_filter<'a, FiltersIter>(
    mask: NetworkFilterMask,
    mut filters: FiltersIter,
    request: &request::Request,
) -> bool
where
    FiltersIter: Iterator<Item = &'a str> + ExactSizeIterator,
{
    if filters.len() == 0 {
        return true;
    }
    let request_url = request.get_url(mask.match_case());
    filters.any(|f| request_url.ends_with(f))
}


fn check_pattern_left_anchor_filter<'a, FiltersIter>(
    mask: NetworkFilterMask,
    mut filters: FiltersIter,
    request: &request::Request,
) -> bool
where
    FiltersIter: Iterator<Item = &'a str> + ExactSizeIterator,
{
    if filters.len() == 0 {
        return true;
    }
    let request_url = request.get_url(mask.match_case());
    filters.any(|f| request_url.starts_with(f))
}


fn check_pattern_left_right_anchor_filter<'a, FiltersIter>(
    mask: NetworkFilterMask,
    mut filters: FiltersIter,
    request: &request::Request,
) -> bool
where
    FiltersIter: Iterator<Item = &'a str> + ExactSizeIterator,
{
    if filters.len() == 0 {
        return true;
    }
    let request_url = request.get_url(mask.match_case());
    filters.any(|f| request_url == f)
}


fn check_pattern_regex_filter_at<'a, FiltersIter>(
    mask: NetworkFilterMask,
    filters: FiltersIter,
    key: u64,
    request: &request::Request,
    start_from: usize,
    regex_manager: &mut RegexManager,
) -> bool
where
    FiltersIter: Iterator<Item = &'a str> + ExactSizeIterator,
{
    let request_url = request.get_url(mask.match_case());
    regex_manager.matches(mask, filters, key, &request_url[start_from..])
}

fn check_pattern_regex_filter<'a, FiltersIter>(
    mask: NetworkFilterMask,
    filters: FiltersIter,
    key: u64,
    request: &request::Request,
    regex_manager: &mut RegexManager,
) -> bool
where
    FiltersIter: Iterator<Item = &'a str> + ExactSizeIterator,
{
    check_pattern_regex_filter_at(mask, filters, key, request, 0, regex_manager)
}


fn check_pattern_hostname_anchor_regex_filter<'a, FiltersIter>(
    mask: NetworkFilterMask,
    filters: FiltersIter,
    hostname: Option<&'a str>,
    key: u64,
    request: &request::Request,
    regex_manager: &mut RegexManager,
) -> bool
where
    FiltersIter: Iterator<Item = &'a str> + ExactSizeIterator,
{
    let request_url = request.get_url(mask.match_case());
    hostname
        .as_ref()
        .map(|hostname| {
            if is_anchored_by_hostname(
                hostname,
                &request.hostname,
                mask.contains(NetworkFilterMask::IS_HOSTNAME_REGEX),
            ) {
                check_pattern_regex_filter_at(
                    mask,
                    filters,
                    key,
                    request,
                    memmem::find(request_url.as_bytes(), hostname.as_bytes()).unwrap_or_default()
                        + hostname.len(),
                    regex_manager,
                )
            } else {
                false
            }
        })
        .unwrap_or_else(|| unreachable!()) 
}


fn check_pattern_hostname_right_anchor_filter<'a, FiltersIter>(
    mask: NetworkFilterMask,
    filters: FiltersIter,
    hostname: Option<&'a str>,
    request: &request::Request,
) -> bool
where
    FiltersIter: Iterator<Item = &'a str> + ExactSizeIterator,
{
    hostname
        .as_ref()
        .map(|hostname| {
            if is_anchored_by_hostname(
                hostname,
                &request.hostname,
                mask.contains(NetworkFilterMask::IS_HOSTNAME_REGEX),
            ) {
                if filters.len() == 0 {
                    
                    
                    
                    
                    request.hostname.len() == hostname.len()        
                          || request.hostname.ends_with(hostname)
                } else {
                    check_pattern_right_anchor_filter(mask, filters, request)
                }
            } else {
                false
            }
        })
        .unwrap_or_else(|| unreachable!()) 
}


fn check_pattern_hostname_left_right_anchor_filter<'a, FiltersIter>(
    mask: NetworkFilterMask,
    mut filters: FiltersIter,
    hostname: Option<&'a str>,
    request: &request::Request,
) -> bool
where
    FiltersIter: Iterator<Item = &'a str> + ExactSizeIterator,
{
    
    
    

    hostname
        .as_ref()
        .map(|hostname| {
            if is_anchored_by_hostname(
                hostname,
                &request.hostname,
                mask.contains(NetworkFilterMask::IS_HOSTNAME_REGEX),
            ) {
                let request_url = request.get_url(mask.match_case());
                if filters.len() == 0 {
                    return true;
                }
                let url_after_hostname = get_url_after_hostname(request_url, hostname);
                filters.any(|f| {
                    
                    
                    
                    url_after_hostname == f
                })
            } else {
                false
            }
        })
        .unwrap_or_else(|| unreachable!()) 
}



fn check_pattern_hostname_left_anchor_filter<'a, FiltersIter>(
    mask: NetworkFilterMask,
    mut filters: FiltersIter,
    hostname: Option<&'a str>,
    request: &request::Request,
) -> bool
where
    FiltersIter: Iterator<Item = &'a str> + ExactSizeIterator,
{
    hostname
        .as_ref()
        .map(|hostname| {
            if is_anchored_by_hostname(
                hostname,
                &request.hostname,
                mask.contains(NetworkFilterMask::IS_HOSTNAME_REGEX),
            ) {
                if filters.len() == 0 {
                    return true;
                }
                let request_url = request.get_url(mask.match_case());
                let url_after_hostname = get_url_after_hostname(request_url, hostname);
                filters.any(|f| {
                    
                    
                    
                    url_after_hostname.starts_with(f)
                })
            } else {
                false
            }
        })
        .unwrap_or_else(|| unreachable!()) 
}


fn check_pattern_hostname_anchor_filter<'a, FiltersIter>(
    mask: NetworkFilterMask,
    mut filters: FiltersIter,
    hostname: Option<&'a str>,
    request: &request::Request,
) -> bool
where
    FiltersIter: Iterator<Item = &'a str> + ExactSizeIterator,
{
    hostname
        .as_ref()
        .map(|hostname| {
            if is_anchored_by_hostname(
                hostname,
                &request.hostname,
                mask.contains(NetworkFilterMask::IS_HOSTNAME_REGEX),
            ) {
                if filters.len() == 0 {
                    return true;
                }
                let request_url = request.get_url(mask.match_case());
                let url_after_hostname = get_url_after_hostname(request_url, hostname);
                filters.any(|f| {
                    
                    url_after_hostname.contains(f)
                })
            } else {
                false
            }
        })
        .unwrap_or_else(|| unreachable!()) 
}



pub fn check_pattern<'a, FiltersIter>(
    mask: NetworkFilterMask,
    filters: FiltersIter,
    hostname: Option<&'a str>,
    key: u64,
    request: &request::Request,
    regex_manager: &mut RegexManager,
) -> bool
where
    FiltersIter: Iterator<Item = &'a str> + ExactSizeIterator,
{
    if mask.is_hostname_anchor() {
        if mask.is_regex() {
            check_pattern_hostname_anchor_regex_filter(
                mask,
                filters,
                hostname,
                key,
                request,
                regex_manager,
            )
        } else if mask.is_right_anchor() && mask.is_left_anchor() {
            check_pattern_hostname_left_right_anchor_filter(mask, filters, hostname, request)
        } else if mask.is_right_anchor() {
            check_pattern_hostname_right_anchor_filter(mask, filters, hostname, request)
        } else if mask.is_left_anchor() {
            check_pattern_hostname_left_anchor_filter(mask, filters, hostname, request)
        } else {
            check_pattern_hostname_anchor_filter(mask, filters, hostname, request)
        }
    } else if mask.is_regex() || mask.is_complete_regex() {
        check_pattern_regex_filter(mask, filters, key, request, regex_manager)
    } else if mask.is_left_anchor() && mask.is_right_anchor() {
        check_pattern_left_right_anchor_filter(mask, filters, request)
    } else if mask.is_left_anchor() {
        check_pattern_left_anchor_filter(mask, filters, request)
    } else if mask.is_right_anchor() {
        check_pattern_right_anchor_filter(mask, filters, request)
    } else {
        check_pattern_plain_filter_filter(mask, filters, request)
    }
}

#[inline]
pub fn check_options(mask: NetworkFilterMask, request: &request::Request) -> bool {
    
    if mask.is_badfilter() {
        return false;
    }
    
    
    if !mask.check_cpt_allowed(&request.request_type)
        || (request.is_https && !mask.for_https())
        || (request.is_http && !mask.for_http())
        || (!mask.first_party() && !request.is_third_party)
        || (!mask.third_party() && request.is_third_party)
    {
        return false;
    }
    true
}

#[inline]
pub fn check_included_domains_mapped(
    opt_domains: Option<&[u32]>,
    request: &request::Request,
    mapping: &HashMap<Hash, u32>,
) -> bool {
    
    if let Some(included_domains) = opt_domains.as_ref() {
        if let Some(source_hashes) = request.source_hostname_hashes.as_ref() {
            if source_hashes.iter().all(|h| {
                mapping
                    .get(h)
                    .is_none_or(|index| !utils::bin_lookup(included_domains, *index))
            }) {
                return false;
            }
        } else {
            
            return false;
        }
    }
    true
}

#[inline]
pub fn check_excluded_domains_mapped(
    opt_not_domains: Option<&[u32]>,
    request: &request::Request,
    mapping: &HashMap<Hash, u32>,
) -> bool {
    if let Some(excluded_domains) = opt_not_domains.as_ref() {
        if let Some(source_hashes) = request.source_hostname_hashes.as_ref() {
            if source_hashes.iter().any(|h| {
                mapping
                    .get(h)
                    .is_some_and(|index| utils::bin_lookup(excluded_domains, *index))
            }) {
                return false;
            }
        } else {
            
            
            return true;
        }
    }

    true
}

#[cfg(test)]
#[path = "../../tests/unit/filters/network_matchers.rs"]
mod unit_tests;
