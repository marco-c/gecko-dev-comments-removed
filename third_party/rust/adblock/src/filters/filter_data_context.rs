use crate::flatbuffers::unsafe_tools::VerifiedFlatbufferMemory;
use crate::utils::Hash;
use std::collections::HashMap;

#[cfg(feature = "single-thread")]
pub(crate) type FilterDataContextRef = std::rc::Rc<FilterDataContext>;
#[cfg(not(feature = "single-thread"))]
pub(crate) type FilterDataContextRef = std::sync::Arc<FilterDataContext>;




pub(crate) struct FilterDataContext {
    pub(crate) memory: VerifiedFlatbufferMemory,
    pub(crate) unique_domains_hashes_map: HashMap<Hash, u32>,
}

impl FilterDataContext {
    pub(crate) fn new(memory: VerifiedFlatbufferMemory) -> FilterDataContextRef {
        
        let root = memory.root();
        let mut unique_domains_hashes_map: HashMap<crate::utils::Hash, u32> = HashMap::new();
        for (index, hash) in root.unique_domains_hashes().iter().enumerate() {
            unique_domains_hashes_map.insert(hash, index as u32);
        }
        FilterDataContextRef::new(Self {
            memory,
            unique_domains_hashes_map,
        })
    }
}
