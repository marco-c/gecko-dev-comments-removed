




















mod imp {
    
    
    
    #[allow(unused)]
    pub use {
        ::core::{
            self, assert_eq, assert_ne,
            cell::UnsafeCell,
            convert::TryFrom,
            hash,
            marker::PhantomData,
            mem::{ManuallyDrop, MaybeUninit},
            option::IntoIter,
            prelude::v1::*,
            primitive::*,
        },
        ::std::{collections::hash_map::DefaultHasher, prelude::v1::*},
        ::zerocopy::*,
    };
}



pub mod util {
    
    pub struct NotZerocopy<T = ()>(pub T);

    
    
    
    
    #[derive(
        super::imp::KnownLayout,
        super::imp::Immutable,
        super::imp::FromBytes,
        super::imp::IntoBytes,
        Copy,
        Clone,
    )]
    #[repr(C, align(2))]
    pub struct AU16(pub u16);

    
    
    
    #[macro_export]
    macro_rules! util_assert_impl_all {
        ($type:ty: $($trait:path),+ $(,)?) => {
            const _: fn() = || {
                use ::core::prelude::v1::*;
                ::static_assertions::assert_impl_all!($type: $($trait),+);
            };
        };
    }

    
    
    
    #[macro_export]
    macro_rules! util_assert_not_impl_any {
        ($x:ty: $($t:path),+ $(,)?) => {
            const _: fn() = || {
                use ::core::prelude::v1::*;
                ::static_assertions::assert_not_impl_any!($x: $($t),+);
            };
        };
    }

    #[macro_export]
    macro_rules! test_trivial_is_bit_valid {
        ($x:ty => $name:ident) => {
            #[test]
            fn $name() {
                util::test_trivial_is_bit_valid::<$x>();
            }
        };
    }

    
    
    
    
    
    
    
    
    pub fn test_trivial_is_bit_valid<T: super::imp::TryFromBytes>() {
        
        
        
        
        
        
        
        

        let buf = super::imp::MaybeUninit::<T>::uninit();
        let ptr = super::imp::Ptr::from_ref(&buf);
        
        let ptr = unsafe { ptr.assume_initialized() };

        
        
        let ptr = unsafe { ptr.cast_unsized_unchecked(|p| p.cast_sized()) };
        assert!(<T as super::imp::TryFromBytes>::is_bit_valid(ptr));
    }
}
