use crate::common::{DebugMacinfoOffset, SectionId};
use crate::endianity::Endianity;
use crate::read::{EndianSlice, Reader, ReaderOffset, Section, UnitRef};
use crate::{
    constants, DebugLineOffset, DebugMacroOffset, DebugStrOffset, DebugStrOffsetsIndex, DwMacinfo,
    DwMacro, Error, Format, Result,
};


#[derive(Debug, Default, Clone, Copy)]
pub struct DebugMacinfo<R> {
    pub(crate) section: R,
}

impl<'input, Endian> DebugMacinfo<EndianSlice<'input, Endian>>
where
    Endian: Endianity,
{
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub fn new(macinfo_section: &'input [u8], endian: Endian) -> Self {
        Self::from(EndianSlice::new(macinfo_section, endian))
    }
}

impl<R: Reader> DebugMacinfo<R> {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub fn get_macinfo(&self, offset: DebugMacinfoOffset<R::Offset>) -> Result<MacroIter<R>> {
        let mut input = self.section.clone();
        input.skip(offset.0)?;
        Ok(MacroIter {
            input,
            format: Format::Dwarf32,
            is_macro: false,
        })
    }
}

impl<T> DebugMacinfo<T> {
    
    
    
    
    
    pub fn borrow<'a, F, R>(&'a self, mut borrow: F) -> DebugMacinfo<R>
    where
        F: FnMut(&'a T) -> R,
    {
        borrow(&self.section).into()
    }
}

impl<R> Section<R> for DebugMacinfo<R> {
    fn id() -> SectionId {
        SectionId::DebugMacinfo
    }

    fn reader(&self) -> &R {
        &self.section
    }
}

impl<R> From<R> for DebugMacinfo<R> {
    fn from(macinfo_section: R) -> Self {
        DebugMacinfo {
            section: macinfo_section,
        }
    }
}


#[derive(Debug, Default, Clone, Copy)]
pub struct DebugMacro<R> {
    pub(crate) section: R,
}

impl<'input, Endian> DebugMacro<EndianSlice<'input, Endian>>
where
    Endian: Endianity,
{
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub fn new(macro_section: &'input [u8], endian: Endian) -> Self {
        Self::from(EndianSlice::new(macro_section, endian))
    }
}

impl<R: Reader> DebugMacro<R> {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub fn get_macros(&self, offset: DebugMacroOffset<R::Offset>) -> Result<MacroIter<R>> {
        let mut input = self.section.clone();
        input.skip(offset.0)?;
        let header = MacroUnitHeader::parse(&mut input)?;
        Ok(MacroIter {
            input,
            format: header.format(),
            is_macro: true,
        })
    }
}

impl<T> DebugMacro<T> {
    
    
    
    
    
    pub fn borrow<'a, F, R>(&'a self, mut borrow: F) -> DebugMacro<R>
    where
        F: FnMut(&'a T) -> R,
    {
        borrow(&self.section).into()
    }
}

impl<R> Section<R> for DebugMacro<R> {
    fn id() -> SectionId {
        SectionId::DebugMacro
    }

    fn reader(&self) -> &R {
        &self.section
    }
}

impl<R> From<R> for DebugMacro<R> {
    fn from(macro_section: R) -> Self {
        DebugMacro {
            section: macro_section,
        }
    }
}

#[derive(Debug, Clone)]
struct MacroUnitHeader<R: Reader> {
    
    _version: u16,
    flags: u8,
    _debug_line_offset: DebugLineOffset<R::Offset>,
}

impl<R: Reader> MacroUnitHeader<R> {
    const OFFSET_SIZE_FLAG: u8 = 0b0000_0001;
    const DEBUG_LINE_OFFSET_FLAG: u8 = 0b0000_0010;
    const OPCODE_OPERANDS_TABLE_FLAG: u8 = 0b0000_0100;

    fn parse(input: &mut R) -> Result<Self> {
        let version = input.read_u16()?;
        let flags = input.read_u8()?;
        let format = if flags & Self::OFFSET_SIZE_FLAG == 0 {
            Format::Dwarf32
        } else {
            Format::Dwarf64
        };
        let _debug_line_offset = if flags & Self::DEBUG_LINE_OFFSET_FLAG != 0 {
            DebugLineOffset(input.read_offset(format)?)
        } else {
            DebugLineOffset(R::Offset::from_u64(0)?)
        };
        
        if flags & Self::OPCODE_OPERANDS_TABLE_FLAG != 0 {
            return Err(Error::UnsupportedOpcodeOperandsTable);
        }
        Ok(MacroUnitHeader {
            _version: version,
            flags,
            _debug_line_offset,
        })
    }

    fn format(&self) -> Format {
        if self.flags & Self::OFFSET_SIZE_FLAG == 0 {
            Format::Dwarf32
        } else {
            Format::Dwarf64
        }
    }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MacroString<R, Offset = <R as Reader>::Offset>
where
    R: Reader<Offset = Offset>,
    Offset: ReaderOffset,
{
    
    Direct(R),
    
    StringPointer(DebugStrOffset<Offset>),
    
    
    IndirectStringPointer(DebugStrOffsetsIndex<Offset>),
    
    Supplementary(DebugStrOffset<Offset>),
}

impl<R: Reader> MacroString<R> {
    
    pub fn string(&self, unit: UnitRef<'_, R>) -> Result<R> {
        match self {
            MacroString::Direct(s) => Ok(s.clone()),
            MacroString::StringPointer(offset) => unit.string(*offset),
            MacroString::IndirectStringPointer(index) => {
                let str_offset = unit.string_offset(*index)?;
                unit.string(str_offset)
            }
            MacroString::Supplementary(offset) => unit.sup_string(*offset),
        }
    }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MacroEntry<R, Offset = <R as Reader>::Offset>
where
    R: Reader<Offset = Offset>,
    Offset: ReaderOffset,
{
    
    Define {
        
        line: u64,
        
        
        text: MacroString<R>,
    },
    
    Undef {
        
        line: u64,
        
        name: MacroString<R>,
    },
    
    StartFile {
        
        line: u64,
        
        file: u64,
    },
    
    EndFile,
    
    Import {
        
        offset: DebugMacroOffset<Offset>,
    },
    
    ImportSup {
        
        offset: DebugMacroOffset<Offset>,
    },
    
    VendorExt {
        
        numeric: u64,
        
        string: R,
    },
}


#[derive(Clone, Debug)]
pub struct MacroIter<R: Reader> {
    input: R,
    format: Format,
    is_macro: bool,
}

impl<R: Reader> MacroIter<R> {
    
    pub fn next(&mut self) -> Result<Option<MacroEntry<R>>> {
        
        let macro_type = DwMacro(self.input.read_u8()?);
        match macro_type {
            DwMacro(0) => {
                self.input.empty();
                Ok(None)
            }
            constants::DW_MACRO_define => {
                let line = self.input.read_uleb128()?;
                let text = self.input.read_null_terminated_slice()?;
                Ok(Some(MacroEntry::Define {
                    line,
                    text: MacroString::Direct(text),
                }))
            }
            constants::DW_MACRO_undef => {
                let line = self.input.read_uleb128()?;
                let name = self.input.read_null_terminated_slice()?;
                Ok(Some(MacroEntry::Undef {
                    line,
                    name: MacroString::Direct(name),
                }))
            }
            constants::DW_MACRO_start_file => {
                let line = self.input.read_uleb128()?;
                let file = self.input.read_uleb128()?;
                Ok(Some(MacroEntry::StartFile { line, file }))
            }
            constants::DW_MACRO_end_file => Ok(Some(MacroEntry::EndFile)),
            constants::DW_MACRO_define_strp if self.is_macro => {
                let line = self.input.read_uleb128()?;
                let text_offset = DebugStrOffset(self.input.read_offset(self.format)?);
                Ok(Some(MacroEntry::Define {
                    line,
                    text: MacroString::StringPointer(text_offset),
                }))
            }
            constants::DW_MACRO_undef_strp if self.is_macro => {
                let line = self.input.read_uleb128()?;
                let name_offset = DebugStrOffset(self.input.read_offset(self.format)?);
                Ok(Some(MacroEntry::Undef {
                    line,
                    name: MacroString::StringPointer(name_offset),
                }))
            }
            constants::DW_MACRO_import if self.is_macro => {
                let offset = DebugMacroOffset(self.input.read_offset(self.format)?);
                Ok(Some(MacroEntry::Import { offset }))
            }
            constants::DW_MACRO_define_sup if self.is_macro => {
                let line = self.input.read_uleb128()?;
                let text_offset = DebugStrOffset(self.input.read_offset(self.format)?);
                Ok(Some(MacroEntry::Define {
                    line,
                    text: MacroString::Supplementary(text_offset),
                }))
            }
            constants::DW_MACRO_undef_sup if self.is_macro => {
                let line = self.input.read_uleb128()?;
                let name_offset = DebugStrOffset(self.input.read_offset(self.format)?);
                Ok(Some(MacroEntry::Undef {
                    line,
                    name: MacroString::Supplementary(name_offset),
                }))
            }
            constants::DW_MACRO_import_sup if self.is_macro => {
                let offset = DebugMacroOffset(self.input.read_offset(self.format)?);
                Ok(Some(MacroEntry::ImportSup { offset }))
            }
            constants::DW_MACRO_define_strx if self.is_macro => {
                let line = self.input.read_uleb128()?;
                let index = self.input.read_uleb128().and_then(R::Offset::from_u64)?;
                let text_index = DebugStrOffsetsIndex(index);
                Ok(Some(MacroEntry::Define {
                    line,
                    text: MacroString::IndirectStringPointer(text_index),
                }))
            }
            constants::DW_MACRO_undef_strx if self.is_macro => {
                let line = self.input.read_uleb128()?;
                let index = self.input.read_uleb128().and_then(R::Offset::from_u64)?;
                let name_index = DebugStrOffsetsIndex(index);
                Ok(Some(MacroEntry::Undef {
                    line,
                    name: MacroString::IndirectStringPointer(name_index),
                }))
            }
            _ => {
                if self.is_macro {
                    self.input.empty();
                    Err(Error::InvalidMacroType(macro_type))
                } else if macro_type.0 == constants::DW_MACINFO_vendor_ext.0 {
                    let numeric = self.input.read_uleb128()?;
                    let string = self.input.read_null_terminated_slice()?;
                    Ok(Some(MacroEntry::VendorExt { numeric, string }))
                } else {
                    self.input.empty();
                    Err(Error::InvalidMacinfoType(DwMacinfo(macro_type.0)))
                }
            }
        }
    }
}

#[cfg(feature = "fallible-iterator")]
impl<R: Reader> fallible_iterator::FallibleIterator for MacroIter<R> {
    type Item = MacroEntry<R>;
    type Error = Error;

    fn next(&mut self) -> ::core::result::Result<Option<Self::Item>, Error> {
        MacroIter::next(self)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{test_util::GimliSectionMethods, DebugStr, LittleEndian};
    use test_assembler::{Endian, Label, LabelMaker, Section};

    #[test]
    fn test_get_macinfo() {
        let position = Label::new();

        
        let section = Section::with_endian(Endian::Little)
            .set_start_const(0)
            .mark(&position)
            .D8(crate::DW_MACINFO_define.0)
            .uleb(0) 
            .append_bytes(b"__STDC__ 1\0")
            .D8(crate::DW_MACINFO_define.0)
            .uleb(1) 
            .append_bytes(b"__GNUC__ 1\0")
            .D8(crate::DW_MACINFO_undef.0)
            .uleb(2) 
            .append_bytes(b"__GNUC__\0")
            .D8(crate::DW_MACINFO_start_file.0)
            .uleb(3) 
            .uleb(4) 
            .D8(crate::DW_MACINFO_end_file.0) 
            .D8(crate::DW_MACINFO_vendor_ext.0)
            .uleb(5) 
            .append_bytes(b"foo\0")
            .D8(0); 

        
        let section = section.get_contents().unwrap();
        let debug_macinfo = DebugMacinfo::from(EndianSlice::new(&section, LittleEndian));

        let offset = position.value().unwrap() as usize;

        let mut iter = debug_macinfo
            .get_macinfo(DebugMacinfoOffset(offset))
            .unwrap();

        
        let entry = iter.next().unwrap().unwrap();
        assert!(
            matches!(entry, MacroEntry::Define { line: 0, text: MacroString::Direct(text) } if text.slice() == b"__STDC__ 1")
        );

        let entry = iter.next().unwrap().unwrap();
        assert!(
            matches!(entry, MacroEntry::Define { line: 1, text: MacroString::Direct(text) } if text.slice() == b"__GNUC__ 1")
        );

        let entry = iter.next().unwrap().unwrap();
        assert!(
            matches!(entry, MacroEntry::Undef { line: 2, name: MacroString::Direct(name) } if name.slice() == b"__GNUC__")
        );

        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::StartFile { line: 3, file: 4 }));

        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::EndFile));

        let entry = iter.next().unwrap().unwrap();
        assert!(
            matches!(entry, MacroEntry::VendorExt { numeric: 5, string } if string.slice() == b"foo")
        );

        assert_eq!(iter.next(), Ok(None));
    }

    #[test]
    fn get_macros_1() {
        let position = Label::new();

        
        
        let section = Section::with_endian(Endian::Little)
            .set_start_const(0)
            .mark(&position)
            .D16(5) 
            .D8(0b0000_0010) 
            .D32(0) 
            .D8(crate::DW_MACRO_start_file.0) 
            .uleb(0) 
            .uleb(0) 
            .D8(crate::DW_MACRO_start_file.0) 
            .uleb(1) 
            .uleb(1) 
            .D8(crate::DW_MACRO_define.0) 
            .uleb(1) 
            .append_bytes(b"LONGER_MACRO 1\0") 
            .D8(crate::DW_MACRO_define.0) 
            .uleb(2) 
            .append_bytes(b"B 2\0") 
            .D8(crate::DW_MACRO_start_file.0) 
            .uleb(3) 
            .uleb(2) 
            .D8(crate::DW_MACRO_undef.0) 
            .uleb(1) 
            .append_bytes(b"B\0") 
            .D8(crate::DW_MACRO_define.0) 
            .uleb(2) 
            .append_bytes(b"D 3\0") 
            .D8(crate::DW_MACRO_define.0) 
            .uleb(3) 
            .append_bytes(b"FUNCTION_LIKE_MACRO(x) 4+x\0") 
            .D8(crate::DW_MACRO_end_file.0) 
            .D8(crate::DW_MACRO_define.0) 
            .uleb(4) 
            .append_bytes(b"B 3\0") 
            .D8(crate::DW_MACRO_end_file.0) 
            .D8(crate::DW_MACRO_define.0) 
            .uleb(2) 
            .append_bytes(b"FUNCTION_LIKE_MACRO(x) 4+x\0") 
            .D8(crate::DW_MACRO_start_file.0) 
            .uleb(3) 
            .uleb(2) 
            .D8(crate::DW_MACRO_undef.0) 
            .uleb(1) 
            .append_bytes(b"B\0") 
            .D8(crate::DW_MACRO_define.0) 
            .uleb(2) 
            .append_bytes(b"D 3\0") 
            .D8(crate::DW_MACRO_define.0) 
            .uleb(3) 
            .append_bytes(b"FUNCTION_LIKE_MACRO(x) 4+x\0") 
            .D8(crate::DW_MACRO_end_file.0) 
            .D8(crate::DW_MACRO_end_file.0) 
            .D8(0); 

        
        let section = section.get_contents().unwrap();
        let debug_macro = DebugMacro::from(EndianSlice::new(&section, LittleEndian));

        let offset = position.value().unwrap() as usize;

        let mut iter = debug_macro.get_macros(DebugMacroOffset(offset)).unwrap();
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::StartFile { line: 0, file: 0 }));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::StartFile { line: 1, file: 1 }));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 1, text: MacroString::Direct(text)
            } if text.slice() == b"LONGER_MACRO 1"
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 2, text: MacroString::Direct(text)
            } if text.slice() == b"B 2"
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::StartFile { line: 3, file: 2 }));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Undef {
                line: 1, name: MacroString::Direct(name)
            } if name.slice() == b"B"
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 2, text: MacroString::Direct(text)
            } if text.slice() == b"D 3"
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 3, text: MacroString::Direct(text)
            } if text.slice() == b"FUNCTION_LIKE_MACRO(x) 4+x"
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::EndFile));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 4, text: MacroString::Direct(text)
            } if text.slice() == b"B 3"
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::EndFile));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 2, text: MacroString::Direct(text)
            } if text.slice() == b"FUNCTION_LIKE_MACRO(x) 4+x"
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::StartFile { line: 3, file: 2 }));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Undef {
                line: 1, name: MacroString::Direct(name)
            } if name.slice() == b"B"
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 2, text: MacroString::Direct(text)
            } if text.slice() == b"D 3"
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 3, text: MacroString::Direct(text)
            } if text.slice() == b"FUNCTION_LIKE_MACRO(x) 4+x"
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::EndFile));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::EndFile));
        assert_eq!(iter.next(), Ok(None));
    }

    #[test]
    fn get_macros_2() {
        let str_0 = Label::new();
        let str_1 = Label::new();
        let macro_unit_0 = Label::new();
        let macro_unit_1 = Label::new();
        let macro_unit_2 = Label::new();

        
        
        let str_section = Section::with_endian(Endian::Little)
            .set_start_const(0)
            .mark(&str_0)
            .append_bytes(b"FUNCTION_LIKE_MACRO(x) 4+x\0") 
            .mark(&str_1)
            .append_bytes(b"LONGER_MACRO 1\0"); 

        let macro_section = Section::with_endian(Endian::Little)
            .set_start_const(0)
            
            .mark(&macro_unit_0) 
            .D16(5) 
            .D8(0b0000_0010) 
            .D32(0) 
            .D8(crate::DW_MACRO_start_file.0) 
            .uleb(0) 
            .uleb(0) 
            .D8(crate::DW_MACRO_start_file.0) 
            .uleb(1) 
            .uleb(1) 
            .D8(crate::DW_MACRO_import.0) 
            .L32(macro_unit_1.clone()) 
            .D8(crate::DW_MACRO_start_file.0) 
            .uleb(3) 
            .uleb(2) 
            .D8(crate::DW_MACRO_import.0) 
            .L32(macro_unit_2.clone()) 
            .D8(crate::DW_MACRO_end_file.0) 
            .D8(crate::DW_MACRO_define.0) 
            .uleb(4) 
            .append_bytes(b"B 3\0") 
            .D8(crate::DW_MACRO_end_file.0) 
            .D8(crate::DW_MACRO_define_strp.0) 
            .uleb(2) 
            .D32(0) 
            .D8(crate::DW_MACRO_start_file.0) 
            .uleb(3) 
            .uleb(2) 
            .D8(crate::DW_MACRO_import.0) 
            .L32(&macro_unit_2) 
            .D8(crate::DW_MACRO_end_file.0) 
            .D8(crate::DW_MACRO_end_file.0) 
            .D8(0)
            
            .mark(&macro_unit_1) 
            .D16(5) 
            .D8(0b0000_0000) 
            .D8(crate::DW_MACRO_define_strp.0) 
            .uleb(1) 
            .L32(str_0.clone()) 
            .D8(crate::DW_MACRO_define.0) 
            .uleb(2) 
            .append_bytes(b"B 2\0") 
            .D8(0) 
            
            .mark(&macro_unit_2) 
            .D16(5) 
            .D8(0b0000_0000) 
            .D8(crate::DW_MACRO_undef.0) 
            .uleb(1) 
            .append_bytes(b"B\0") 
            .D8(crate::DW_MACRO_define.0) 
            .uleb(2) 
            .append_bytes(b"D 3\0") 
            .D8(crate::DW_MACRO_define_strp.0) 
            .uleb(2) 
            .L32(str_1.clone()) 
            .D8(0); 

        
        let str_section = str_section.get_contents().unwrap();
        let debug_str = DebugStr::from(EndianSlice::new(&str_section, LittleEndian));

        
        let macro_section = macro_section.get_contents().unwrap();
        let debug_macro = DebugMacro::from(EndianSlice::new(&macro_section, LittleEndian));

        
        let offset = macro_unit_0.value().unwrap() as usize;
        let mut iter = debug_macro.get_macros(DebugMacroOffset(offset)).unwrap();
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::StartFile { line: 0, file: 0 }));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::StartFile { line: 1, file: 1 }));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Import { offset } if offset.0 == macro_unit_1.value().unwrap() as usize
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::StartFile { line: 3, file: 2 }));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Import { offset } if offset.0 == macro_unit_2.value().unwrap() as usize
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::EndFile));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 4, text: MacroString::Direct(text)
            } if text.slice() == b"B 3"
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::EndFile));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 2, text: MacroString::StringPointer(text_offset)
            } if text_offset.0 == str_0.value().unwrap() as usize
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::StartFile { line: 3, file: 2 }));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Import { offset } if offset.0 == macro_unit_2.value().unwrap() as usize
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::EndFile));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(entry, MacroEntry::EndFile));
        assert_eq!(iter.next(), Ok(None));

        
        let offset = macro_unit_1.value().unwrap() as usize;
        let mut iter = debug_macro.get_macros(DebugMacroOffset(offset)).unwrap();
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 1, text: MacroString::StringPointer(text_offset)
            } if text_offset.0 == str_0.value().unwrap() as usize
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 2, text: MacroString::Direct(text)
            } if text.slice() == b"B 2"
        ));
        assert_eq!(iter.next(), Ok(None));

        
        let offset = macro_unit_2.value().unwrap() as usize;
        let mut iter = debug_macro.get_macros(DebugMacroOffset(offset)).unwrap();
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Undef {
                line: 1, name: MacroString::Direct(name)
            } if name.slice() == b"B"
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 2, text: MacroString::Direct(text)
            } if text.slice() == b"D 3"
        ));
        let entry = iter.next().unwrap().unwrap();
        assert!(matches!(
            entry,
            MacroEntry::Define {
                line: 2, text: MacroString::StringPointer(text_offset)
            } if text_offset.0 == str_1.value().unwrap() as usize
        ));
        assert_eq!(iter.next(), Ok(None));

        
        let text_offset = DebugStrOffset(str_0.value().unwrap() as usize);
        assert_eq!(
            debug_str.get_str(text_offset).unwrap().slice(),
            b"FUNCTION_LIKE_MACRO(x) 4+x"
        );
        let text_offset = DebugStrOffset(str_1.value().unwrap() as usize);
        assert_eq!(
            debug_str.get_str(text_offset).unwrap().slice(),
            b"LONGER_MACRO 1"
        );
    }
}
