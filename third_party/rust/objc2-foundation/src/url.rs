#![cfg(feature = "std")]
#![cfg(unix)] 
#![cfg(not(feature = "gnustep-1-7"))] 
use core::ptr::NonNull;
use std::ffi::{CStr, CString, OsStr};
use std::os::unix::ffi::OsStrExt;
use std::path::{Path, PathBuf};

use objc2::rc::Retained;
use objc2::AnyThread;

use crate::NSURL;

const PATH_MAX: usize = 1024;


impl NSURL {
    
    pub fn from_path(
        path: &Path,
        is_directory: bool,
        
        base_url: Option<&NSURL>,
    ) -> Option<Retained<Self>> {
        
        let bytes = path.as_os_str().as_bytes();

        if bytes.is_empty() {
            
            
            
            return None;
        }

        
        let cstr = CString::new(bytes).ok()?;
        let ptr = NonNull::new(cstr.as_ptr().cast_mut()).unwrap();

        
        
        Some(unsafe {
            Self::initFileURLWithFileSystemRepresentation_isDirectory_relativeToURL(
                Self::alloc(),
                ptr,
                is_directory,
                base_url,
            )
        })
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "fileURLWithFileSystemRepresentation:isDirectory:relativeToURL:")]
    #[doc(alias = "initFileURLWithFileSystemRepresentation:isDirectory:relativeToURL:")]
    pub fn from_file_path<P: AsRef<Path>>(path: P) -> Option<Retained<Self>> {
        Self::from_path(path.as_ref(), false, None)
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "fileURLWithFileSystemRepresentation:isDirectory:relativeToURL:")]
    #[doc(alias = "initFileURLWithFileSystemRepresentation:isDirectory:relativeToURL:")]
    pub fn from_directory_path<P: AsRef<Path>>(path: P) -> Option<Retained<Self>> {
        Self::from_path(path.as_ref(), true, None)
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[doc(alias = "getFileSystemRepresentation:maxLength:")]
    #[doc(alias = "fileSystemRepresentation")]
    pub fn to_file_path(&self) -> Option<PathBuf> {
        let mut buf = [0u8; PATH_MAX];
        let ptr = NonNull::new(buf.as_mut_ptr()).unwrap().cast();
        
        
        
        
        
        let result = unsafe { self.getFileSystemRepresentation_maxLength(ptr, buf.len()) };
        if !result {
            return None;
        }

        
        
        let cstr = unsafe { CStr::from_bytes_until_nul(&buf).unwrap_unchecked() };

        let path = OsStr::from_bytes(cstr.to_bytes());
        Some(PathBuf::from(path))
    }
}


#[cfg(test)]
#[cfg(unix)]
mod tests {
    use std::os::unix::ffi::OsStrExt;

    use super::*;

    #[test]
    fn invalid_path() {
        assert_eq!(NSURL::from_file_path(""), None);
        assert_eq!(NSURL::from_file_path("/\0/a"), None);
    }

    #[test]
    fn roundtrip() {
        let path = Path::new(OsStr::from_bytes(b"/abc/def"));
        let url = NSURL::from_file_path(path).unwrap();
        assert_eq!(url.to_file_path().unwrap(), path);

        let path = Path::new(OsStr::from_bytes(b"/\x08"));
        let url = NSURL::from_file_path(path).unwrap();
        assert_eq!(url.to_file_path().unwrap(), path);

        
        let path = Path::new(OsStr::from_bytes(b"/\x08"));
        let url = NSURL::from_file_path(path).unwrap();
        assert_eq!(url.to_file_path().unwrap(), path);
    }

    #[test]
    #[cfg(all(feature = "NSData", feature = "NSFileManager", feature = "NSError"))]
    #[ignore = "needs HFS+ file system"]
    fn special_paths() {
        use crate::{NSData, NSFileManager};

        let manager = NSFileManager::defaultManager();

        let path = Path::new(OsStr::from_bytes(b"\xf8"));
        
        let url = NSURL::from_file_path("%F8").unwrap();

        
        std::fs::write(path, "").unwrap();
        assert_eq!(NSData::dataWithContentsOfURL(&url), Some(NSData::new()));
        manager.removeItemAtURL_error(&url).unwrap();
    }

    
    
}
