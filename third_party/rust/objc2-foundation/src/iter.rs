#![allow(dead_code)]
use core::ffi::c_ulong;
use core::ptr::{self, NonNull};

use objc2::rc::Retained;
use objc2::runtime::AnyObject;
use objc2::runtime::ProtocolObject;
use objc2::ClassType;
use objc2::Message;

use crate::{NSFastEnumeration, NSFastEnumerationState};







const BUF_SIZE: usize = 16;







type MutationState = Option<c_ulong>;






#[derive(Debug, PartialEq)]
struct FastEnumeratorHelper {
    state: NSFastEnumerationState,
    buf: [*mut AnyObject; BUF_SIZE],
    
    
    
    
    
    
    
    
    
    
    
    
    current_item: usize,
    items_count: usize,
}





unsafe impl Send for FastEnumeratorHelper {}



unsafe impl Sync for FastEnumeratorHelper {}

#[cfg(feature = "unstable-mutation-return-null")]
extern "C" {
    static kCFNull: NonNull<AnyObject>;
}


#[cfg(not(feature = "unstable-mutation-return-null"))]
#[cfg_attr(debug_assertions, track_caller)]
fn items_ptr_null() -> ! {
    panic!("`itemsPtr` was NULL, likely due to mutation during iteration");
}

#[cfg(not(feature = "unstable-mutation-return-null"))]
#[cfg_attr(debug_assertions, track_caller)]
fn mutation_detected() -> ! {
    panic!("mutation detected during enumeration");
}

impl FastEnumeratorHelper {
    #[inline]
    fn new() -> Self {
        Self {
            state: NSFastEnumerationState {
                state: 0,
                itemsPtr: ptr::null_mut(),
                mutationsPtr: ptr::null_mut(),
                extra: [0; 5],
            },
            buf: [ptr::null_mut(); BUF_SIZE],
            current_item: 0,
            items_count: 0,
        }
    }

    #[inline]
    const fn remaining_items_at_least(&self) -> usize {
        self.items_count - self.current_item
    }

    
    
    
    
    
    
    #[inline]
    unsafe fn load_next_items(&mut self, collection: &ProtocolObject<dyn NSFastEnumeration>) {
        
        
        
        
        let buf_ptr = unsafe { NonNull::new_unchecked(self.buf.as_mut_ptr()) };
        
        
        
        
        
        self.items_count = unsafe {
            collection.countByEnumeratingWithState_objects_count(
                NonNull::from(&mut self.state),
                buf_ptr,
                self.buf.len(),
            )
        };

        
        
        
        self.current_item = 0;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[track_caller]
    unsafe fn next_from(
        &mut self,
        collection: &ProtocolObject<dyn NSFastEnumeration>,
        mutations_state: Option<&mut MutationState>,
    ) -> Option<NonNull<AnyObject>> {
        
        if self.current_item >= self.items_count {
            
            
            
            unsafe { self.load_next_items(collection) };

            
            if self.items_count == 0 {
                
                return None;
            }

            if mutations_state.is_some() && self.state.itemsPtr.is_null() {
                #[cfg(feature = "unstable-mutation-return-null")]
                return Some(unsafe { kCFNull });
                #[cfg(not(feature = "unstable-mutation-return-null"))]
                items_ptr_null();
            }
        }

        if let Some(mutations_state) = mutations_state {
            
            if let Some(ptr) = NonNull::new(self.state.mutationsPtr) {
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                let new_state = unsafe { ptr.as_ptr().read_unaligned() };
                match *mutations_state {
                    
                    None => {
                        *mutations_state = Some(new_state);
                    }
                    
                    
                    Some(current_state) => {
                        if current_state != new_state {
                            #[cfg(feature = "unstable-mutation-return-null")]
                            return Some(unsafe { kCFNull });
                            #[cfg(not(feature = "unstable-mutation-return-null"))]
                            mutation_detected();
                        }
                    }
                }
            }
        }

        
        
        
        
        let ptr = unsafe { self.state.itemsPtr.add(self.current_item) };
        
        self.current_item += 1;
        
        
        
        
        
        
        
        
        
        let obj = unsafe { ptr.read_unaligned() };
        
        Some(unsafe { NonNull::new_unchecked(obj) })
    }
}















pub(crate) unsafe trait FastEnumerationHelper: Message + NSFastEnumeration {
    type Item: Message;

    fn maybe_len(&self) -> Option<usize>;
}





























#[derive(Debug, PartialEq)]
pub(crate) struct IterUnchecked<'a, C: ?Sized + 'a> {
    helper: FastEnumeratorHelper,
    
    collection: &'a C,
    #[cfg(debug_assertions)]
    mutations_state: MutationState,
}

impl<'a, C: ?Sized + FastEnumerationHelper> IterUnchecked<'a, C> {
    pub(crate) fn new(collection: &'a C) -> Self {
        Self {
            helper: FastEnumeratorHelper::new(),
            collection,
            #[cfg(debug_assertions)]
            mutations_state: None,
        }
    }
}

impl<'a, C: FastEnumerationHelper> Iterator for IterUnchecked<'a, C> {
    type Item = &'a C::Item;

    #[inline]
    #[track_caller]
    fn next(&mut self) -> Option<&'a C::Item> {
        #[cfg(debug_assertions)]
        let mutations_state = Some(&mut self.mutations_state);
        #[cfg(not(debug_assertions))]
        let mutations_state = None;
        
        
        
        
        let obj = unsafe {
            self.helper
                .next_from(ProtocolObject::from_ref(self.collection), mutations_state)?
        };
        
        
        
        
        
        
        
        Some(unsafe { obj.cast::<C::Item>().as_ref() })
    }

    #[inline]
    fn size_hint(&self) -> (usize, Option<usize>) {
        (
            self.helper.remaining_items_at_least(),
            self.collection.maybe_len(),
        )
    }
}

#[derive(Debug, PartialEq)]
pub(crate) struct Iter<'a, C: ?Sized + 'a> {
    helper: FastEnumeratorHelper,
    
    collection: &'a C,
    mutations_state: MutationState,
}

impl<'a, C: ?Sized + FastEnumerationHelper> Iter<'a, C> {
    pub(crate) fn new(collection: &'a C) -> Self {
        Self {
            helper: FastEnumeratorHelper::new(),
            collection,
            mutations_state: None,
        }
    }
}

impl<C: FastEnumerationHelper> Iterator for Iter<'_, C> {
    type Item = Retained<C::Item>;

    #[inline]
    #[track_caller]
    fn next(&mut self) -> Option<Retained<C::Item>> {
        let obj = unsafe {
            self.helper.next_from(
                ProtocolObject::from_ref(self.collection),
                Some(&mut self.mutations_state),
            )?
        };
        Some(unsafe { obj.cast::<C::Item>().as_ref() }.retain())
    }

    #[inline]
    fn size_hint(&self) -> (usize, Option<usize>) {
        (
            self.helper.remaining_items_at_least(),
            self.collection.maybe_len(),
        )
    }
}









#[derive(Debug, PartialEq)]
pub(crate) struct IntoIter<C: ?Sized> {
    helper: FastEnumeratorHelper,
    
    collection: Retained<C>,
    mutations_state: MutationState,
}

impl<C: ?Sized + FastEnumerationHelper> IntoIter<C> {
    pub(crate) fn new(collection: Retained<C>) -> Self {
        Self {
            helper: FastEnumeratorHelper::new(),
            collection,
            mutations_state: None,
        }
    }

    pub(crate) fn new_mutable<T>(collection: Retained<T>) -> Self
    where
        T: ClassType<Super = C>,
        C: Sized,
    {
        Self {
            helper: FastEnumeratorHelper::new(),
            
            
            
            collection: unsafe { Retained::cast_unchecked(collection) },
            mutations_state: None,
        }
    }
}

impl<C: FastEnumerationHelper> Iterator for IntoIter<C> {
    type Item = Retained<C::Item>;

    #[inline]
    #[track_caller]
    fn next(&mut self) -> Option<Retained<C::Item>> {
        let collection = ProtocolObject::from_ref(&*self.collection);
        
        let obj = unsafe {
            self.helper
                .next_from(collection, Some(&mut self.mutations_state))?
        };
        
        let obj = unsafe { Retained::retain(obj.cast::<C::Item>().as_ptr()) };
        
        
        Some(unsafe { obj.unwrap_unchecked() })
    }

    #[inline]
    fn size_hint(&self) -> (usize, Option<usize>) {
        (
            self.helper.remaining_items_at_least(),
            self.collection.maybe_len(),
        )
    }
}

#[derive(Debug, PartialEq)]
pub(crate) struct IterUncheckedWithBackingEnum<'a, C: ?Sized + 'a, E: ?Sized + 'a> {
    helper: FastEnumeratorHelper,
    
    collection: &'a C,
    
    enumerator: Retained<E>,
    #[cfg(debug_assertions)]
    mutations_state: MutationState,
}

impl<'a, C, E> IterUncheckedWithBackingEnum<'a, C, E>
where
    C: ?Sized + FastEnumerationHelper,
    E: ?Sized + FastEnumerationHelper,
{
    pub(crate) unsafe fn new(collection: &'a C, enumerator: Retained<E>) -> Self {
        Self {
            helper: FastEnumeratorHelper::new(),
            collection,
            enumerator,
            #[cfg(debug_assertions)]
            mutations_state: None,
        }
    }
}

impl<'a, C, E> Iterator for IterUncheckedWithBackingEnum<'a, C, E>
where
    C: ?Sized + FastEnumerationHelper,
    E: FastEnumerationHelper,
{
    type Item = &'a E::Item;

    #[inline]
    #[track_caller]
    fn next(&mut self) -> Option<&'a E::Item> {
        #[cfg(debug_assertions)]
        let mutations_state = Some(&mut self.mutations_state);
        #[cfg(not(debug_assertions))]
        let mutations_state = None;
        
        let obj = unsafe {
            self.helper
                .next_from(ProtocolObject::from_ref(&*self.enumerator), mutations_state)?
        };
        
        Some(unsafe { obj.cast::<E::Item>().as_ref() })
    }

    #[inline]
    fn size_hint(&self) -> (usize, Option<usize>) {
        (
            self.helper.remaining_items_at_least(),
            
            
            self.collection.maybe_len(),
        )
    }
}

#[derive(Debug, PartialEq)]
pub(crate) struct IterWithBackingEnum<'a, C: ?Sized + 'a, E: ?Sized + 'a> {
    helper: FastEnumeratorHelper,
    
    collection: &'a C,
    
    enumerator: Retained<E>,
    mutations_state: MutationState,
}

impl<'a, C, E> IterWithBackingEnum<'a, C, E>
where
    C: ?Sized + FastEnumerationHelper,
    E: ?Sized + FastEnumerationHelper,
{
    pub(crate) unsafe fn new(collection: &'a C, enumerator: Retained<E>) -> Self {
        Self {
            helper: FastEnumeratorHelper::new(),
            collection,
            enumerator,
            mutations_state: None,
        }
    }
}

impl<C, E> Iterator for IterWithBackingEnum<'_, C, E>
where
    C: ?Sized + FastEnumerationHelper,
    E: FastEnumerationHelper,
{
    type Item = Retained<E::Item>;

    #[inline]
    #[track_caller]
    fn next(&mut self) -> Option<Retained<E::Item>> {
        
        let obj = unsafe {
            self.helper.next_from(
                ProtocolObject::from_ref(&*self.enumerator),
                Some(&mut self.mutations_state),
            )?
        };
        
        Some(unsafe { obj.cast::<E::Item>().as_ref() }.retain())
    }

    #[inline]
    fn size_hint(&self) -> (usize, Option<usize>) {
        (
            self.helper.remaining_items_at_least(),
            
            
            self.collection.maybe_len(),
        )
    }
}

#[doc(hidden)]
macro_rules! __impl_iter {
    (
        impl<$($lifetime:lifetime, )? $t1:ident: $bound1:ident $(+ $bound1_b:ident)? $(, $t2:ident: $bound2:ident $(+ $bound2_b:ident)?)?> Iterator<Item = $item:ty> for $for:ty { ... }
    ) => {
        impl<$($lifetime, )? $t1: $bound1 $(+ $bound1_b)? $(, $t2: $bound2 $(+ $bound2_b)?)?> Iterator for $for {
            type Item = $item;

            #[inline]
            #[track_caller]
            fn next(&mut self) -> Option<Self::Item> {
                self.0.next()
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.0.size_hint()
            }
        }
    }
}

#[doc(hidden)]
macro_rules! __impl_into_iter {
    () => {};
    (
        $(#[$m:meta])*
        impl<$param:ident: Message> IntoIterator for &$ty:ident<$param2:ident> {
            type IntoIter = $iter:ident<'_, $param3:ident>;
        }

        $($rest:tt)*
    ) => {
        $(#[$m])*
        impl<'a, $param: Message> IntoIterator for &'a $ty<$param2> {
            type Item = Retained<$param3>;
            type IntoIter = $iter<'a, $param3>;

            #[inline]
            fn into_iter(self) -> Self::IntoIter {
                $iter($crate::iter::Iter::new(&self))
            }
        }

        __impl_into_iter! {
            $($rest)*
        }
    };
    (
        $(#[$m:meta])*
        impl<$param:ident: Message> IntoIterator for Retained<$ty:ident<$param2:ident>> {
            #[uses($new_fn:ident)]
            type IntoIter = $into_iter:ident<$param3:ident>;
        }

        $($rest:tt)*
    ) => {
        $(#[$m])*
        impl<$param: Message> objc2::rc::RetainedIntoIterator for $ty<$param2> {
            type Item = Retained<$param3>;
            type IntoIter = $into_iter<$param3>;

            #[inline]
            fn retained_into_iter(this: Retained<Self>) -> Self::IntoIter {
                $into_iter($crate::iter::IntoIter::$new_fn(this))
            }
        }

        __impl_into_iter! {
            $($rest)*
        }
    };
}

#[cfg(test)]
#[cfg(feature = "NSArray")]
#[cfg(feature = "NSValue")]
mod tests {
    use alloc::vec::Vec;
    use core::mem::size_of;

    use super::*;
    use crate::{NSArray, NSNumber};

    #[test]
    #[cfg_attr(
        any(not(target_pointer_width = "64"), debug_assertions),
        ignore = "assertions assume pointer-width of 64, and the size only really matter in release mode"
    )]
    fn test_enumerator_helper() {
        
        assert_eq!(size_of::<NSFastEnumerationState>(), 64);
        assert_eq!(size_of::<FastEnumeratorHelper>(), 208);
        assert_eq!(size_of::<IterUnchecked<'_, NSArray<NSNumber>>>(), 216);
        assert_eq!(size_of::<Iter<'_, NSArray<NSNumber>>>(), 232);
        assert_eq!(size_of::<IntoIter<NSArray<NSNumber>>>(), 232);
    }

    #[test]
    fn test_enumerator() {
        let vec: Vec<_> = (0..4).map(NSNumber::new_usize).collect();
        let array = NSArray::from_retained_slice(&vec);

        let enumerator = array.iter();
        assert_eq!(enumerator.count(), 4);

        let enumerator = array.iter();
        assert!(enumerator.enumerate().all(|(i, obj)| obj.as_usize() == i));
    }

    #[test]
    fn test_into_enumerator() {
        let vec: Vec<_> = (0..4).map(NSNumber::new_usize).collect();
        let array = NSArray::from_retained_slice(&vec);

        let enumerator = array.into_iter();
        assert!(enumerator.enumerate().all(|(i, obj)| obj.as_usize() == i));
    }
}
