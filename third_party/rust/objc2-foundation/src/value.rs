use alloc::ffi::CString;
use alloc::string::ToString;
use core::ffi::CStr;
use core::fmt;
use core::hash;
use core::mem::MaybeUninit;
use core::ptr::NonNull;
use core::str;

use objc2::encode::Encode;
use objc2::rc::Retained;
use objc2::AnyThread;

use crate::NSValue;





impl NSValue {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub fn new<T: 'static + Copy + Encode>(value: T) -> Retained<Self> {
        let bytes: NonNull<T> = NonNull::from(&value);
        let encoding = CString::new(T::ENCODING.to_string()).unwrap();
        unsafe {
            Self::initWithBytes_objCType(
                Self::alloc(),
                bytes.cast(),
                NonNull::new(encoding.as_ptr() as *mut _).unwrap(),
            )
        }
    }
}


impl NSValue {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pub unsafe fn get<T: 'static + Copy + Encode>(&self) -> T {
        debug_assert!(
        self.contains_encoding::<T>(),
        "wrong encoding. NSValue tried to return something with encoding {}, but the encoding of the given type was {}",
        self.encoding().unwrap_or("(NULL)"),
        T::ENCODING,
    );
        let mut value = MaybeUninit::<T>::uninit();
        let ptr: NonNull<T> = NonNull::new(value.as_mut_ptr()).unwrap();
        #[allow(deprecated)]
        unsafe {
            self.getValue(ptr.cast())
        };
        
        
        unsafe { value.assume_init() }
    }

    #[cfg(feature = "NSRange")]
    pub fn get_range(&self) -> Option<crate::NSRange> {
        if self.contains_encoding::<crate::NSRange>() {
            
            Some(unsafe { self.rangeValue() })
        } else {
            None
        }
    }

    #[cfg(all(feature = "NSGeometry", feature = "objc2-core-foundation"))]
    pub fn get_point(&self) -> Option<crate::NSPoint> {
        if self.contains_encoding::<crate::NSPoint>() {
            
            
            
            
            
            Some(unsafe { self.pointValue() })
        } else {
            None
        }
    }

    #[cfg(all(feature = "NSGeometry", feature = "objc2-core-foundation"))]
    pub fn get_size(&self) -> Option<crate::NSSize> {
        if self.contains_encoding::<crate::NSSize>() {
            
            Some(unsafe { self.sizeValue() })
        } else {
            None
        }
    }

    #[cfg(all(feature = "NSGeometry", feature = "objc2-core-foundation"))]
    pub fn get_rect(&self) -> Option<crate::NSRect> {
        if self.contains_encoding::<crate::NSRect>() {
            
            Some(unsafe { self.rectValue() })
        } else {
            None
        }
    }

    pub fn encoding(&self) -> Option<&str> {
        let ptr = self.objCType().as_ptr();
        Some(unsafe { CStr::from_ptr(ptr) }.to_str().unwrap())
    }

    pub fn contains_encoding<T: 'static + Copy + Encode>(&self) -> bool {
        T::ENCODING.equivalent_to_str(self.encoding().unwrap())
    }
}

impl hash::Hash for NSValue {
    #[inline]
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        (**self).hash(state);
    }
}

impl PartialEq for NSValue {
    #[doc(alias = "isEqualToValue:")]
    fn eq(&self, other: &Self) -> bool {
        
        self.isEqualToValue(other)
    }
}

impl Eq for NSValue {}

impl fmt::Debug for NSValue {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let enc = self.encoding().unwrap_or("(NULL)");
        let bytes = &**self; 
        f.debug_struct("NSValue")
            .field("encoding", &enc)
            .field("bytes", bytes)
            .finish()
    }
}
