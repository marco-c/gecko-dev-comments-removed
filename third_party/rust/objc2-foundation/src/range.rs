use core::ops::Range;

use objc2::encode::{Encode, Encoding, RefEncode};

use crate::NSUInteger;




#[repr(C)]

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSRange {
    
    pub location: NSUInteger,
    
    pub length: NSUInteger,
}

impl NSRange {
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "NSMakeRange")]
    pub const fn new(location: usize, length: usize) -> Self {
        
        Self { location, length }
    }

    
    
    
    
    
    
    
    
    
    
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.length == 0
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[inline]
    #[doc(alias = "NSLocationInRange")]
    pub fn contains(&self, index: usize) -> bool {
        
        if let Some(len) = index.checked_sub(self.location) {
            len < self.length
        } else {
            
            false
        }
    }

    
    #[inline]
    #[doc(alias = "NSMaxRange")]
    pub fn end(&self) -> usize {
        self.location
            .checked_add(self.length)
            .expect("NSRange too large")
    }

    
    
    
}











impl From<Range<usize>> for NSRange {
    fn from(range: Range<usize>) -> Self {
        let length = range
            .end
            .checked_sub(range.start)
            .expect("Range end < start");
        Self {
            location: range.start,
            length,
        }
    }
}

impl From<NSRange> for Range<usize> {
    #[inline]
    fn from(nsrange: NSRange) -> Self {
        Self {
            start: nsrange.location,
            end: nsrange.end(),
        }
    }
}

unsafe impl Encode for NSRange {
    const ENCODING: Encoding = Encoding::Struct("_NSRange", &[usize::ENCODING, usize::ENCODING]);
}

unsafe impl RefEncode for NSRange {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_from_range() {
        let cases: &[(Range<usize>, NSRange)] = &[
            (0..0, NSRange::new(0, 0)),
            (0..10, NSRange::new(0, 10)),
            (10..10, NSRange::new(10, 0)),
            (10..20, NSRange::new(10, 10)),
        ];

        for (range, expected) in cases {
            assert_eq!(NSRange::from(range.clone()), *expected);
        }
    }

    #[test]
    #[should_panic = "Range end < start"]
    #[allow(clippy::reversed_empty_ranges)]
    fn test_from_range_inverted() {
        let _ = NSRange::from(10..0);
    }

    #[test]
    fn test_contains() {
        let range = NSRange::from(10..20);
        assert!(!range.contains(0));
        assert!(!range.contains(9));
        assert!(range.contains(10));
        assert!(range.contains(11));
        assert!(!range.contains(20));
        assert!(!range.contains(21));
    }

    #[test]
    fn test_end() {
        let range = NSRange::from(10..20);
        assert!(!range.contains(0));
        assert!(!range.contains(9));
        assert!(range.contains(10));
        assert!(range.contains(11));
        assert!(!range.contains(20));
        assert!(!range.contains(21));
    }

    #[test]
    #[should_panic = "NSRange too large"]
    fn test_end_large() {
        let _ = NSRange::new(usize::MAX, usize::MAX).end();
    }
}
