





#[test]
fn zero_repetition_capture_group() {
    use regex_automata::{
        dfa::onepass::DFA, util::primitives::NonMaxUsize, Anchored, Input,
    };

    let expr = DFA::new(r"(abc)(ABC){0}").unwrap();
    let s = "abcABC";
    let input = Input::new(s).span(0..s.len()).anchored(Anchored::Yes);

    
    let mut cache = expr.create_cache();
    let mut slots: Vec<Option<NonMaxUsize>> = vec![None; 4];
    let pid = expr.try_search_slots(&mut cache, &input, &mut slots).unwrap();
    assert_eq!(pid, Some(regex_automata::PatternID::must(0)));
    assert_eq!(slots[0], Some(NonMaxUsize::new(0).unwrap()));
    assert_eq!(slots[1], Some(NonMaxUsize::new(3).unwrap()));
    assert_eq!(slots[2], Some(NonMaxUsize::new(0).unwrap()));
    assert_eq!(slots[3], Some(NonMaxUsize::new(3).unwrap()));

    
    
    slots.resize(6, None);
    let pid = expr.try_search_slots(&mut cache, &input, &mut slots).unwrap();
    assert_eq!(pid, Some(regex_automata::PatternID::must(0)));
    
    assert_eq!(slots[2], Some(NonMaxUsize::new(0).unwrap()));
    assert_eq!(slots[3], Some(NonMaxUsize::new(3).unwrap()));
    
    assert_eq!(slots[4], None);
    assert_eq!(slots[5], None);
}






#[test]
fn too_many_slots_normal_pattern() {
    use regex_automata::{
        dfa::onepass::DFA, util::primitives::NonMaxUsize, Anchored, Input,
    };

    let expr = DFA::new(r"abc").unwrap();
    let s = "abc";
    let input = Input::new(s).span(0..s.len()).anchored(Anchored::Yes);

    let mut cache = expr.create_cache();
    let mut slots: Vec<Option<NonMaxUsize>> = vec![None; 4];
    let pid = expr.try_search_slots(&mut cache, &input, &mut slots).unwrap();
    assert_eq!(pid, Some(regex_automata::PatternID::must(0)));
    assert_eq!(slots[0], Some(NonMaxUsize::new(0).unwrap()));
    assert_eq!(slots[1], Some(NonMaxUsize::new(3).unwrap()));
}
