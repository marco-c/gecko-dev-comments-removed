



use crate::decoder::JxlApiDecoder;
use std::slice;

#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum JxlDecoderStatus {
    Ok = 0,
    NeedMoreData = 1,
    Error = 2,
}

#[repr(C)]
#[derive(Debug, Clone, Copy, Default)]
pub struct JxlBasicInfo {
    pub width: u32,
    pub height: u32,
    pub has_alpha: bool,
    pub alpha_premultiplied: bool,
    pub is_animated: bool,
    pub num_loops: u32,
    pub valid: bool,
}

#[repr(C)]
#[derive(Debug, Clone, Copy, Default)]
pub struct JxlFrameInfo {
    pub duration_ms: i32,
    pub frame_duration_valid: bool,
}

#[no_mangle]
pub extern "C" fn jxl_decoder_new(metadata_only: bool, premultiply: bool) -> *mut JxlApiDecoder {
    Box::into_raw(Box::new(JxlApiDecoder::new(metadata_only, premultiply)))
}




#[no_mangle]
pub unsafe extern "C" fn jxl_decoder_destroy(decoder: *mut JxlApiDecoder) {
    if !decoder.is_null() {
        
        
        let _ = unsafe { Box::from_raw(decoder) };
    }
}









#[no_mangle]
pub unsafe extern "C" fn jxl_decoder_process_data(
    decoder: *mut JxlApiDecoder,
    data: *mut *const u8,
    data_len: *mut usize,
    output_buffer: *mut u8,
    output_buffer_len: usize,
) -> JxlDecoderStatus {
    debug_assert!(!decoder.is_null() && !data.is_null() && !data_len.is_null());

    
    let decoder = unsafe { &mut *decoder };

    
    
    
    let mut data_slice = if unsafe { (*data).is_null() } {
        &[]
    } else {
        unsafe { slice::from_raw_parts(*data, *data_len) }
    };

    let output_slice = if output_buffer.is_null() {
        None
    } else {
        
        
        Some(unsafe { slice::from_raw_parts_mut(output_buffer, output_buffer_len) })
    };

    let result = decoder.process_data(&mut data_slice, output_slice);

    
    
    unsafe {
        *data = data_slice.as_ptr();
        *data_len = data_slice.len();
    }

    match result {
        Ok(true) => JxlDecoderStatus::Ok,
        Ok(false) => JxlDecoderStatus::NeedMoreData,
        Err(_) => JxlDecoderStatus::Error,
    }
}



#[no_mangle]
pub unsafe extern "C" fn jxl_decoder_get_basic_info(decoder: *const JxlApiDecoder) -> JxlBasicInfo {
    debug_assert!(!decoder.is_null());

    
    let decoder = unsafe { &*decoder };

    let Some(info) = decoder.get_basic_info() else {
        return JxlBasicInfo::default();
    };

    JxlBasicInfo {
        width: info.width,
        height: info.height,
        has_alpha: info.has_alpha,
        alpha_premultiplied: info.alpha_premultiplied,
        is_animated: info.is_animated,
        num_loops: info.num_loops,
        valid: true,
    }
}



#[no_mangle]
pub unsafe extern "C" fn jxl_decoder_get_frame_info(decoder: *const JxlApiDecoder) -> JxlFrameInfo {
    debug_assert!(!decoder.is_null());

    
    let decoder = unsafe { &*decoder };

    match decoder.frame_duration {
        Some(duration) => JxlFrameInfo {
            duration_ms: duration.clamp(0.0, i32::MAX as f64) as i32,
            frame_duration_valid: true,
        },
        None => JxlFrameInfo {
            duration_ms: 0,
            frame_duration_valid: false,
        },
    }
}



#[no_mangle]
pub unsafe extern "C" fn jxl_decoder_is_frame_ready(decoder: *const JxlApiDecoder) -> bool {
    debug_assert!(!decoder.is_null());

    
    let decoder = unsafe { &*decoder };

    decoder.frame_ready
}



#[no_mangle]
pub unsafe extern "C" fn jxl_decoder_has_more_frames(decoder: *const JxlApiDecoder) -> bool {
    debug_assert!(!decoder.is_null());

    
    let decoder = unsafe { &*decoder };

    decoder.inner.has_more_frames()
}
