





#ifndef RegisteredThread_h
#define RegisteredThread_h

#include "platform.h"
#include "ThreadInfo.h"

namespace mozilla {
namespace baseprofiler {






class RacyRegisteredThread final {
 private:
  enum class SleepState {
    Awake,
    SleepingNotObserved,
    SleepingObserved,
  };

 public:
  explicit RacyRegisteredThread(BaseProfilerThreadId aThreadId)
      : mThreadId(aThreadId),
        mSleep(SleepState::Awake),
        mIsBeingProfiled(false) {}

  ~RacyRegisteredThread() {}

  void SetIsBeingProfiled(bool aIsBeingProfiled) {
    mIsBeingProfiled = aIsBeingProfiled;
  }

  bool IsBeingProfiled() const { return mIsBeingProfiled; }

  
  
  void ReinitializeOnResume() {
    
    
    
    
    (void)mSleep.compareExchange(SleepState::SleepingObserved,
                                 SleepState::SleepingNotObserved);
  }

  
  bool CanDuplicateLastSampleDueToSleep() {
    if (mSleep == SleepState::Awake) {
      return false;
    }

    if (mSleep.compareExchange(SleepState::SleepingNotObserved,
                               SleepState::SleepingObserved)) {
      return false;
    }

    return true;
  }

  
  
  void SetSleeping() {
    MOZ_ASSERT(mSleep == SleepState::Awake);
    mSleep = SleepState::SleepingNotObserved;
  }

  
  
  void SetAwake() {
    MOZ_ASSERT(mSleep != SleepState::Awake);
    mSleep = SleepState::Awake;
  }

  bool IsSleeping() { return mSleep != SleepState::Awake; }

  BaseProfilerThreadId ThreadId() const { return mThreadId; }

  class ProfilingStack& ProfilingStack() { return mProfilingStack; }
  const class ProfilingStack& ProfilingStack() const { return mProfilingStack; }

 private:
  class ProfilingStack mProfilingStack;

  
  
  const BaseProfilerThreadId mThreadId;

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Atomic<SleepState> mSleep;

  
  Atomic<bool, MemoryOrdering::Relaxed> mIsBeingProfiled;
};





class RegisteredThread final {
 public:
  RegisteredThread(ThreadInfo* aInfo, void* aStackTop);
  ~RegisteredThread();

  class RacyRegisteredThread& RacyRegisteredThread() {
    return mRacyRegisteredThread;
  }
  const class RacyRegisteredThread& RacyRegisteredThread() const {
    return mRacyRegisteredThread;
  }

  PlatformData* GetPlatformData() const { return mPlatformData.get(); }
  const void* StackTop() const { return mStackTop; }

  size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const;

  const RefPtr<ThreadInfo> Info() const { return mThreadInfo; }

 private:
  class RacyRegisteredThread mRacyRegisteredThread;

  const UniquePlatformData mPlatformData;
  const void* mStackTop;

  const RefPtr<ThreadInfo> mThreadInfo;
};

}  
}  

#endif  
