



GLOBAL(uint8_t, gPageSize2Pow, GLOBAL_LOG2(gPageSize))
GLOBAL(uint8_t, gRealPageSize2Pow, GLOBAL_LOG2(gRealPageSize))
GLOBAL(size_t, gPageSizeMask, gPageSize - 1)
GLOBAL(size_t, gRealPageSizeMask, gRealPageSize - 1)



GLOBAL(size_t, gPagesPerRealPage,
       gPageSize < gRealPageSize ? gRealPageSize / gPageSize : 1);


GLOBAL(size_t, gChunkNumPages, kChunkSize >> gPageSize2Pow)


GLOBAL(size_t, gChunkHeaderNumPages,
       gPagesPerRealPage +
           (std::max(PAGE_CEILING(sizeof(arena_chunk_t) +
                                  sizeof(arena_chunk_map_t) * gChunkNumPages),
                     REAL_PAGE_CEILING(sizeof(arena_chunk_t) +
                                       sizeof(arena_chunk_map_t) *
                                           gChunkNumPages)) >>
            gPageSize2Pow));


GLOBAL(size_t, gMaxLargeClass,
       kChunkSize - gRealPageSize - (gChunkHeaderNumPages << gPageSize2Pow))


GLOBAL_ASSERT(1ULL << gPageSize2Pow == gPageSize,
              "Page size is not a power of two");
GLOBAL_ASSERT(1ULL << gRealPageSize2Pow == gRealPageSize,
              "Real page size is not a power of two");
GLOBAL_ASSERT(kQuantum >= sizeof(void*));
GLOBAL_ASSERT(kQuantum <= kQuantumWide);
GLOBAL_ASSERT(!kNumQuantumWideClasses ||
              kQuantumWide <= (kMinLargeClass - kMaxQuantumClass));

GLOBAL_ASSERT(kQuantumWide <= kMaxQuantumClass);

GLOBAL_ASSERT(gMaxLargeClass >= kMaxQuantumWideClass);
GLOBAL_ASSERT(kChunkSize >= gPageSize);
GLOBAL_ASSERT(kChunkSize >= gRealPageSize);
GLOBAL_ASSERT(gPagesPerRealPage < gChunkHeaderNumPages);
GLOBAL_ASSERT(kQuantum * 4 <= kChunkSize);
