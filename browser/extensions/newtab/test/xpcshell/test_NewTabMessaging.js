


"use strict";

ChromeUtils.defineESModuleGetters(this, {
  actionTypes: "resource://newtab/common/Actions.mjs",
  actionUtils: "resource://newtab/common/Actions.mjs",
  sinon: "resource://testing-common/Sinon.sys.mjs",
  NewTabMessaging: "resource://newtab/lib/NewTabMessaging.sys.mjs",
});

function createMockSubject(targetBrowser, message, dispatch) {
  return {
    wrappedJSObject: { targetBrowser, message, dispatch },
  };
}












async function getTestNewTabMessaging(sandbox, taskFn) {
  let messaging = new NewTabMessaging();
  messaging.store = {
    dispatch: sandbox.spy(),
    getState() {
      return this.state;
    },
  };

  
  Assert.ok(!messaging.initialized, "Should not be initialized initially");

  
  messaging.init();
  Assert.ok(messaging.initialized, "Should be initialized");

  await taskFn(messaging);
  messaging.uninit();
}





add_task(async function test_NewTabMessaging() {
  let sandbox = sinon.createSandbox();
  let mockDispatch = sandbox.spy();

  await getTestNewTabMessaging(sandbox, async messaging => {
    
    let mockMessage = { id: "test-message" };
    let mockBrowser = {
      browsingContext: {
        currentWindowGlobal: {
          getActor: () => ({
            getTabDetails: () => ({ portID: "12345" }),
          }),
        },
      },
    };

    messaging.observe(
      createMockSubject(mockBrowser, mockMessage, mockDispatch),
      "newtab-message",
      null
    );

    
    Assert.equal(
      messaging.ASRouterDispatch,
      mockDispatch,
      "ASRouterDispatch should be assigned"
    );

    
    messaging.handleImpression(mockMessage);
    Assert.ok(
      mockDispatch.calledWithMatch({ type: "IMPRESSION", data: mockMessage }),
      "Impression action should be dispatched"
    );

    
    messaging.sendTelemetry("CLICK", mockMessage);
    Assert.ok(
      mockDispatch.calledWithMatch({
        type: "NEWTAB_MESSAGE_TELEMETRY",
        data: sandbox.match.has("event", "CLICK"),
      }),
      "Telemetry event should be dispatched"
    );
  });

  sandbox.restore();
});





add_task(async function test_dismissal() {
  let sandbox = sinon.createSandbox();
  await getTestNewTabMessaging(sandbox, async messaging => {
    messaging.onAction({
      type: actionTypes.MESSAGE_DISMISS,
      data: { message: "some-message-ID" },
    });

    Assert.ok(
      messaging.store.dispatch.calledOnce,
      "Should have dispatched a single action"
    );
    const [action] = messaging.store.dispatch.getCall(0).args;
    Assert.equal(
      action.type,
      actionTypes.MESSAGE_TOGGLE_VISIBILITY,
      "Should have sent the action to toggle visibility"
    );
    Assert.deepEqual(
      action.data,
      { isVisible: false },
      "Should have set visibility to false"
    );
    Assert.ok(
      actionUtils.isSendToPreloaded(action),
      "Should be sending the action to all newtab instances, including the preloaded one."
    );
  });

  sandbox.restore();
});
