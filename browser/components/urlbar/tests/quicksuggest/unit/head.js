





ChromeUtils.defineESModuleGetters(this, {
  Preferences: "resource://gre/modules/Preferences.sys.mjs",
  QuickSuggest: "moz-src:///browser/components/urlbar/QuickSuggest.sys.mjs",
  SearchUtils: "moz-src:///toolkit/components/search/SearchUtils.sys.mjs",
  TelemetryTestUtils: "resource://testing-common/TelemetryTestUtils.sys.mjs",
  UrlbarProviderAutofill:
    "moz-src:///browser/components/urlbar/UrlbarProviderAutofill.sys.mjs",
  UrlbarProviderQuickSuggest:
    "moz-src:///browser/components/urlbar/UrlbarProviderQuickSuggest.sys.mjs",
  UrlbarSearchUtils:
    "moz-src:///browser/components/urlbar/UrlbarSearchUtils.sys.mjs",
});

add_setup(async function setUpQuickSuggestXpcshellTest() {
  
  
  
  
  QuickSuggest._testSkipTelemetryEnvironmentInit = true;
});







async function setUpMigrateTest() {
  await UrlbarTestUtils.initNimbusFeature();
  await QuickSuggestTestUtils.setRegionAndLocale({
    region: "US",
    locale: "en-US",
  });
}





















async function doMigrateTest({
  toVersion,
  preMigrationUserPrefs = {},
  expectedPostMigrationUserPrefs = {},
}) {
  info(
    "Testing migration: " +
      JSON.stringify({
        toVersion,
        preMigrationUserPrefs,
        expectedPostMigrationUserPrefs,
      })
  );

  
  
  let userPrefsToAlwaysCheck = [
    "quicksuggest.dataCollection.enabled",
    "quicksuggest.enabled",
    "suggest.quicksuggest",
    "suggest.quicksuggest.nonsponsored",
    "suggest.quicksuggest.sponsored",
  ];

  let userBranch = new Preferences({
    branch: "browser.urlbar.",
    defaultBranch: false,
  });

  
  if (toVersion == 1) {
    userBranch.reset("quicksuggest.migrationVersion");
  } else {
    userBranch.set("quicksuggest.migrationVersion", toVersion - 1);
  }

  
  for (let [name, value] of Object.entries(preMigrationUserPrefs)) {
    userBranch.set(name, value);
  }

  
  
  for (let name of userPrefsToAlwaysCheck) {
    if (!preMigrationUserPrefs.hasOwnProperty(name)) {
      preMigrationUserPrefs[name] = userBranch.isSet(name)
        ? userBranch.get(name)
        : null;
    }
  }

  
  let userPrefsToCheckPostMigration = new Set([
    ...Object.keys(preMigrationUserPrefs),
    ...Object.keys(expectedPostMigrationUserPrefs),
  ]);

  
  
  
  for (let i = 0; i < 2; i++) {
    info(`Reinitializing Suggest, i=${i}`);

    
    await QuickSuggest._test_reset({
      migrationVersion: toVersion,
    });

    for (let name of userPrefsToCheckPostMigration) {
      
      
      let expectedValue = expectedPostMigrationUserPrefs.hasOwnProperty(name)
        ? expectedPostMigrationUserPrefs[name]
        : preMigrationUserPrefs[name];
      if (expectedValue === null) {
        Assert.ok(
          !userBranch.isSet(name),
          "Pref should not have a user value after migration: " + name
        );
      } else {
        Assert.ok(
          userBranch.isSet(name),
          "Pref should have a user value after migration: " + name
        );
        Assert.equal(
          userBranch.get(name),
          expectedValue,
          "Pref should have been set to the expected value after migration: " +
            name
        );
      }
    }

    Assert.equal(
      userBranch.get("quicksuggest.migrationVersion"),
      toVersion,
      "quicksuggest.migrationVersion should be updated after migration"
    );
  }

  
  userBranch.reset("quicksuggest.migrationVersion");
  for (let name of userPrefsToCheckPostMigration) {
    userBranch.reset(name);
  }
}


























async function doDismissOneTest({
  feature,
  result,
  command,
  queriesForDismissals,
  queriesForOthers,
  providers = [UrlbarProviderQuickSuggest.name],
}) {
  await QuickSuggest.clearDismissedSuggestions();
  await QuickSuggestTestUtils.forceSync();
  Assert.ok(
    !(await QuickSuggest.canClearDismissedSuggestions()),
    "Sanity check: canClearDismissedSuggestions should return false initially"
  );

  let changedPromise = TestUtils.topicObserved(
    "quicksuggest-dismissals-changed"
  );

  let actualResult = await getActualResult({
    providers,
    query: queriesForDismissals[0].query,
    expectedResult: result,
  });

  triggerCommand({
    command,
    feature,
    result: actualResult,
    expectedCountsByCall: {
      removeResult: 1,
    },
  });

  info("Awaiting dismissals-changed promise");
  await changedPromise;

  Assert.ok(
    await QuickSuggest.canClearDismissedSuggestions(),
    "canClearDismissedSuggestions should return true after triggering command"
  );
  Assert.ok(
    await QuickSuggest.isResultDismissed(actualResult),
    "The result should be dismissed"
  );

  for (let { query } of queriesForDismissals) {
    info("Doing search for dismissed suggestions: " + JSON.stringify(query));
    await check_results({
      context: createContext(query, {
        providers,
        isPrivate: false,
      }),
      matches: [],
    });
  }

  for (let { query, expectedResults } of queriesForOthers) {
    info(
      "Doing search for non-dismissed suggestions: " + JSON.stringify(query)
    );
    await check_results({
      context: createContext(query, {
        providers,
        isPrivate: false,
      }),
      matches: expectedResults,
    });
  }

  let clearedPromise = TestUtils.topicObserved(
    "quicksuggest-dismissals-cleared"
  );

  info("Clearing dismissals");
  await QuickSuggest.clearDismissedSuggestions();

  
  
  info("Awaiting dismissals-cleared promise");
  await clearedPromise;

  Assert.ok(
    !(await QuickSuggest.canClearDismissedSuggestions()),
    "canClearDismissedSuggestions should return false after clearing dismissals"
  );

  for (let { query, expectedResults = [result] } of queriesForDismissals) {
    info("Doing search after clearing dismissals: " + JSON.stringify(query));
    await check_results({
      context: createContext(query, {
        providers,
        isPrivate: false,
      }),
      matches: expectedResults,
    });
  }
}




























async function doDismissAllTest({
  feature,
  result,
  command,
  pref,
  queries,
  providers = [UrlbarProviderQuickSuggest.name],
}) {
  await QuickSuggest.clearDismissedSuggestions();
  await QuickSuggestTestUtils.forceSync();
  Assert.ok(
    !(await QuickSuggest.canClearDismissedSuggestions()),
    "Sanity check: canClearDismissedSuggestions should return false initially"
  );

  let changedPromise = TestUtils.topicObserved(
    "quicksuggest-dismissals-changed"
  );

  let actualResult = await getActualResult({
    providers,
    query: queries[0].query,
    expectedResult: result,
  });

  triggerCommand({
    command,
    feature,
    result: actualResult,
    expectedCountsByCall: {
      removeResult: 1,
    },
  });

  info("Awaiting dismissals-changed promise");
  await changedPromise;

  Assert.ok(
    await QuickSuggest.canClearDismissedSuggestions(),
    "canClearDismissedSuggestions should return true after triggering command"
  );
  Assert.ok(
    !UrlbarPrefs.get(pref),
    "Pref should be false after triggering command: " + pref
  );

  for (let { query } of queries) {
    info("Doing search after triggering command: " + JSON.stringify(query));
    await check_results({
      context: createContext(query, {
        providers,
        isPrivate: false,
      }),
      matches: [],
    });
  }

  let clearedPromise = TestUtils.topicObserved(
    "quicksuggest-dismissals-cleared"
  );

  info("Clearing dismissals");
  await QuickSuggest.clearDismissedSuggestions();

  
  
  info("Awaiting dismissals-cleared promise");
  await clearedPromise;

  Assert.ok(
    !(await QuickSuggest.canClearDismissedSuggestions()),
    "canClearDismissedSuggestions should return false after clearing dismissals"
  );
  Assert.ok(
    UrlbarPrefs.get(pref),
    "Pref should be true after clearing it: " + pref
  );

  
  await QuickSuggestTestUtils.forceSync();

  for (let { query, expectedResults = [result] } of queries) {
    info("Doing search after clearing dismissals: " + JSON.stringify(query));
    await check_results({
      context: createContext(query, {
        providers,
        isPrivate: false,
      }),
      matches: expectedResults,
    });
  }
}














async function getActualResult({
  query,
  expectedResult,
  providers = [UrlbarProviderQuickSuggest.name],
}) {
  info("Doing search to get an actual result: " + JSON.stringify(query));
  let context = createContext(query, {
    providers,
    isPrivate: false,
  });
  await check_results({
    context,
    matches: [expectedResult],
  });

  let actualResult = context.results.find(
    r =>
      r.providerName == UrlbarProviderQuickSuggest.name &&
      r.payload.provider == expectedResult.payload.provider
  );
  Assert.ok(actualResult, "Search should have returned a matching result");

  return actualResult;
}


















async function doShowLessFrequentlyTest({
  feature,
  keyword,
  expectedResult,
  minKeywordLengthPref,
  showLessFrequentlyCountPref,
}) {
  let showLessFrequentlyCap = 3;

  if (keyword.length < showLessFrequentlyCap) {
    throw new Error(
      "keyword must be long enough to 'Show less frequently' enough times"
    );
  }

  await QuickSuggestTestUtils.withConfig({
    config: { show_less_frequently_cap: showLessFrequentlyCap },
    callback: async () => {
      
      
      
      for (let count = 0; count < showLessFrequentlyCap; count++) {
        let searchString = keyword.substring(
          0,
          keyword.length - showLessFrequentlyCap + count + 1
        );

        info(
          "Doing search: " +
            JSON.stringify({
              count,
              searchString,
            })
        );

        
        Assert.equal(
          UrlbarPrefs.get(minKeywordLengthPref),
          count == 0 ? 0 : searchString.length,
          "minKeywordLength pref should be correct before search " + count
        );
        Assert.equal(
          feature.showLessFrequentlyCount,
          count,
          "showLessFrequentlyCount should be correct before search " + count
        );
        Assert.equal(
          UrlbarPrefs.get(showLessFrequentlyCountPref),
          count,
          "showLessFrequentlyCount pref should be correct before search " +
            count
        );
        Assert.ok(
          feature.canShowLessFrequently,
          "canShowLessFrequently should be correct before search " + count
        );

        
        await check_results({
          context: createContext(searchString, {
            providers: [UrlbarProviderQuickSuggest.name],
            isPrivate: false,
          }),
          matches: [expectedResult],
        });

        
        triggerCommand({
          feature,
          searchString,
          command: "show_less_frequently",
          result: expectedResult,
          expectedCountsByCall: {
            acknowledgeFeedback: 1,
            invalidateResultMenuCommands:
              count == showLessFrequentlyCap - 1 ? 1 : 0,
          },
        });

        
        await check_results({
          context: createContext(searchString, {
            providers: [UrlbarProviderQuickSuggest.name],
            isPrivate: false,
          }),
          matches: [],
        });
      }

      
      Assert.equal(
        UrlbarPrefs.get(minKeywordLengthPref),
        keyword.length + 1,
        "minKeywordLength pref should be correct after all searches"
      );
      Assert.equal(
        feature.showLessFrequentlyCount,
        showLessFrequentlyCap,
        "showLessFrequentlyCount should be correct after all searches"
      );
      Assert.equal(
        UrlbarPrefs.get(showLessFrequentlyCountPref),
        showLessFrequentlyCap,
        "showLessFrequentlyCap pref should be correct after all searches"
      );
      Assert.ok(
        !feature.canShowLessFrequently,
        "canShowLessFrequently should be correct after all searches"
      );
    },
  });

  UrlbarPrefs.clear(minKeywordLengthPref);
  UrlbarPrefs.clear(showLessFrequentlyCountPref);
}



























async function doRustProvidersTests({ searchString, tests }) {
  for (let { prefs, expectedUrls } of tests) {
    info(
      "Starting Rust providers test: " + JSON.stringify({ prefs, expectedUrls })
    );

    info("Setting prefs and forcing sync");
    for (let [name, value] of Object.entries(prefs)) {
      UrlbarPrefs.set(name, value);
    }
    await QuickSuggestTestUtils.forceSync();

    info("Querying with search string: " + JSON.stringify(searchString));
    let suggestions = await QuickSuggest.rustBackend.query(searchString);
    info("Got suggestions: " + JSON.stringify(suggestions));

    Assert.deepEqual(
      suggestions.map(s => s.url).sort(),
      expectedUrls.sort(),
      "query() should return the expected suggestions (by URL)"
    );

    info("Clearing prefs and forcing sync");
    for (let name of Object.keys(prefs)) {
      UrlbarPrefs.clear(name);
    }
    await QuickSuggestTestUtils.forceSync();
  }
}





















function triggerCommand({
  feature,
  command,
  result,
  searchString = "",
  expectedCountsByCall = null,
}) {
  info(`Calling ${feature.name}.onEngagement() to trigger command: ${command}`);

  let countsByCall = new Map();
  let addCall = name => {
    if (!countsByCall.has(name)) {
      countsByCall.set(name, 0);
    }
    countsByCall.set(name, countsByCall.get(name) + 1);
  };

  feature.onEngagement(
    
    {},
    
    {
      removeResult() {
        addCall("removeResult");
      },
      input: {
        startQuery() {
          addCall("startQuery");
        },
      },
      view: {
        acknowledgeFeedback() {
          addCall("acknowledgeFeedback");
        },
        invalidateResultMenuCommands() {
          addCall("invalidateResultMenuCommands");
        },
      },
    },
    
    { result, selType: command },
    searchString
  );

  if (expectedCountsByCall) {
    for (let [name, expectedCount] of Object.entries(expectedCountsByCall)) {
      Assert.equal(
        countsByCall.get(name) ?? 0,
        expectedCount,
        "Function should have been called the expected number of times: " + name
      );
    }
  }

  return countsByCall;
}
