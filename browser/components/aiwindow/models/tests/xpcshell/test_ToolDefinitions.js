
















const { toolsConfig, TOOLS } = ChromeUtils.importESModule(
  "moz-src:///browser/components/aiwindow/models/Tools.sys.mjs"
);




add_task(function test_toolDefinitions_structure() {
  Assert.ok(Array.isArray(toolsConfig), "toolsConfig should be an array");
  Assert.equal(
    toolsConfig.length,
    TOOLS.length,
    "toolsConfig length should match TOOLS length"
  );

  for (const [index, toolDef] of toolsConfig.entries()) {
    Assert.equal(
      toolDef.type,
      "function",
      `Tool ${index} should have type "function"`
    );
    Assert.ok(
      toolDef.function,
      `Tool ${index} should have a function property`
    );
    Assert.equal(
      typeof toolDef.function.name,
      "string",
      `Tool ${index} function.name should be a string`
    );
    Assert.greater(
      toolDef.function.name.length,
      0,
      `Tool ${index} function.name should not be empty`
    );
    Assert.equal(
      typeof toolDef.function.description,
      "string",
      `Tool ${index} function.description should be a string`
    );
    Assert.greater(
      toolDef.function.description.length,
      0,
      `Tool ${index} function.description should not be empty`
    );
    Assert.ok(
      toolDef.function.parameters,
      `Tool ${index} should have parameters`
    );
    Assert.equal(
      toolDef.function.parameters.type,
      "object",
      `Tool ${index} parameters.type should be "object"`
    );
  }
});




add_task(function test_toolDefinitions_names_match_constants() {
  const definedNames = toolsConfig.map(t => t.function.name);
  const expectedNames = TOOLS;

  Assert.deepEqual(
    definedNames.sort(),
    expectedNames.sort(),
    "Tool names in toolsConfig should match TOOLS constant"
  );
});




add_task(function test_parameter_types_are_valid() {
  const validTypes = [
    "string",
    "number",
    "integer",
    "boolean",
    "array",
    "object",
    "null",
  ];

  for (const toolDef of toolsConfig) {
    const props = toolDef.function.parameters.properties;

    for (const [paramName, paramDef] of Object.entries(props)) {
      Assert.ok(
        validTypes.includes(paramDef.type),
        `Parameter ${paramName} in ${toolDef.function.name} should have valid JSON Schema type`
      );

      
      if (paramDef.type === "array" && paramDef.items) {
        Assert.ok(
          validTypes.includes(paramDef.items.type),
          `Array items type for ${paramName} in ${toolDef.function.name} should be valid`
        );
      }
    }
  }
});




add_task(function test_parameter_descriptions_are_meaningful() {
  for (const toolDef of toolsConfig) {
    const props = toolDef.function.parameters.properties;

    for (const [paramName, paramDef] of Object.entries(props)) {
      Assert.greater(
        paramDef.description.length,
        10,
        `Parameter ${paramName} in ${toolDef.function.name} should have meaningful description (>10 chars)`
      );

      
      if (paramDef.type === "array" && paramDef.items?.description) {
        Assert.greater(
          paramDef.items.description.length,
          10,
          `Array items description for ${paramName} in ${toolDef.function.name} should be meaningful`
        );
      }
    }
  }
});




add_task(function test_required_parameters_exist_in_properties() {
  for (const toolDef of toolsConfig) {
    const params = toolDef.function.parameters;
    if (params.required) {
      Assert.ok(
        Array.isArray(params.required),
        `Tool ${toolDef.function.name} required field should be an array if present`
      );
      for (const requiredParam of params.required) {
        Assert.ok(
          params.properties[requiredParam],
          `Required parameter ${requiredParam} in ${toolDef.function.name} should exist in properties`
        );
      }
    }
  }
});
