

"use strict";

const { AIWindowUI } = ChromeUtils.importESModule(
  "moz-src:///browser/components/aiwindow/ui/modules/AIWindowUI.sys.mjs"
);

const { Chat } = ChromeUtils.importESModule(
  "moz-src:///browser/components/aiwindow/models/Chat.sys.mjs"
);

const { openAIEngine } = ChromeUtils.importESModule(
  "moz-src:///browser/components/aiwindow/models/Utils.sys.mjs"
);

const { ChatConversation } = ChromeUtils.importESModule(
  "moz-src:///browser/components/aiwindow/ui/modules/ChatConversation.sys.mjs"
);

const { ChatMessage } = ChromeUtils.importESModule(
  "moz-src:///browser/components/aiwindow/ui/modules/ChatMessage.sys.mjs"
);

const { ChatStore, MESSAGE_ROLE } = ChromeUtils.importESModule(
  "moz-src:///browser/components/aiwindow/ui/modules/ChatStore.sys.mjs"
);

const lazy = {};
ChromeUtils.defineESModuleGetters(lazy, {
  sinon: "resource://testing-common/Sinon.sys.mjs",
});

function hasAiWindowAttribute() {
  return window.document.documentElement.hasAttribute("ai-window");
}

function createMockConversation(id = "test-conv-id") {
  const conversation = new ChatConversation({
    id,
    title: "Test Conversation",
    pageUrl: new URL("https://example.com/"),
  });

  conversation.messages = [
    new ChatMessage({
      ordinal: 0,
      role: MESSAGE_ROLE.USER,
      content: { text: "Hello" },
    }),
    new ChatMessage({
      ordinal: 1,
      role: MESSAGE_ROLE.ASSISTANT,
      content: { text: "Hi there" },
    }),
  ];

  return conversation;
}

async function open_ai_window() {
  await SpecialPowers.pushPrefEnv({
    set: [["browser.smartwindow.enabled", true]],
  });

  const newAIWindow = await BrowserTestUtils.openNewBrowserWindow({
    openerWindow: null,
    aiWindow: true,
  });

  const isAIWindow =
    newAIWindow.document.documentElement.hasAttribute("ai-window");

  if (!isAIWindow) {
    throw new Error("Did not open a new AIWindow");
  }

  return newAIWindow;
}

add_setup(async function setup() {
  await SpecialPowers.pushPrefEnv({
    set: [
      ["browser.search.suggest.enabled", false],
      ["browser.urlbar.suggest.searches", false],
    ],
  });
});


add_task(async function test_new_tab_closes_opened_sidebar_convo() {
  AIWindow.toggleAIWindow(window, true);
  let newTab;
  try {
    AIWindowUI.openSidebar(window);
    Assert.ok(
      AIWindowUI.isSidebarOpen(window),
      "Sidebar should be opened by AIWindowUI.openSidebar()"
    );

    newTab = await BrowserTestUtils.addTab(gBrowser, "about:blank");
    await BrowserTestUtils.switchTab(gBrowser, newTab);

    Assert.ok(
      !AIWindowUI.isSidebarOpen(window),
      "Sidebar should not be opened after switching to a fresh AIWindow tab"
    );
  } finally {
    AIWindow.toggleAIWindow(window, false);
    await BrowserTestUtils.removeTab(newTab);
  }
});


add_task(
  async function test_navigate_to_url_with_active_chat_move_convo_to_sidebar() {
    const sb = lazy.sinon.createSandbox();

    try {
      const mockConversation = createMockConversation();
      sb.stub(ChatStore, "findConversationById").resolves(mockConversation);

      const win = await openAIWindow();
      const browser = win.gBrowser.selectedBrowser;
      const tab = win.gBrowser.selectedTab;

      await BrowserTestUtils.browserLoaded(browser, false, AIWINDOW_URL);

      
      win.dispatchEvent(
        new win.CustomEvent("ai-window:opened-conversation", {
          detail: {
            mode: "fullpage",
            conversationId: mockConversation.id,
            tab,
          },
        })
      );

      
      const loaded = BrowserTestUtils.browserLoaded(browser);
      BrowserTestUtils.startLoadingURIString(browser, "https://example.com/");
      await loaded;

      await TestUtils.waitForCondition(
        () => AIWindowUI.isSidebarOpen(win),
        "Sidebar should be open after navigating away with active conversation"
      );

      await BrowserTestUtils.closeWindow(win);
    } finally {
      sb.restore();
    }
  }
);


add_task(
  async function test_switch_back_to_tab_with_conversation_reopens_sidebar() {
    const sb = lazy.sinon.createSandbox();

    try {
      const mockConversation = createMockConversation();
      sb.stub(ChatStore, "findConversationById").resolves(mockConversation);

      const win = await openAIWindow();
      const browser = win.gBrowser.selectedBrowser;
      const originalTab = win.gBrowser.selectedTab;

      await BrowserTestUtils.browserLoaded(browser, false, AIWINDOW_URL);

      
      win.dispatchEvent(
        new win.CustomEvent("ai-window:opened-conversation", {
          detail: {
            mode: "fullpage",
            conversationId: mockConversation.id,
            tab: originalTab,
          },
        })
      );

      
      const loaded = BrowserTestUtils.browserLoaded(browser);
      BrowserTestUtils.startLoadingURIString(browser, "https://example.com/");
      await loaded;

      Assert.ok(
        AIWindowUI.isSidebarOpen(win),
        "Sidebar should be open after navigating away"
      );

      
      const newTab = await BrowserTestUtils.openNewForegroundTab(
        win.gBrowser,
        "about:blank"
      );
      await TestUtils.waitForCondition(
        () => !AIWindowUI.isSidebarOpen(win),
        "Sidebar should close when switching to new tab"
      );

      
      await BrowserTestUtils.switchTab(win.gBrowser, originalTab);
      await TestUtils.waitForCondition(
        () => AIWindowUI.isSidebarOpen(win),
        "Sidebar should reopen when switching back to tab with conversation"
      );

      await BrowserTestUtils.removeTab(newTab);
      await BrowserTestUtils.closeWindow(win);
    } finally {
      sb.restore();
    }
  }
);


add_task(
  async function test_switch_between_tabs_with_different_conversations() {
    const sb = lazy.sinon.createSandbox();

    try {
      const conversationA = createMockConversation("conv-a");
      const conversationB = createMockConversation("conv-b");

      const findStub = sb.stub(ChatStore, "findConversationById");
      findStub.withArgs("conv-a").resolves(conversationA);
      findStub.withArgs("conv-b").resolves(conversationB);

      const win = await openAIWindow();
      const browserA = win.gBrowser.selectedBrowser;
      const tabA = win.gBrowser.selectedTab;

      await BrowserTestUtils.browserLoaded(browserA, false, AIWINDOW_URL);

      
      win.dispatchEvent(
        new win.CustomEvent("ai-window:opened-conversation", {
          detail: {
            mode: "fullpage",
            conversationId: "conv-a",
            tab: tabA,
          },
        })
      );

      
      let loaded = BrowserTestUtils.browserLoaded(browserA);
      BrowserTestUtils.startLoadingURIString(browserA, "https://example.com/");
      await loaded;

      
      const tabB = await BrowserTestUtils.openNewForegroundTab(
        win.gBrowser,
        "https://example.org/"
      );

      win.dispatchEvent(
        new win.CustomEvent("ai-window:opened-conversation", {
          detail: {
            mode: "fullpage",
            conversationId: "conv-b",
            tab: tabB,
          },
        })
      );

      
      AIWindowUI.openSidebar(win, conversationB);
      Assert.ok(
        AIWindowUI.isSidebarOpen(win),
        "Sidebar should be open for tab B"
      );

      
      await BrowserTestUtils.switchTab(win.gBrowser, tabA);

      Assert.ok(
        AIWindowUI.isSidebarOpen(win),
        "Sidebar should remain open when switching to tab A with conversation"
      );

      
      await BrowserTestUtils.switchTab(win.gBrowser, tabB);

      Assert.ok(
        AIWindowUI.isSidebarOpen(win),
        "Sidebar should remain open when switching back to tab B"
      );

      await BrowserTestUtils.removeTab(tabB);
      await BrowserTestUtils.closeWindow(win);
    } finally {
      sb.restore();
    }
  }
);



add_task(async function test_navigate_back_to_aiwindow_closes_sidebar() {
  const sb = lazy.sinon.createSandbox();

  try {
    const mockConversation = createMockConversation();
    sb.stub(ChatStore, "findConversationById").resolves(mockConversation);

    const win = await openAIWindow();
    const browser = win.gBrowser.selectedBrowser;
    const tab = win.gBrowser.selectedTab;

    await BrowserTestUtils.browserLoaded(browser, false, AIWINDOW_URL);

    
    win.dispatchEvent(
      new win.CustomEvent("ai-window:opened-conversation", {
        detail: {
          mode: "fullpage",
          conversationId: mockConversation.id,
          tab,
        },
      })
    );

    
    let loaded = BrowserTestUtils.browserLoaded(browser);
    BrowserTestUtils.startLoadingURIString(browser, "https://example.com/");
    await loaded;

    
    await new Promise(resolve => win.setTimeout(resolve, 100));
    Assert.ok(
      AIWindowUI.isSidebarOpen(win),
      "Sidebar should be open after navigating away"
    );

    
    loaded = BrowserTestUtils.browserLoaded(browser);
    BrowserTestUtils.startLoadingURIString(browser, AIWINDOW_URL);
    await loaded;

    
    await new Promise(resolve => win.setTimeout(resolve, 100));
    Assert.ok(
      !AIWindowUI.isSidebarOpen(win),
      "Sidebar should close when navigating back to AI Window URL"
    );

    await BrowserTestUtils.closeWindow(win);
  } finally {
    sb.restore();
  }
}).skip();


add_task(
  async function test_navigate_without_active_chat_keeps_sidebar_closed() {
    const win = await openAIWindow();
    const browser = win.gBrowser.selectedBrowser;

    await BrowserTestUtils.browserLoaded(browser, false, AIWINDOW_URL);

    

    Assert.ok(
      !AIWindowUI.isSidebarOpen(win),
      "Sidebar should be closed initially"
    );

    
    const loaded = BrowserTestUtils.browserLoaded(browser);
    BrowserTestUtils.startLoadingURIString(browser, "https://example.com/");
    await loaded;

    
    await new Promise(resolve => win.setTimeout(resolve, 100));

    Assert.ok(
      !AIWindowUI.isSidebarOpen(win),
      "Sidebar should remain closed when navigating without active chat"
    );

    await BrowserTestUtils.closeWindow(win);
  }
);


add_task(async function test_close_tab_with_active_sidebar() {
  const sb = lazy.sinon.createSandbox();

  try {
    const mockConversation = createMockConversation();
    sb.stub(ChatStore, "findConversationById").resolves(mockConversation);

    const win = await openAIWindow();
    const browser = win.gBrowser.selectedBrowser;
    const originalTab = win.gBrowser.selectedTab;

    await BrowserTestUtils.browserLoaded(browser, false, AIWINDOW_URL);

    
    win.dispatchEvent(
      new win.CustomEvent("ai-window:opened-conversation", {
        detail: {
          mode: "fullpage",
          conversationId: mockConversation.id,
          tab: originalTab,
        },
      })
    );

    
    AIWindowUI.openSidebar(win, mockConversation);
    Assert.ok(AIWindowUI.isSidebarOpen(win), "Sidebar should be open");

    
    const newTab = await BrowserTestUtils.openNewForegroundTab(
      win.gBrowser,
      "about:blank"
    );
    await TestUtils.waitForCondition(
      () => !AIWindowUI.isSidebarOpen(win),
      "Sidebar should close when switching to new tab"
    );

    
    await BrowserTestUtils.removeTab(originalTab);
    await TestUtils.waitForCondition(
      () => !AIWindowUI.isSidebarOpen(win),
      "Sidebar should be closed after tab with conversation is removed"
    );

    await BrowserTestUtils.removeTab(newTab);
    await BrowserTestUtils.closeWindow(win);
  } finally {
    sb.restore();
  }
});


add_task(async function test_sidebar_state_after_multiple_navigations() {
  const sb = lazy.sinon.createSandbox();

  try {
    
    const mockConversation = createMockConversation();
    sb.stub(ChatStore, "findConversationById").resolves(mockConversation);

    const win = await openAIWindow();
    const browser = win.gBrowser.selectedBrowser;
    const tab = win.gBrowser.selectedTab;

    await BrowserTestUtils.browserLoaded(browser, false, AIWINDOW_URL);

    
    win.dispatchEvent(
      new win.CustomEvent("ai-window:opened-conversation", {
        detail: {
          mode: "fullpage",
          conversationId: mockConversation.id,
          tab,
        },
      })
    );

    Assert.ok(
      !AIWindowUI.isSidebarOpen(win),
      "Sidebar should be closed on AI Window URL"
    );

    
    let loaded = BrowserTestUtils.browserLoaded(browser);
    BrowserTestUtils.startLoadingURIString(browser, "https://example.com/");
    await loaded;
    await new Promise(resolve => win.setTimeout(resolve, 100));
    Assert.ok(
      AIWindowUI.isSidebarOpen(win),
      "Sidebar should open when navigating away with active conversation"
    );

    
    loaded = BrowserTestUtils.browserLoaded(browser);
    BrowserTestUtils.startLoadingURIString(browser, AIWINDOW_URL);
    await loaded;
    await new Promise(resolve => win.setTimeout(resolve, 100));
    Assert.ok(
      !AIWindowUI.isSidebarOpen(win),
      "Sidebar should close when returning to AI Window URL"
    );

    
    loaded = BrowserTestUtils.browserLoaded(browser);
    BrowserTestUtils.startLoadingURIString(browser, "https://example.org/");
    await loaded;
    await new Promise(resolve => win.setTimeout(resolve, 100));
    Assert.ok(
      AIWindowUI.isSidebarOpen(win),
      "Sidebar should open again when navigating away"
    );

    await BrowserTestUtils.closeWindow(win);
  } finally {
    sb.restore();
  }
}).skip();
