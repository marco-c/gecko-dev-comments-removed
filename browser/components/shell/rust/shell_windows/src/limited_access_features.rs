
















































































use base64::{Engine as _, engine::general_purpose::STANDARD};
use log;
use nserror::{NS_ERROR_UNEXPECTED, NS_OK, nsresult};
use nsstring::{nsACString, nsCString, nsString};
use sha2::{Digest, Sha256};
use std::borrow::Cow;
use windows::{
    ApplicationModel::{LimitedAccessFeatureStatus as LafStatus, LimitedAccessFeatures, Package},
    Win32::Foundation::APPMODEL_ERROR_NO_PACKAGE,
    core::{HRESULT, HSTRING},
};
use xpcom::{
    RefPtr,
    interfaces::{nsILimitedAccessFeature, nsIWindowsRegKey},
    xpcom, xpcom_method,
};

#[xpcom(implement(nsILimitedAccessFeature), nonatomic)]
struct LimitedAccessFeature {
    feature_id: String,
    token: String,
    attestation: String,
}

impl LimitedAccessFeature {
    xpcom_method!(unlock => Unlock() -> bool);
    pub fn unlock(&self) -> Result<bool, nsresult> {
        let status = LimitedAccessFeatures::TryUnlockFeature(
            &HSTRING::from(&self.feature_id),
            &HSTRING::from(&self.token),
            &HSTRING::from(&self.attestation),
        )
        .and_then(|result| result.Status())
        .map_err(|e| {
            log::error!("{e:?}");
            NS_ERROR_UNEXPECTED
        })?;

        log::debug!("Unlock status: {status:?}");

        match status {
            LafStatus::Available | LafStatus::AvailableWithoutToken => Ok(true),
            LafStatus::Unavailable | LafStatus::Unknown => Ok(false),
            _ => Err(NS_ERROR_UNEXPECTED),
        }
    }

    xpcom_method!(get_feature_id => GetFeatureId() -> nsACString);
    fn get_feature_id(&self) -> Result<nsCString, nsresult> {
        Ok(self.feature_id.as_str().into())
    }

    xpcom_method!(get_token => GetToken() -> nsACString);
    fn get_token(&self) -> Result<nsCString, nsresult> {
        Ok(self.token.as_str().into())
    }

    xpcom_method!(get_attestation => GetAttestation() -> nsACString);
    fn get_attestation(&self) -> Result<nsCString, nsresult> {
        Ok(self.attestation.as_str().into())
    }
}

#[xpcom(implement(nsILimitedAccessFeatureService), nonatomic)]
pub struct LimitedAccessFeatureService {}

impl LimitedAccessFeatureService {
    xpcom_method!(get_taskbar_pin_feature_id => GetTaskbarPinFeatureId() -> nsACString);
    pub fn get_taskbar_pin_feature_id(&self) -> Result<nsCString, nsresult> {
        Ok(nsCString::from("com.microsoft.windows.taskbar.pin"))
    }

    xpcom_method!(generate_limited_access_feature => GenerateLimitedAccessFeature(featureId: *const nsACString) -> *const nsILimitedAccessFeature);
    pub fn generate_limited_access_feature(
        &self,
        feature_id: &nsACString,
    ) -> Result<RefPtr<nsILimitedAccessFeature>, nsresult> {
        let (family_name, publisher_id) = get_package_identity()?;
        let token = generate_token(&feature_id.to_utf8(), &family_name)
            .inspect_err(|e| log::error!("Error generating feature token: {e:?}"))?;
        let attestation = generate_attestation(&feature_id.to_utf8(), &publisher_id);

        let feature = LimitedAccessFeature::allocate(InitLimitedAccessFeature {
            feature_id: feature_id.to_utf8().into(),
            token,
            attestation: attestation,
        });

        feature
            .query_interface::<nsILimitedAccessFeature>()
            .ok_or(NS_ERROR_UNEXPECTED)
    }
}









fn generate_token(feature_id: &str, family_name: &FamilyName) -> Result<String, nsresult> {
    let family_name = &family_name.0;
    let feature_key = get_feature_key(feature_id)?;

    let to_hash = format!("{feature_id}!{feature_key}!{family_name}");

    let mut hasher = Sha256::new();
    hasher.update(to_hash);
    let digest = hasher.finalize();
    Ok(STANDARD.encode(&digest[..16]))
}


fn get_feature_key(feature_id: &str) -> Result<String, nsresult> {
    let reg: RefPtr<nsIWindowsRegKey> =
        xpcom::create_instance(c"@mozilla.org/windows-registry-key;1")
            .ok_or(NS_ERROR_UNEXPECTED)?;

    let path = nsString::from(&format!(
        r"SOFTWARE\Microsoft\Windows\CurrentVersion\AppModel\LimitedAccessFeatures\{feature_id}"
    ));
    
    unsafe {
        reg.Open(
            nsIWindowsRegKey::ROOT_KEY_LOCAL_MACHINE,
            &*path,
            nsIWindowsRegKey::ACCESS_QUERY_VALUE,
        )
    }
    .to_result()?;

    let mut value = nsString::new();
    
    unsafe { reg.ReadStringValue(&*nsString::new(), &mut *value) }.to_result()?;

    Ok(value.to_string())
}

fn generate_attestation(feature_id: &str, publisher_id: &PublisherId) -> String {
    let publisher_id = &publisher_id.0;
    format!(
        "{publisher_id} has registered their use of {feature_id} with Microsoft and agrees to the terms of use."
    )
}









struct FamilyName<'a>(Cow<'a, str>);









struct PublisherId<'a>(Cow<'a, str>);



fn get_package_identity<'a>() -> Result<(FamilyName<'a>, PublisherId<'a>), nsresult> {
    match Package::Current() {
        Ok(package) => (|| {
            let id = package.Id()?;
            let family_name = FamilyName(id.FamilyName()?.to_string().into());
            let publisher_id = PublisherId(id.PublisherId()?.to_string().into());
            Ok((family_name, publisher_id))
        })()
        .map_err(|e: HRESULT| {
            log::error!("{e:?}");
            NS_ERROR_UNEXPECTED
        }),
        Err(e) if e.code() == APPMODEL_ERROR_NO_PACKAGE.to_hresult() => {
            
            
            
            const UNPACKAGED_FAMILY_NAME: &str = "MozillaFirefox_pcsmm0jrprpb2";
            const UNPACKAGED_PUBLISHER_ID: &str = "pcsmm0jrprpb2";

            log::debug!(
                "Not an MSIX install, using Family Name: `{UNPACKAGED_FAMILY_NAME}` and Publisher ID: `{UNPACKAGED_PUBLISHER_ID}`"
            );
            Ok((
                FamilyName(UNPACKAGED_FAMILY_NAME.into()),
                PublisherId(UNPACKAGED_PUBLISHER_ID.into()),
            ))
        }
        Err(e) => {
            log::error!("{e:?}");
            Err(NS_ERROR_UNEXPECTED)
        }
    }
}






#[unsafe(no_mangle)]
pub extern "C" fn new_limited_access_feature_service(
    iid: *const xpcom::nsIID,
    result: *mut *mut xpcom::reexports::libc::c_void,
) -> nsresult {
    let service = LimitedAccessFeatureService::allocate(InitLimitedAccessFeatureService {});
    
    unsafe { service.QueryInterface(iid, result) }
}
