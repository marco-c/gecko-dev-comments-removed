


"use strict";


async function createStubBackupFile(dirPath, filename) {
  const filePath = PathUtils.join(dirPath, filename);
  await IOUtils.writeUTF8(filePath, "<!-- stub backup -->", {
    tmpPath: filePath + ".tmp",
  });
  return filePath;
}

add_task(
  async function test_findBackupsInWellKnownLocations_and_multipleFiles() {
    
    const TEST_ROOT = await IOUtils.createUniqueDirectory(
      PathUtils.tempDir,
      "test-findBackupsInWellKnownLocations"
    );
    const BACKUP_DIR = PathUtils.join(TEST_ROOT, "Backups");
    await IOUtils.makeDirectory(BACKUP_DIR, { createAncestors: true });

    Services.prefs.setStringPref("browser.backup.location", BACKUP_DIR);

    
    let bs = new BackupService();
    let sandbox = sinon.createSandbox();

    
    
    sandbox.stub(bs, "getBackupFileInfo").callsFake(async _filePath => {});

    
    Assert.ok(await IOUtils.exists(BACKUP_DIR), "Backup directory exists");
    Assert.equal(
      (await IOUtils.getChildren(BACKUP_DIR)).length,
      0,
      "Folder is empty"
    );

    
    const ONE = "FirefoxBackup_one_20241201-1200.html";
    await createStubBackupFile(BACKUP_DIR, ONE);

    let result = await bs.findBackupsInWellKnownLocations();
    Assert.ok(result.found, "Found should be true with one candidate");
    Assert.equal(
      result.multipleBackupsFound,
      false,
      "multipleBackupsFound should be false"
    );
    
    Assert.ok(
      result.backupFileToRestore && result.backupFileToRestore.endsWith(ONE),
      "backupFileToRestore should point at the single html file"
    );

    
    const TWO = "FirefoxBackup_two_20241202-1300.html";
    await createStubBackupFile(BACKUP_DIR, TWO);

    let result2 = await bs.findBackupsInWellKnownLocations();
    Assert.ok(
      !result2.found,
      "Found should be false when multiple candidates exist and validateFile=false"
    );
    Assert.equal(
      result2.multipleBackupsFound,
      true,
      "Should signal multipleBackupsFound"
    );
    Assert.equal(
      result2.backupFileToRestore,
      null,
      "No file chosen if multiple & not allowed"
    );

    
    let { multipleBackupsFound } = await bs.findIfABackupFileExists({
      validateFile: false,
      multipleFiles: true, 
    });
    Assert.ok(!multipleBackupsFound, "Should not report multiple when allowed");

    
    
    let result3 = await bs.findBackupsInWellKnownLocations({
      validateFile: true,
      multipleFiles: true,
    });
    Assert.ok(
      result3.found,
      "Found should be true when validateFile=true and multiple files exist"
    );
    Assert.equal(
      result3.multipleBackupsFound,
      true,
      "Should signal multipleBackupsFound when validateFile=true and multipleFiles=true and multiple files exist"
    );
    Assert.ok(
      result3.backupFileToRestore && result3.backupFileToRestore.endsWith(TWO),
      "Should select the newest file when validateFile=true"
    );

    
    sandbox.restore();
    await IOUtils.remove(TEST_ROOT, { recursive: true });
  }
);

const docsDirName = "Documents";
const oneDriveDirName = "OneDrive";
const backupDirName = "Restore Firefox";
const backupFilename = "FirefoxBackup_.html";

add_task(async function test_findBackupInDocsAfterSignInToOneDrive() {
  const testRoot = await IOUtils.createUniqueDirectory(
    PathUtils.tempDir,
    test_findBackupInDocsAfterSignInToOneDrive.name
  );

  const docsDir = PathUtils.join(testRoot, docsDirName);
  const backupDir = PathUtils.join(docsDir, backupDirName);
  await IOUtils.makeDirectory(backupDir, { createAncestors: true });
  await createStubBackupFile(backupDir, backupFilename);

  const oneDriveDir = PathUtils.join(testRoot, oneDriveDirName);
  await IOUtils.makeDirectory(oneDriveDir, { createAncestors: true });

  let backupService = new BackupService();
  let sandbox = sinon.createSandbox();
  sandbox.stub(BackupService, "docsDirFolderPath").get(() => ({
    path: docsDir,
  }));
  sandbox.stub(BackupService, "oneDriveFolderPath").get(() => ({
    path: oneDriveDir,
  }));

  const result = await backupService.findBackupsInWellKnownLocations();
  Assert.ok(result.found, "Backup found in Documents");

  sandbox.restore();
  await IOUtils.remove(testRoot, { recursive: true });
});

add_task(async function test_findBackupInOneDriveDocsAfterSignInToOneDrive() {
  Services.prefs.clearUserPref("browser.backup.location");

  const testRoot = await IOUtils.createUniqueDirectory(
    PathUtils.tempDir,
    test_findBackupInOneDriveDocsAfterSignInToOneDrive.name
  );

  const docsDir = PathUtils.join(testRoot, docsDirName);
  await IOUtils.makeDirectory(docsDir, { createAncestors: true });

  const oneDriveDir = PathUtils.join(testRoot, oneDriveDirName);
  const oneDriveDocsDir = PathUtils.join(oneDriveDir, docsDirName);
  const backupDir = PathUtils.join(oneDriveDocsDir, backupDirName);
  await IOUtils.makeDirectory(backupDir, { createAncestors: true });
  await createStubBackupFile(backupDir, backupFilename);

  let backupService = new BackupService();
  let sandbox = sinon.createSandbox();

  
  
  sandbox.stub(BackupService, "docsDirFolderPath").get(() => ({
    path: oneDriveDocsDir,
  }));
  sandbox.stub(BackupService, "oneDriveFolderPath").get(() => ({
    path: oneDriveDir,
  }));

  const result = await backupService.findBackupsInWellKnownLocations();
  Assert.ok(result.found, "Backup found in OneDrive/Documents");

  sandbox.restore();
  await IOUtils.remove(testRoot, { recursive: true });
});
