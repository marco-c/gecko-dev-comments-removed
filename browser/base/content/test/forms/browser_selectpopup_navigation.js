


add_task(async function test_select_popup_closing_enables_pointer_events() {
  const INITIAL_PAGE = `
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Initial Page</title>
</head>
<body>
  <h1 id="heading">Initial Page</h1>
  <button id="testbutton">Click Me</button>
  <script>
    window.addEventListener("unload", () => {});
  </script>
</body>
</html>
`;

  const SELECT_PAGE = `
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Select Page</title>
</head>
<body>
  <select id="testselect">
    <option>Option 1</option>
    <option>Option 2</option>
    <option>Option 3</option>
  </select>
  <script>
    window.addEventListener("unload", () => {});
  </script>
</body>
</html>
`;

  const initialUrl = "data:text/html," + encodeURI(INITIAL_PAGE);
  const selectUrl = "data:text/html," + encodeURI(SELECT_PAGE);

  await BrowserTestUtils.withNewTab(
    {
      gBrowser,
      url: initialUrl,
    },
    async function (browser) {
      
      let loaded = BrowserTestUtils.browserLoaded(browser, false, selectUrl);
      BrowserTestUtils.startLoadingURIString(browser, selectUrl);
      await loaded;

      
      await SpecialPowers.spawn(browser, [], async () => {
        const select = content.document.getElementById("testselect");
        const focusPromise = new Promise(resolve => {
          select.addEventListener("focus", resolve, { once: true });
        });
        select.focus();
        await focusPromise;
      });

      
      let popup = await openSelectPopup("key");
      ok(popup, "Select popup should be open");

      
      is(popup.state, "open", "Popup should be in open state");

      
      is(
        browser.style.pointerEvents,
        "none",
        "Browser pointer events should be disabled while popup is open"
      );

      
      
      function preventDefault(event) {
        event.preventDefault();
      }
      popup.addEventListener("popuphiding", preventDefault);

      
      let pageshown = BrowserTestUtils.waitForContentEvent(browser, "pageshow");

      
      
      let commandEvent = new CommandEvent("AppCommand", {
        bubbles: true,
        cancelable: true,
        command: "Back",
      });
      document.documentElement.dispatchEvent(commandEvent);

      
      await pageshown;

      
      is(
        popup.state,
        "open",
        "Popup should still be open after back navigation"
      );

      popup.removeEventListener("popuphiding", preventDefault);

      
      
      EventUtils.synthesizeKey("KEY_Escape", {}, window);

      
      await TestUtils.waitForCondition(
        () => popup.state === "closed",
        "Waiting for popup to close after ESC",
        100,
        50
      );

      ok(true, "Popup closed without throwing exception");

      
      is(
        browser.style.pointerEvents,
        "",
        "Browser pointer events should be restored after popup closes"
      );

      
      
      let clickReceivedPromise = BrowserTestUtils.waitForContentEvent(
        browser,
        "click"
      );

      
      
      
      
      AccessibilityUtils.setEnv({ mustHaveAccessibleRule: false });

      
      EventUtils.synthesizeMouseAtCenter(browser, {}, window);
      AccessibilityUtils.resetEnv();

      let clickReceived = await clickReceivedPromise;
      ok(
        clickReceived,
        "Mouse events should reach the page after popup closes"
      );
    }
  );
});
