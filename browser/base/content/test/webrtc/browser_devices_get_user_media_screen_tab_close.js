


"use strict";

const TEST_ROOT = getRootDirectory(gTestPath).replace(
  "chrome://mochitests/content/",
  "https://example.com/"
);
const TEST_PAGE = TEST_ROOT + "get_user_media.html";






function testSelected(aTab) {
  is(aTab, gBrowser.selectedTab, "Tab is gBrowser.selectedTab");
  ok(aTab.hasAttribute("selected"), "Tab has attribute 'selected'");
  ok(
    aTab.hasAttribute("visuallyselected"),
    "Tab has attribute 'visuallyselected'"
  );
}





add_task(async function testScreenSharingTabClose() {
  let initialTab = await BrowserTestUtils.openNewForegroundTab(
    gBrowser,
    "https://example.com"
  );

  
  let tab = await BrowserTestUtils.openNewForegroundTab(gBrowser, TEST_PAGE);
  let browser = tab.linkedBrowser;
  testSelected(tab);

  
  await shareDevices(browser, false, false, SHARE_WINDOW);
  ok(
    browser._sharingState.webRTC.screen,
    "Tab has webRTC screen sharing state"
  );

  let recordingEndedPromise = expectObserverCalled(
    "recording-window-ended",
    1,
    tab.linkedBrowser.browsingContext
  );
  let tabClosedPromise = BrowserTestUtils.waitForCondition(
    () => gBrowser.selectedTab == initialTab,
    "Waiting for tab to close"
  );

  
  BrowserTestUtils.removeTab(tab, { animate: true });

  
  await recordingEndedPromise;

  
  await tabClosedPromise;

  
  testSelected(initialTab);

  
  ok(
    !gBrowser.selectedBrowser._sharingState?.webRTC?.screen,
    "Selected tab's browser doesn't have webRTC screen sharing state"
  );

  BrowserTestUtils.removeTab(initialTab);
});
