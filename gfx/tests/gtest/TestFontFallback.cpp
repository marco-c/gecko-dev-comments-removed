




#include "gtest/gtest.h"
#include "gfxPlatform.h"
#include "gfxPlatformFontList.h"
#include "gfxTypes.h"
#include "nsReadableUtils.h"
#include "nsString.h"
#include "nsTArray.h"

class FontFallbackTest : public ::testing::Test {
 protected:
  static void SetUpTestSuite() {
    
    gfxPlatform::GetPlatform();
  }

  static bool FontHasCharacter(gfxPlatformFontList* pfl,
                               const nsCString& fontName, uint32_t ch) {
    nsAutoString text;
    AppendUCS4ToUTF16(ch, text);
    nsTArray<nsCString> fontList;
    fontList.AppendElement(fontName);
    nsTArray<nsCString> fontsUsed;
    pfl->ListFontsUsedForString(text, fontList, fontsUsed);
    if (fontsUsed.IsEmpty()) {
      return false;
    }
    
    
    nsCString actualLower(fontsUsed[0]);
    ToLowerCase(actualLower);
    nsCString expectedLower(fontName);
    ToLowerCase(expectedLower);
    return actualLower.Equals(expectedLower);
  }
};

TEST_F(FontFallbackTest, ListFontsUsedForString_EmptyInput) {
  gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
  ASSERT_NE(pfl, nullptr);

  nsTArray<nsCString> fontList;
  fontList.AppendElement("DejaVu Sans"_ns);

  nsTArray<nsCString> fontsUsed;

  pfl->ListFontsUsedForString(nsAutoString(), fontList, fontsUsed);

  EXPECT_EQ(fontsUsed.Length(), 0u) << "Empty text should use no fonts";
}

TEST_F(FontFallbackTest, ListFontsUsedForString_EmptyFontList) {
  gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
  ASSERT_NE(pfl, nullptr);

  nsTArray<nsCString> emptyFontList;
  nsTArray<nsCString> fontsUsed;

  pfl->ListFontsUsedForString(u"Hi"_ns, emptyFontList, fontsUsed);

  EXPECT_EQ(fontsUsed.Length(), 0u) << "Empty font list should use no fonts";
}

TEST_F(FontFallbackTest, ListFontsUsedForString_BasicUsage) {
  gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
  ASSERT_NE(pfl, nullptr);

  
  const char* commonFonts[] = {"DejaVu Sans", "Liberation Sans", "Roboto",
                               "Noto Sans",   "Arial",           "Helvetica",
                               "Sans"};

  nsCString workingFont;
  for (const char* fontNameStr : commonFonts) {
    nsCString fontName(fontNameStr);
    if (FontHasCharacter(pfl, fontName, 'A')) {
      workingFont = fontName;
      break;
    }
  }

  if (workingFont.IsEmpty()) {
    GTEST_SKIP() << "No common test fonts available on this system";
  }

  nsTArray<nsCString> fontList;
  fontList.AppendElement(workingFont);

  nsTArray<nsCString> fontsUsed;

  pfl->ListFontsUsedForString(u"Hello"_ns, fontList, fontsUsed);

  EXPECT_EQ(fontsUsed.Length(), 1u)
      << "Should use exactly one font for 'Hello'";

  if (fontsUsed.Length() > 0) {
    
    nsCString expectedLower(workingFont);
    ToLowerCase(expectedLower);
    nsCString actualLower(fontsUsed[0]);
    ToLowerCase(actualLower);
    EXPECT_EQ(actualLower, expectedLower);
  }
}

TEST_F(FontFallbackTest, ListFontsUsedForString_NonExistentFont) {
  gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
  ASSERT_NE(pfl, nullptr);

  nsTArray<nsCString> fontList;
  fontList.AppendElement("This Font Does Not Exist 12345"_ns);

  nsTArray<nsCString> fontsUsed;

  pfl->ListFontsUsedForString(u"A"_ns, fontList, fontsUsed);

  
  
  EXPECT_EQ(fontsUsed.Length(), 1u)
      << "Global fallback should find exactly one font for 'A'";
}

TEST_F(FontFallbackTest, ListFontsUsedForString_FallbackOrder) {
  gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
  ASSERT_NE(pfl, nullptr);

  
  const char* commonFonts[] = {
      "DejaVu Sans",  "Liberation Sans",  "Roboto",     "Noto Sans",
      "DejaVu Serif", "Liberation Serif", "Noto Serif", "Nimbus Sans",
      "Nimbus Roman", "FreeSans",         "FreeSerif"};

  nsTArray<nsCString> existingFonts;
  for (const char* fontNameStr : commonFonts) {
    nsCString fontName(fontNameStr);
    if (FontHasCharacter(pfl, fontName, 'A')) {
      existingFonts.AppendElement(fontName);
      if (existingFonts.Length() >= 2) {
        break;
      }
    }
  }

  if (existingFonts.Length() < 2) {
    GTEST_SKIP() << "Need at least 2 fonts for fallback order test";
  }

  
  nsTArray<nsCString> fontList;
  fontList.AppendElement(existingFonts[0]);
  fontList.AppendElement(existingFonts[1]);

  nsTArray<nsCString> fontsUsed;

  pfl->ListFontsUsedForString(u"A"_ns, fontList, fontsUsed);

  EXPECT_EQ(fontsUsed.Length(), 1u);
  if (fontsUsed.Length() > 0) {
    nsCString expectedLower(existingFonts[0]);
    ToLowerCase(expectedLower);
    nsCString actualLower(fontsUsed[0]);
    ToLowerCase(actualLower);
    EXPECT_EQ(actualLower, expectedLower)
        << "First font in list should be used when both have the character";
  }
}

TEST_F(FontFallbackTest, ListFontsUsedForString_MultipleFontsWithEmoji) {
  gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
  ASSERT_NE(pfl, nullptr);

  
  const uint32_t grinningFace = 0x1F600;

  
  const char* textFonts[] = {"DejaVu Sans", "Liberation Sans", "Roboto",
                             "Noto Sans",   "DejaVu Serif",    "FreeSans",
                             "Nimbus Sans"};
  
  const char* emojiFonts[] = {"Noto Color Emoji", "Noto Emoji",
                              "Twemoji",          "EmojiOne",
                              "Symbola",          "Segoe UI Emoji"};

  nsCString textFont;
  for (const char* fontNameStr : textFonts) {
    nsCString fontName(fontNameStr);
    bool hasA = FontHasCharacter(pfl, fontName, 'A');
    bool hasEmoji = FontHasCharacter(pfl, fontName, grinningFace);
    
    if (hasA && !hasEmoji) {
      textFont = fontName;
      break;
    }
  }

  nsCString emojiFont;
  for (const char* fontNameStr : emojiFonts) {
    nsCString fontName(fontNameStr);
    if (FontHasCharacter(pfl, fontName, grinningFace)) {
      emojiFont = fontName;
      break;
    }
  }

  if (textFont.IsEmpty() || emojiFont.IsEmpty()) {
    GTEST_SKIP() << "Need both a text font (without emoji) and an emoji font. "
                 << "textFont='"
                 << (textFont.IsEmpty() ? "(none)" : textFont.get()) << "' "
                 << "emojiFont='"
                 << (emojiFont.IsEmpty() ? "(none)" : emojiFont.get()) << "'";
  }

  
  nsTArray<nsCString> fontList;
  fontList.AppendElement(textFont);
  fontList.AppendElement(emojiFont);

  nsTArray<nsCString> fontsUsed;

  pfl->ListFontsUsedForString(u"Hi \U0001F600"_ns, fontList, fontsUsed);

  EXPECT_EQ(fontsUsed.Length(), 2u)
      << "Should use exactly 2 fonts: one for text, one for emoji";

  if (fontsUsed.Length() == 2) {
    
    nsCString textFontLower(textFont);
    ToLowerCase(textFontLower);
    nsCString emojiFontLower(emojiFont);
    ToLowerCase(emojiFontLower);

    nsCString firstUsedLower(fontsUsed[0]);
    ToLowerCase(firstUsedLower);
    nsCString secondUsedLower(fontsUsed[1]);
    ToLowerCase(secondUsedLower);

    EXPECT_EQ(firstUsedLower, textFontLower)
        << "First font used should be the text font";
    EXPECT_EQ(secondUsedLower, emojiFontLower)
        << "Second font used should be the emoji font";
  }
}

TEST_F(FontFallbackTest, ListFontsUsedForString_VisibilityFilter) {
  gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
  ASSERT_NE(pfl, nullptr);

  
  const char* commonFonts[] = {"DejaVu Sans", "Liberation Sans", "Roboto",
                               "Noto Sans",   "Arial",           "Helvetica",
                               "Sans"};

  nsCString workingFont;
  for (const char* fontNameStr : commonFonts) {
    nsCString fontName(fontNameStr);
    if (FontHasCharacter(pfl, fontName, 'A')) {
      workingFont = fontName;
      break;
    }
  }

  if (workingFont.IsEmpty()) {
    GTEST_SKIP() << "No common test fonts available on this system";
  }

  nsTArray<nsCString> fontList;
  fontList.AppendElement(workingFont);

  
  nsTArray<nsCString> fontsUsedUser;
  pfl->ListFontsUsedForString(u"A"_ns, fontList, fontsUsedUser,
                              FontVisibility::User);

  
  
  

  
  nsTArray<nsCString> fontsUsedBase;
  pfl->ListFontsUsedForString(u"A"_ns, fontList, fontsUsedBase,
                              FontVisibility::Base);

  
  EXPECT_LE(fontsUsedBase.Length(), 1u)
      << "With Base visibility, should have at most one font";

  EXPECT_LE(fontsUsedUser.Length(), 1u)
      << "With User visibility, should have at most one font";
}

TEST_F(FontFallbackTest, ListFontsUsedForString_DefaultVisibility) {
  gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
  ASSERT_NE(pfl, nullptr);

  const char* commonFonts[] = {"DejaVu Sans", "Liberation Sans", "Roboto",
                               "Noto Sans",   "Arial",           "Helvetica",
                               "Sans"};

  nsCString workingFont;
  for (const char* fontNameStr : commonFonts) {
    nsCString fontName(fontNameStr);
    if (FontHasCharacter(pfl, fontName, 'A')) {
      workingFont = fontName;
      break;
    }
  }

  if (workingFont.IsEmpty()) {
    GTEST_SKIP() << "No common test fonts available on this system";
  }

  nsTArray<nsCString> fontList;
  fontList.AppendElement(workingFont);

  
  nsTArray<nsCString> fontsUsedDefault;
  pfl->ListFontsUsedForString(u"Test"_ns, fontList, fontsUsedDefault);

  
  nsTArray<nsCString> fontsUsedUser;
  pfl->ListFontsUsedForString(u"Test"_ns, fontList, fontsUsedUser,
                              FontVisibility::User);

  
  EXPECT_EQ(fontsUsedDefault.Length(), fontsUsedUser.Length())
      << "Default visibility should match explicit User visibility";
}

TEST_F(FontFallbackTest, ListFontsUsedForString_VisibilityMonotonicity) {
  gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
  ASSERT_NE(pfl, nullptr);

  const char* commonFonts[] = {"DejaVu Sans", "Liberation Sans", "Roboto",
                               "Noto Sans",   "Arial",           "Helvetica",
                               "Sans"};

  nsCString workingFont;
  for (const char* fontNameStr : commonFonts) {
    nsCString fontName(fontNameStr);
    if (FontHasCharacter(pfl, fontName, 'A')) {
      workingFont = fontName;
      break;
    }
  }

  if (workingFont.IsEmpty()) {
    GTEST_SKIP() << "No common test fonts available on this system";
  }

  nsTArray<nsCString> fontList;
  fontList.AppendElement(workingFont);

  
  FontVisibility levels[] = {FontVisibility::Base, FontVisibility::LangPack,
                             FontVisibility::User, FontVisibility::Hidden};

  size_t prevFontsUsed = 0;
  for (FontVisibility vis : levels) {
    nsTArray<nsCString> fontsUsed;
    pfl->ListFontsUsedForString(u"Hello"_ns, fontList, fontsUsed, vis);

    
    EXPECT_GE(fontsUsed.Length(), prevFontsUsed)
        << "Visibility level " << static_cast<int>(vis)
        << " should not have fewer fonts than more restrictive levels";
    prevFontsUsed = fontsUsed.Length();
  }
}

TEST_F(FontFallbackTest, ListFontsUsedForString_VisibilityWithMultipleFonts) {
  gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
  ASSERT_NE(pfl, nullptr);

  
  const char* commonFonts[] = {
      "DejaVu Sans",  "Liberation Sans",  "Roboto",     "Noto Sans",
      "DejaVu Serif", "Liberation Serif", "Noto Serif", "Nimbus Sans",
      "FreeSans",     "FreeSerif"};

  nsTArray<nsCString> existingFonts;
  for (const char* fontNameStr : commonFonts) {
    nsCString fontName(fontNameStr);
    if (FontHasCharacter(pfl, fontName, 'A')) {
      existingFonts.AppendElement(fontName);
      if (existingFonts.Length() >= 3) {
        break;
      }
    }
  }

  if (existingFonts.Length() < 2) {
    GTEST_SKIP() << "Need at least 2 fonts for this test";
  }

  
  nsTArray<nsCString> fontsUsedHidden;
  pfl->ListFontsUsedForString(u"ABC"_ns, existingFonts, fontsUsedHidden,
                              FontVisibility::Hidden);

  
  
  EXPECT_GE(fontsUsedHidden.Length(), 1u)
      << "Should use at least one font for basic Latin chars";
}

TEST_F(FontFallbackTest, ListFontsUsedForString_VariantI_EmojiFontList) {
  gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
  ASSERT_NE(pfl, nullptr);

  
  nsTArray<nsCString> emojiFontList;
  emojiFontList.AppendElement("Apple Color Emoji"_ns);
  emojiFontList.AppendElement("Segoe UI Emoji"_ns);
  emojiFontList.AppendElement("Segoe UI Symbol"_ns);
  emojiFontList.AppendElement("Noto Color Emoji"_ns);
  emojiFontList.AppendElement("EmojiOne Color"_ns);
  emojiFontList.AppendElement("Android Emoji"_ns);
  emojiFontList.AppendElement("sans-serif"_ns);

  
  nsAutoString emojiText;
  AppendUCS4ToUTF16(0x1F600, emojiText);  
  AppendUCS4ToUTF16(0x263A, emojiText);   
  AppendUCS4ToUTF16(0x2708, emojiText);   

  nsTArray<nsCString> fontsAllowlisted;
  pfl->ListFontsUsedForString(emojiText, emojiFontList, fontsAllowlisted,
                              FontVisibility::LangPack);
  nsTArray<nsCString> fontsNonAllowlisted;
  pfl->ListFontsUsedForString(emojiText, emojiFontList, fontsNonAllowlisted,
                              FontVisibility::User);

  
  EXPECT_GE(fontsNonAllowlisted.Length(), fontsAllowlisted.Length());

  
  EXPECT_GT(fontsNonAllowlisted.Length(), 0u)
      << "Should find at least one emoji font for basic emoji codepoints";
}
