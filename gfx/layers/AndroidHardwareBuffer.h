





#ifndef MOZILLA_LAYERS_ANDROID_HARDWARE_BUFFER
#define MOZILLA_LAYERS_ANDROID_HARDWARE_BUFFER

#include <android/hardware_buffer.h>
#include <atomic>
#include <unordered_map>

#include "mozilla/layers/TextureClient.h"
#include "mozilla/gfx/Types.h"
#include "mozilla/gfx/2D.h"
#include "mozilla/Monitor.h"
#include "mozilla/RefPtr.h"
#include "mozilla/StaticPtr.h"
#include "mozilla/ThreadSafeWeakPtr.h"
#include "mozilla/UniquePtrExtensions.h"

namespace mozilla {
namespace layers {







class AndroidHardwareBuffer
    : public SupportsThreadSafeWeakPtr<AndroidHardwareBuffer> {
 public:
  MOZ_DECLARE_REFCOUNTED_TYPENAME(AndroidHardwareBuffer)

  static already_AddRefed<AndroidHardwareBuffer> Create(
      gfx::IntSize aSize, gfx::SurfaceFormat aFormat);

  virtual ~AndroidHardwareBuffer();

  int Lock(uint64_t aUsage, const ARect* aRect, void** aOutVirtualAddress);
  int Unlock();

  AHardwareBuffer* GetNativeBuffer() const { return mNativeBuffer; }

  void SetAcquireFence(UniqueFileHandle&& aFenceFd);

  void SetReleaseFence(UniqueFileHandle&& aFenceFd);

  UniqueFileHandle GetAndResetReleaseFence();

  UniqueFileHandle GetAndResetAcquireFence();

  UniqueFileHandle GetAcquireFence() const;

  const gfx::IntSize mSize;
  const uint32_t mStride;
  const gfx::SurfaceFormat mFormat;
  const uint64_t mId;

 protected:
  AndroidHardwareBuffer(AHardwareBuffer* aNativeBuffer, gfx::IntSize aSize,
                        uint32_t aStride, gfx::SurfaceFormat aFormat,
                        uint64_t aId);

  void SetReleaseFence(UniqueFileHandle&& aFenceFd,
                       const MonitorAutoLock& aAutoLock);

  AHardwareBuffer* mNativeBuffer;

  
  
  bool mIsRegistered;

  

  
  
  
  UniqueFileHandle mReleaseFenceFd;

  
  
  
  UniqueFileHandle mAcquireFenceFd;

  static uint64_t GetNextId();

  friend class AndroidHardwareBufferManager;
};






class AndroidHardwareBufferManager {
 public:
  static void Init();
  static void Shutdown();

  AndroidHardwareBufferManager();

  static AndroidHardwareBufferManager* Get() { return sInstance; }

  void Register(RefPtr<AndroidHardwareBuffer> aBuffer);

  void Unregister(AndroidHardwareBuffer* aBuffer);

  already_AddRefed<AndroidHardwareBuffer> GetBuffer(uint64_t aBufferId);

  Monitor& GetMonitor() { return mMonitor; }

 private:
  Monitor mMonitor MOZ_UNANNOTATED;
  std::unordered_map<uint64_t, ThreadSafeWeakPtr<AndroidHardwareBuffer>>
      mBuffers;

  static StaticAutoPtr<AndroidHardwareBufferManager> sInstance;
};

}  
}  

#endif
