



#![forbid(unsafe_code)]



use crate::derives::*;
use crate::properties::Importance;
use crate::shared_lock::{SharedRwLockReadGuard, StylesheetGuards};
use crate::stylesheets::Origin;
use crate::values::animated::ToAnimatedValue;





















#[derive(
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    MallocSizeOf,
    Ord,
    PartialEq,
    PartialOrd,
    SpecifiedValueInfo,
    ToAnimatedValue,
    ToComputedValue,
    ToResolvedValue,
    ToShmem,
    Serialize,
    Deserialize,
)]
#[repr(C, u8)]
pub enum CascadeLevel {
    
    UANormal,
    
    UserNormal,
    
    PresHints,
    
    AuthorNormal {
        
        
        
        
        
        
        
        
        
        shadow_cascade_order: ShadowCascadeOrder,
    },
    
    PositionFallback,
    
    SMILOverride,
    
    Animations,
    
    AuthorImportant {
        
        
        shadow_cascade_order: ShadowCascadeOrder,
    },
    
    UserImportant,
    
    UAImportant,
    
    Transitions,
}

impl CascadeLevel {
    
    pub fn important(&self) -> Self {
        match *self {
            Self::UANormal => Self::UAImportant,
            Self::UserNormal => Self::UserImportant,
            Self::AuthorNormal {
                shadow_cascade_order,
            } => Self::AuthorImportant {
                shadow_cascade_order: -shadow_cascade_order,
            },
            Self::PresHints
            | Self::PositionFallback
            | Self::SMILOverride
            | Self::Animations
            | Self::AuthorImportant { .. }
            | Self::UserImportant
            | Self::UAImportant
            | Self::Transitions => *self,
        }
    }

    
    pub fn unimportant(&self) -> Self {
        match *self {
            Self::UAImportant => Self::UANormal,
            Self::UserImportant => Self::UserNormal,
            Self::AuthorImportant {
                shadow_cascade_order,
            } => Self::AuthorNormal {
                shadow_cascade_order: -shadow_cascade_order,
            },
            Self::PresHints
            | Self::PositionFallback
            | Self::SMILOverride
            | Self::Animations
            | Self::AuthorNormal { .. }
            | Self::UserNormal
            | Self::UANormal
            | Self::Transitions => *self,
        }
    }

    
    pub fn guard<'a>(&self, guards: &'a StylesheetGuards<'a>) -> &'a SharedRwLockReadGuard<'a> {
        match *self {
            Self::UANormal | Self::UserNormal | Self::UserImportant | Self::UAImportant => {
                guards.ua_or_user
            },
            _ => guards.author,
        }
    }

    
    
    #[inline]
    pub fn same_tree_author_important() -> Self {
        Self::AuthorImportant {
            shadow_cascade_order: ShadowCascadeOrder::for_same_tree(),
        }
    }

    
    
    #[inline]
    pub fn same_tree_author_normal() -> Self {
        Self::AuthorNormal {
            shadow_cascade_order: ShadowCascadeOrder::for_same_tree(),
        }
    }

    
    
    #[inline]
    pub fn is_important(&self) -> bool {
        match *self {
            Self::AuthorImportant { .. } | Self::UserImportant | Self::UAImportant => true,
            _ => false,
        }
    }

    
    
    #[inline]
    pub fn importance(&self) -> Importance {
        if self.is_important() {
            Importance::Important
        } else {
            Importance::Normal
        }
    }

    
    #[inline]
    pub fn origin(&self) -> Origin {
        match *self {
            Self::UAImportant | Self::UANormal => Origin::UserAgent,
            Self::UserImportant | Self::UserNormal => Origin::User,
            Self::PresHints
            | Self::PositionFallback { .. }
            | Self::AuthorNormal { .. }
            | Self::AuthorImportant { .. }
            | Self::SMILOverride
            | Self::Animations
            | Self::Transitions => Origin::Author,
        }
    }

    
    #[inline]
    pub fn is_animation(&self) -> bool {
        match *self {
            Self::SMILOverride | Self::Animations | Self::Transitions => true,
            _ => false,
        }
    }

    
    #[inline]
    pub fn is_tree(&self) -> bool {
        matches!(
            *self,
            Self::AuthorImportant { .. } | Self::AuthorNormal { .. }
        )
    }
}







#[derive(
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    MallocSizeOf,
    Ord,
    PartialEq,
    PartialOrd,
    SpecifiedValueInfo,
    ToComputedValue,
    ToResolvedValue,
    ToShmem,
    Serialize,
    Deserialize,
)]
#[repr(transparent)]
pub struct ShadowCascadeOrder(i8);

impl ShadowCascadeOrder {
    
    
    
    const MAX: i8 = 0b111;
    const MIN: i8 = -Self::MAX;

    
    
    #[inline]
    pub fn for_outermost_shadow_tree() -> Self {
        Self(-1)
    }

    
    #[inline]
    pub fn for_same_tree() -> Self {
        Self(0)
    }

    
    
    #[inline]
    pub fn for_innermost_containing_tree() -> Self {
        Self(1)
    }

    
    
    #[inline]
    pub fn dec(&mut self) {
        debug_assert!(self.0 < 0);
        if self.0 != Self::MIN {
            self.0 -= 1;
        }
    }

    
    
    #[inline]
    pub fn inc(&mut self) {
        debug_assert_ne!(self.0, -1);
        if self.0 != Self::MAX {
            self.0 += 1;
        }
    }
}

impl std::ops::Neg for ShadowCascadeOrder {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self(self.0.neg())
    }
}

impl ToAnimatedValue for ShadowCascadeOrder {
    type AnimatedValue = ShadowCascadeOrder;

    #[inline]
    fn to_animated_value(self, _: &crate::values::animated::Context) -> Self::AnimatedValue {
        self
    }

    #[inline]
    fn from_animated_value(animated: Self::AnimatedValue) -> Self {
        animated
    }
}
