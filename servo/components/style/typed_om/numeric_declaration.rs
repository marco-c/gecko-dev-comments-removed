





use crate::derives::*;
use crate::parser::{Parse, ParserContext};
use crate::typed_om::numeric_values::NoCalcNumeric;
use crate::values::generics::calc::CalcUnits;
use crate::values::specified::calc::{AllowParse, CalcNode};
use crate::values::specified::NoCalcLength;
use cssparser::{Parser, Token};
use style_traits::values::specified::AllowedNumericType;
use style_traits::{ParseError, StyleParseErrorKind};


#[derive(Clone, ToTyped)]
#[typed_value(derive_fields)]
pub enum NumericDeclaration {
    
    NoCalc(NoCalcNumeric),

    
    
    
    Calc(CalcNode),
}

impl Parse for NumericDeclaration {
    
    fn parse<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Self, ParseError<'i>> {
        let location = input.current_source_location();

        
        let token = input.next()?;

        
        match *token {
            Token::Dimension {
                value, ref unit, ..
            } => {
                NoCalcLength::parse_dimension(context, value, unit)
                    .map(NoCalcNumeric::Length)
                    .map(Self::NoCalc)
                    .map_err(|()| location.new_unexpected_token_error(token.clone()))

                

                

                
                
            },

            Token::Function(ref name) => {
                let function = CalcNode::math_function(context, name, location)?;
                let allow_all_units = AllowParse::new(CalcUnits::ALL);
                let node = CalcNode::parse(context, input, function, allow_all_units)?;

                let allow_all_types = AllowedNumericType::All;
                let _ = node
                    .clone()
                    .into_length_or_percentage(allow_all_types)
                    .map_err(|()| {
                        location.new_custom_error(StyleParseErrorKind::UnspecifiedError)
                    })?;

                

                Ok(Self::Calc(node))
            },

            ref token => return Err(location.new_unexpected_token_error(token.clone())),
        }
    }
}
