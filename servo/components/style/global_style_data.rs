





use crate::context::StyleSystemOptions;
#[cfg(feature = "gecko")]
use crate::gecko_bindings::bindings;
use crate::parallel::STYLE_THREAD_STACK_SIZE_KB;
use crate::shared_lock::SharedRwLock;
use crate::thread_state;
use parking_lot::{Mutex, RwLock, RwLockReadGuard};
#[cfg(all(unix, not(target_arch = "wasm32")))]
use std::os::unix::thread::{JoinHandleExt, RawPthread};
#[cfg(windows)]
use std::os::windows::{io::AsRawHandle, prelude::RawHandle};
use std::{io, sync::LazyLock, thread};
use thin_vec::ThinVec;


#[cfg(all(unix, not(target_arch = "wasm32")))]
pub type PlatformThreadHandle = RawPthread;

#[cfg(windows)]
pub type PlatformThreadHandle = RawHandle;



#[cfg(all(target_arch = "wasm32", not(feature = "gecko")))]
pub struct DummyThreadHandle;
#[cfg(all(target_arch = "wasm32", not(feature = "gecko")))]
impl DummyThreadHandle {
    
    pub fn join(&self) {
        
    }
}
#[cfg(all(target_arch = "wasm32", not(feature = "gecko")))]

pub type PlatformThreadHandle = DummyThreadHandle;


pub struct GlobalStyleData {
    
    pub shared_lock: SharedRwLock,

    
    pub options: StyleSystemOptions,
}


pub struct StyleThreadPool {
    
    pub num_threads: Option<usize>,

    
    
    
    
    style_thread_pool: RwLock<Option<rayon::ThreadPool>>,
}

fn thread_name(index: usize) -> String {
    format!("StyleThread#{}", index)
}








static STYLE_THREAD_JOIN_HANDLES: Mutex<Vec<thread::JoinHandle<()>>> = Mutex::new(Vec::new());

fn thread_spawn(options: rayon::ThreadBuilder) -> io::Result<()> {
    let mut b = thread::Builder::new();
    if let Some(name) = options.name() {
        b = b.name(name.to_owned());
    }
    if let Some(stack_size) = options.stack_size() {
        b = b.stack_size(stack_size);
    }
    let join_handle = b.spawn(|| options.run())?;
    STYLE_THREAD_JOIN_HANDLES.lock().push(join_handle);
    Ok(())
}

fn thread_startup(_index: usize) {
    thread_state::initialize_layout_worker_thread();
    #[cfg(feature = "gecko")]
    unsafe {
        bindings::Gecko_SetJemallocThreadLocalArena(true);
        let name = thread_name(_index);
        gecko_profiler::register_thread(&name);
    }
}

fn thread_shutdown(_: usize) {
    #[cfg(feature = "gecko")]
    unsafe {
        gecko_profiler::unregister_thread();
        bindings::Gecko_SetJemallocThreadLocalArena(false);
    }
}

impl StyleThreadPool {
    
    pub fn shutdown() {
        if STYLE_THREAD_JOIN_HANDLES.lock().is_empty() {
            return;
        }
        {
            
            let _ = STYLE_THREAD_POOL.style_thread_pool.write().take();
        }

        
        
        
        while let Some(join_handle) = STYLE_THREAD_JOIN_HANDLES.lock().pop() {
            let _ = join_handle.join();
        }
    }

    
    
    
    
    pub fn pool(&self) -> RwLockReadGuard<'_, Option<rayon::ThreadPool>> {
        self.style_thread_pool.read()
    }

    
    pub fn get_thread_handles(handles: &mut ThinVec<PlatformThreadHandle>) {
        
        
        LazyLock::force(&STYLE_THREAD_POOL);

        for join_handle in STYLE_THREAD_JOIN_HANDLES.lock().iter() {
            #[cfg(all(unix, not(target_arch = "wasm32")))]
            let handle = join_handle.as_pthread_t();
            #[cfg(windows)]
            let handle = join_handle.as_raw_handle();
            #[cfg(all(target_arch = "wasm32", not(feature = "gecko")))]
            let handle = {
                let _ = join_handle;
                DummyThreadHandle
            };

            handles.push(handle);
        }
    }
}

#[cfg(feature = "servo")]
fn stylo_threads_pref() -> i32 {
    style_config::get_i32("layout.threads")
}

#[cfg(feature = "gecko")]
fn stylo_threads_pref() -> i32 {
    static_prefs::pref!("layout.css.stylo-threads")
}



pub(crate) const STYLO_MAX_THREADS: usize = 6;


pub static STYLE_THREAD_POOL: LazyLock<StyleThreadPool> = LazyLock::new(|| {
    use std::cmp;
    
    
    let threads_pref: i32 = stylo_threads_pref();
    let num_threads = if threads_pref >= 0 {
        threads_pref as usize
    } else {
        
        
        #[cfg(feature = "gecko")]
        let num_threads = unsafe { bindings::Gecko_GetNumStyleThreads() };
        #[cfg(not(feature = "gecko"))]
        let num_threads = -1;

        if num_threads >= 0 {
            num_threads as usize
        } else {
            
            
            cmp::max(num_cpus::get() * 3 / 4, 1)
        }
    };

    let num_threads = cmp::min(num_threads, STYLO_MAX_THREADS);
    
    
    let (pool, num_threads) = if num_threads <= 1 {
        (None, None)
    } else {
        let workers = rayon::ThreadPoolBuilder::new()
            .spawn_handler(thread_spawn)
            .use_current_thread()
            .num_threads(num_threads)
            .thread_name(thread_name)
            .start_handler(thread_startup)
            .exit_handler(thread_shutdown)
            .stack_size(STYLE_THREAD_STACK_SIZE_KB * 1024)
            .build();
        (workers.ok(), Some(num_threads))
    };

    StyleThreadPool {
        num_threads,
        style_thread_pool: RwLock::new(pool),
    }
});


pub static GLOBAL_STYLE_DATA: LazyLock<GlobalStyleData> = LazyLock::new(|| GlobalStyleData {
    shared_lock: SharedRwLock::new_leaked(),
    options: StyleSystemOptions::default(),
});
