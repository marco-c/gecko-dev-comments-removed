





#include "mozilla/TaskQueue.h"

#include "mozilla/ProfilerRunnable.h"
#include "mozilla/FlowMarkers.h"
#include "nsIEventTarget.h"
#include "nsITargetShutdownTask.h"
#include "nsThreadUtils.h"
#include "nsQueryObject.h"

namespace mozilla {

static LazyLogModule sTaskQueueLog("TaskQueue");

#define LOG_TQ(level, msg, ...) \
  MOZ_LOG(sTaskQueueLog, level, (msg, ##__VA_ARGS__))

RefPtr<TaskQueue> TaskQueue::Create(already_AddRefed<nsIEventTarget> aTarget,
                                    StaticString aName,
                                    bool aSupportsTailDispatch) {
  nsCOMPtr<nsIEventTarget> target(std::move(aTarget));
  LOG_TQ(LogLevel::Debug,
         "Creating TaskQueue '%s' on target %p (supportsTailDispatch=%d)",
         aName.get(), target.get(), aSupportsTailDispatch);

  RefPtr<TaskQueue> queue =
      new TaskQueue(do_AddRef(target), aName, aSupportsTailDispatch);

  return queue;
}

TaskQueue::TaskQueue(already_AddRefed<nsIEventTarget> aTarget,
                     const char* aName, bool aSupportsTailDispatch)
    : AbstractThread(aSupportsTailDispatch),
      mTarget(aTarget),
      mQueueMonitor("TaskQueue::Queue"),
      mTailDispatcher(nullptr),
      mIsTargetShutdownTaskRegistered(false),
      mIsRunning(false),
      mIsShutdown(false),
      mName(aName) {}

TaskQueue::~TaskQueue() {
  LOG_TQ(LogLevel::Debug, "Destroying TaskQueue '%s'", mName);
  
  
  
  MOZ_ASSERT(mIsShutdown || mShutdownTasks.IsEmpty());
}

NS_IMPL_ADDREF(TaskQueue)
NS_IMPL_RELEASE(TaskQueue)

NS_INTERFACE_MAP_BEGIN(TaskQueue)
  NS_INTERFACE_MAP_ENTRY(nsIDirectTaskDispatcher)
  NS_INTERFACE_MAP_ENTRY(nsISerialEventTarget)
  NS_INTERFACE_MAP_ENTRY(nsIEventTarget)
  NS_INTERFACE_MAP_ENTRY(nsITargetShutdownTask)
  NS_INTERFACE_MAP_ENTRY_CONCRETE(TaskQueue)
NS_INTERFACE_MAP_END

TaskDispatcher& TaskQueue::TailDispatcher() {
  MOZ_ASSERT(IsCurrentThreadIn());
  MOZ_ASSERT(mTailDispatcher);
  return *mTailDispatcher;
}

void TaskQueue::TargetShutdown() {
  
  
  
  LOG_TQ(LogLevel::Debug, "TaskQueue::TargetShutdown '%s'", mName);
  BeginShutdown();
}

void TaskQueue::MaybeUnregisterTargetShutdownTask() {
  if (mIsTargetShutdownTaskRegistered) {
    mTarget->UnregisterShutdownTask(this);
    
    
    
    mIsTargetShutdownTaskRegistered = false;
  }
}



nsresult TaskQueue::DispatchLocked(nsCOMPtr<nsIRunnable>& aRunnable,
                                   DispatchFlags aFlags,
                                   DispatchReason aReason) {
  mQueueMonitor.AssertCurrentThreadOwns();

  
  
  if (mIsShutdown) {
    LOG_TQ(LogLevel::Debug,
           "TaskQueue::DispatchLocked '%s' %s dispatch during shutdown", mName,
           mIsRunning ? "accepting" : "rejecting");
    if (!mIsRunning) {
      return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
    }
  }

  AbstractThread* currentThread;
  if (aReason != TailDispatch && (currentThread = GetCurrent()) &&
      RequiresTailDispatch(currentThread) &&
      currentThread->IsTailDispatcherAvailable()) {
    return currentThread->TailDispatcher().AddTask(this, aRunnable.forget());
  }

  PROFILER_MARKER("TaskQueue::DispatchLocked", OTHER,
                  {MarkerStack::MaybeCapture(
                      profiler_feature_active(ProfilerFeature::Flows))},
                  FlowMarker, Flow::FromPointer(aRunnable.get()));
  LogRunnable::LogDispatch(aRunnable);
  mTasks.Push({std::move(aRunnable), aFlags});

  if (mIsRunning) {
    return NS_OK;
  }
  RefPtr<nsIRunnable> runner(new Runner(this));
  nsresult rv =
      mTarget->Dispatch(runner.forget(), aFlags | NS_DISPATCH_FALLIBLE);
  if (NS_FAILED(rv)) {
    NS_WARNING("Failed to dispatch runnable to run TaskQueue");
    return rv;
  }
  mIsRunning = true;

  return NS_OK;
}

nsresult TaskQueue::RegisterShutdownTask(nsITargetShutdownTask* aTask) {
  NS_ENSURE_ARG(aTask);

  LOG_TQ(LogLevel::Debug,
         "TaskQueue::RegisterShutdownTask '%s' registering shutdown task %p",
         mName, aTask);
  MonitorAutoLock mon(mQueueMonitor);
  if (mIsShutdown) {
    return NS_ERROR_UNEXPECTED;
  }
  if (!mIsTargetShutdownTaskRegistered && mShutdownTasks.IsEmpty()) {
    FeatureFlags f = mTarget->GetFeatures();
    if ((f & SUPPORTS_SHUTDOWN_TASKS) &&
        (f & SUPPORTS_SHUTDOWN_TASK_DISPATCH)) {
      MOZ_TRY(mTarget->RegisterShutdownTask(this));
      mIsTargetShutdownTaskRegistered = true;
    }
  }
  return mShutdownTasks.AddTask(aTask);
}

nsresult TaskQueue::UnregisterShutdownTask(nsITargetShutdownTask* aTask) {
  NS_ENSURE_ARG(aTask);

  LOG_TQ(
      LogLevel::Debug,
      "TaskQueue::UnregisterShutdownTask '%s' unregistering shutdown task %p",
      mName, aTask);
  MonitorAutoLock mon(mQueueMonitor);
  nsresult rv = mShutdownTasks.RemoveTask(aTask);
  if (mShutdownTasks.IsEmpty()) {
    MaybeUnregisterTargetShutdownTask();
  }
  return rv;
}

nsIEventTarget::FeatureFlags TaskQueue::GetFeatures() {
  FeatureFlags supports = SUPPORTS_BASE;
  nsCOMPtr<nsIEventTarget> target;
  {
    MonitorAutoLock mon(mQueueMonitor);
    target = mTarget;
  }
  if (target) {
    supports = target->GetFeatures();
  }
  
  
  
  return supports | SUPPORTS_SHUTDOWN_TASKS;
}

void TaskQueue::AwaitIdle() {
  MonitorAutoLock mon(mQueueMonitor);
  AwaitIdleLocked();
}

void TaskQueue::AwaitIdleLocked() {
  
  
  MOZ_ASSERT_IF(AbstractThread::GetCurrent(),
                !AbstractThread::GetCurrent()->HasTailTasksFor(this));

  mQueueMonitor.AssertCurrentThreadOwns();
  MOZ_ASSERT(mIsRunning || mTasks.IsEmpty());
  while (mIsRunning) {
    mQueueMonitor.Wait();
  }
  LOG_TQ(LogLevel::Debug, "TaskQueue::AwaitIdleLocked '%s' is now idle", mName);
}

void TaskQueue::AwaitShutdownAndIdle() {
  MOZ_ASSERT(!IsCurrentThreadIn());
  
  
  MOZ_ASSERT_IF(AbstractThread::GetCurrent(),
                !AbstractThread::GetCurrent()->HasTailTasksFor(this));

  MonitorAutoLock mon(mQueueMonitor);
  while (!mIsShutdown) {
    mQueueMonitor.Wait();
  }
  AwaitIdleLocked();
}

RefPtr<ShutdownPromise> TaskQueue::BeginShutdown() {
  LOG_TQ(LogLevel::Debug, "TaskQueue::BeginShutdown '%s'", mName);
  
  
  if (AbstractThread* currentThread = AbstractThread::GetCurrent()) {
    currentThread->TailDispatchTasksFor(this);
  }

  MonitorAutoLock mon(mQueueMonitor);
  if (!mIsShutdown) {
    MaybeUnregisterTargetShutdownTask();
    
    
    TargetShutdownTaskSet::TasksArray tasks = mShutdownTasks.Extract();
    for (auto& task : tasks) {
      LOG_TQ(LogLevel::Debug,
             "TaskQueue::BeginShutdown '%s' dispatching shutdown task %p",
             mName, task.get());
      nsCOMPtr runnable{task->AsRunnable()};
      MOZ_ALWAYS_SUCCEEDS(
          DispatchLocked(runnable, NS_DISPATCH_NORMAL, TailDispatch));
    }
    mIsShutdown = true;
  }

  RefPtr<ShutdownPromise> p = mShutdownPromise.Ensure(__func__);
  MaybeResolveShutdown();
  mon.NotifyAll();
  return p;
}

void TaskQueue::MaybeResolveShutdown() {
  mQueueMonitor.AssertCurrentThreadOwns();
  if (mIsShutdown && !mIsRunning) {
    LOG_TQ(LogLevel::Debug, "TaskQueue::MaybeResolveShutdown '%s' resolve",
           mName);
    MOZ_ASSERT(!mIsTargetShutdownTaskRegistered);
    mShutdownPromise.ResolveIfExists(true, __func__);
    
    mTarget = nullptr;
    mObserver = nullptr;
  }
}

bool TaskQueue::IsEmpty() {
  MonitorAutoLock mon(mQueueMonitor);
  return mTasks.IsEmpty();
}

bool TaskQueue::IsCurrentThreadIn() const {
  bool in = mRunningThread == PR_GetCurrentThread();
  return in;
}

void TaskQueue::SetObserver(Observer* aObserver) {
  MonitorAutoLock mon(mQueueMonitor);
  MOZ_ASSERT_IF(aObserver, !mObserver);
  mObserver = std::move(aObserver);
}

nsresult TaskQueue::Runner::Run() {
  TaskStruct event;
  RefPtr<Observer> observer;
  {
    MonitorAutoLock mon(mQueue->mQueueMonitor);
    MOZ_ASSERT(mQueue->mIsRunning);
    if (mQueue->mTasks.IsEmpty()) {
      mQueue->mIsRunning = false;
      mQueue->MaybeResolveShutdown();
      mon.NotifyAll();
      return NS_OK;
    }
    event = mQueue->mTasks.Pop();
    observer = mQueue->mObserver;
  }
  MOZ_ASSERT(event.event);

  
  
  
  
  
  {
    AutoTaskGuard g(mQueue, observer);
    {
      LogRunnable::Run log(event.event);

      AUTO_PROFILE_FOLLOWING_RUNNABLE(event.event);
      event.event->Run();

      
      
      
      
      
      event.event = nullptr;
    }
  }

  {
    MonitorAutoLock mon(mQueue->mQueueMonitor);
    if (mQueue->mTasks.IsEmpty()) {
      
      mQueue->mIsRunning = false;
      mQueue->MaybeResolveShutdown();
      mon.NotifyAll();
      return NS_OK;
    }
  }

  
  
  
  
  
  nsresult rv;
  {
    MonitorAutoLock mon(mQueue->mQueueMonitor);
    rv = mQueue->mTarget->Dispatch(this, mQueue->mTasks.FirstElement().flags |
                                             NS_DISPATCH_AT_END |
                                             NS_DISPATCH_FALLIBLE);
  }
  if (NS_FAILED(rv)) {
    
    MonitorAutoLock mon(mQueue->mQueueMonitor);
    mQueue->mIsRunning = false;
    mQueue->mIsShutdown = true;
    mQueue->MaybeUnregisterTargetShutdownTask();
    mQueue->MaybeResolveShutdown();
    mon.NotifyAll();
  }

  return NS_OK;
}





NS_IMETHODIMP
TaskQueue::DispatchDirectTask(already_AddRefed<nsIRunnable> aEvent) {
  if (!IsCurrentThreadIn()) {
    return NS_ERROR_FAILURE;
  }
  mDirectTasks.AddTask(std::move(aEvent));
  return NS_OK;
}

NS_IMETHODIMP TaskQueue::DrainDirectTasks() {
  if (!IsCurrentThreadIn()) {
    return NS_ERROR_FAILURE;
  }
  mDirectTasks.DrainTasks();
  return NS_OK;
}

NS_IMETHODIMP TaskQueue::HaveDirectTasks(bool* aValue) {
  if (!IsCurrentThreadIn()) {
    return NS_ERROR_FAILURE;
  }

  *aValue = mDirectTasks.HaveTasks();
  return NS_OK;
}

#undef LOG_TQ

}  
