





#include "mozilla/SharedThreadPool.h"

#include "mozilla/AppShutdown.h"
#include "mozilla/Logging.h"

#include "mozilla/AppShutdown.h"
#include "mozilla/Monitor.h"
#include "mozilla/ReentrantMonitor.h"
#include "mozilla/Services.h"
#include "mozilla/SpinEventLoopUntil.h"
#include "mozilla/StaticPtr.h"
#include "nsComponentManagerUtils.h"
#include "nsIObserver.h"
#include "nsIObserverService.h"
#include "nsIThreadManager.h"
#include "nsThreadPool.h"
#include "nsTHashMap.h"
#include "nsXPCOMCIDInternal.h"

static mozilla::LazyLogModule sSharedThreadPoolLog("SharedThreadPool");

#define STP_LOG(level, msg, ...) \
  MOZ_LOG_FMT(sSharedThreadPoolLog, level, msg, ##__VA_ARGS__)

namespace mozilla {


using PoolMap = nsTHashMap<nsCStringHashKey, RefPtr<SharedThreadPool>>;
static StaticMutex sPoolsMutex;
static StaticAutoPtr<PoolMap> sPools MOZ_GUARDED_BY(sPoolsMutex);
static bool sPoolsShutdownStarted MOZ_GUARDED_BY(sPoolsMutex) = false;

static already_AddRefed<nsIThreadPool> CreateThreadPool(const nsCString& aName,
                                                        uint32_t aThreadLimit) {
  nsCOMPtr<nsIThreadPool> pool = new nsThreadPool();

  nsresult rv = pool->SetName(aName);
  NS_ENSURE_SUCCESS(rv, nullptr);

  
  
  
  
  
  rv = pool->SetThreadLimit(aThreadLimit);
  NS_ENSURE_SUCCESS(rv, nullptr);

  

  
  
  rv = pool->SetIdleThreadGraceTimeout(500);
  NS_ENSURE_SUCCESS(rv, nullptr);
  rv = pool->SetIdleThreadMaximumTimeout(5000);
  NS_ENSURE_SUCCESS(rv, nullptr);

  return pool.forget();
}

class SharedThreadPoolShutdownObserver : public nsIObserver {
 public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSIOBSERVER
 protected:
  virtual ~SharedThreadPoolShutdownObserver() = default;
};

NS_IMPL_ISUPPORTS(SharedThreadPoolShutdownObserver, nsIObserver, nsISupports)

NS_IMETHODIMP
SharedThreadPoolShutdownObserver::Observe(nsISupports* aSubject,
                                          const char* aTopic,
                                          const char16_t* aData) {
  MOZ_RELEASE_ASSERT(!strcmp(aTopic, "xpcom-shutdown-threads"));

  
  
  
  
  
  
  nsTArray<RefPtr<SharedThreadPool>> pools;
  {
    StaticMutexAutoLock lock(sPoolsMutex);
    sPoolsShutdownStarted = true;
    AppendToArray(pools, sPools->Values());
  }
  for (const auto& pool : pools) {
    
    
    STP_LOG(LogLevel::Debug, "Shutdown {}", fmt::ptr(pool.get()));
    pool->Shutdown();
  }
  {
    StaticMutexAutoLock lock(sPoolsMutex);
    sPools->Clear();
  }
  pools.Clear();
  return NS_OK;
}

void SharedThreadPool::InitStatics() {
  MOZ_ASSERT(NS_IsMainThread());
  StaticMutexAutoLock lock(sPoolsMutex);
  MOZ_ASSERT(!sPools);
  sPools = new nsTHashMap<nsCStringHashKey, RefPtr<SharedThreadPool>>();
  nsCOMPtr<nsIObserverService> obsService =
      mozilla::services::GetObserverService();
  nsCOMPtr<nsIObserver> obs = new SharedThreadPoolShutdownObserver();
  obsService->AddObserver(obs, "xpcom-shutdown-threads", false);
}

already_AddRefed<SharedThreadPool> SharedThreadPool::Get(
    StaticString aName, uint32_t aThreadLimit) {
  StaticMutexAutoLock lock(sPoolsMutex);
  MOZ_ASSERT(sPools);

  nsCString name(aName);
  return sPools->WithEntryHandle(
      name, [&](auto&& entry) -> already_AddRefed<SharedThreadPool> {
        RefPtr<SharedThreadPool> pool;
        if (entry) {
          pool = entry.Data();
          if (NS_FAILED(pool->EnsureThreadLimitIsAtLeast(aThreadLimit))) {
            NS_WARNING("Failed to set limits on thread pool");
          }
          STP_LOG(LogLevel::Debug, "Existing {} found for {}",
                  fmt::ptr(pool.get()), name);
        } else {
          sPoolsMutex.AssertCurrentThreadOwns();
          if (sPoolsShutdownStarted) {
            
            return do_AddRef(new SharedThreadPool(nullptr));
          }

          nsCOMPtr<nsIThreadPool> threadPool(
              CreateThreadPool(name, aThreadLimit));
          if (NS_WARN_IF(!threadPool)) {
            return do_AddRef(new SharedThreadPool(nullptr));
          }
          pool = new SharedThreadPool(threadPool);
          
          entry.Insert(pool.get());
          STP_LOG(LogLevel::Debug, "New {} created for {}",
                  fmt::ptr(pool.get()), name);
        }

        return pool.forget();
      });
}

NS_IMPL_ISUPPORTS(SharedThreadPool, nsIThreadPool, nsIEventTarget)

SharedThreadPool::SharedThreadPool(nsIThreadPool* aPool) : mPool(aPool) {}

SharedThreadPool::~SharedThreadPool() = default;

nsresult SharedThreadPool::EnsureThreadLimitIsAtLeast(uint32_t aThreadLimit) {
  uint32_t existingLimit = 0;
  nsresult rv;

  rv = mPool->GetThreadLimit(&existingLimit);
  NS_ENSURE_SUCCESS(rv, rv);
  if (aThreadLimit > existingLimit) {
    rv = mPool->SetThreadLimit(aThreadLimit);
    NS_ENSURE_SUCCESS(rv, rv);
  }

  return NS_OK;
}

}  

#undef STP_LOG
