


"use strict";

const EventEmitter = require("resource://devtools/shared/event-emitter.js");

loader.lazyRequireGetter(
  this,
  "AccessibilityProxy",
  "resource://devtools/client/accessibility/accessibility-proxy.js",
  true
);
loader.lazyRequireGetter(
  this,
  "Picker",
  "resource://devtools/client/accessibility/picker.js",
  true
);


const EVENTS = {
  
  NEW_ACCESSIBLE_FRONT_SELECTED: "Accessibility:NewAccessibleFrontSelected",
  
  NEW_ACCESSIBLE_FRONT_HIGHLIGHTED:
    "Accessibility:NewAccessibleFrontHighlighted",
  
  NEW_ACCESSIBLE_FRONT_INSPECTED: "Accessibility:NewAccessibleFrontInspected",
  
  ACCESSIBILITY_INSPECTOR_UPDATED:
    "Accessibility:AccessibilityInspectorUpdated",
  
  INITIALIZED: "Accessibility:Initialized",
  
  
  PROPERTIES_UPDATED: "Accessibility:PropertiesUpdated",
};






class AccessibilityPanel {
  #toolbox;
  #commands;
  #opening;
  #telemetry;
  #timerID;
  #destroyed;

  constructor(iframeWindow, toolbox, commands) {
    this.panelWin = iframeWindow;
    this.#toolbox = toolbox;
    this.#commands = commands;

    this.onPanelVisibilityChange = this.onPanelVisibilityChange.bind(this);
    this.onNewAccessibleFrontSelected =
      this.onNewAccessibleFrontSelected.bind(this);
    this.onAccessibilityInspectorUpdated =
      this.onAccessibilityInspectorUpdated.bind(this);
    this.updateA11YServiceDurationTimer =
      this.updateA11YServiceDurationTimer.bind(this);
    this.forceUpdatePickerButton = this.forceUpdatePickerButton.bind(this);
    this.onLifecycleEvent = this.onLifecycleEvent.bind(this);

    EventEmitter.decorate(this);
  }
  


  async open() {
    if (this.#opening) {
      await this.#opening;
      return this.#opening;
    }

    
    let resolver;
    this.#opening = new Promise(resolve => {
      resolver = resolve;
    });

    
    
    const { promise, resolve } = Promise.withResolvers();
    this.initializedPromise = promise;

    this.#telemetry = this.#toolbox.telemetry;
    this.panelWin.gTelemetry = this.#telemetry;

    this.#toolbox.on("select", this.onPanelVisibilityChange);

    this.panelWin.EVENTS = EVENTS;
    EventEmitter.decorate(this.panelWin);
    this.panelWin.on(
      EVENTS.NEW_ACCESSIBLE_FRONT_SELECTED,
      this.onNewAccessibleFrontSelected
    );
    this.panelWin.on(
      EVENTS.ACCESSIBILITY_INSPECTOR_UPDATED,
      this.onAccessibilityInspectorUpdated
    );

    this.picker = new Picker(this);
    this.fluentBundles = await this.createFluentBundles();

    this.accessibilityProxy = new AccessibilityProxy(this.#commands, this);

    await this.accessibilityProxy.initialize();

    this.accessibilityProxy.startListeningForLifecycleEvents({
      init: this.onLifecycleEvent,
      shutdown: this.onLifecycleEvent,
    });

    
    this.updateA11YServiceDurationTimer();

    
    resolve();

    
    await this.forceRefresh();

    resolver(this);
    return this.#opening;
  }

  



  async createFluentBundles() {
    const locales = Services.locale.appLocalesAsBCP47;
    const generator = L10nRegistry.getInstance().generateBundles(locales, [
      "devtools/client/accessibility.ftl",
    ]);

    
    
    const contexts = [];
    for await (const message of generator) {
      contexts.push(message);
    }

    return contexts;
  }

  onLifecycleEvent() {
    this.updateA11YServiceDurationTimer();
    this.forceUpdatePickerButton();
  }

  onNewAccessibleFrontSelected(selected) {
    this.emit("new-accessible-front-selected", selected);
  }

  onAccessibilityInspectorUpdated() {
    this.emit("accessibility-inspector-updated");
  }

  




  async forceRefresh() {
    this.shouldRefresh = true;

    
    await this.initializedPromise;
    const onUpdated = this.panelWin.once(EVENTS.INITIALIZED);
    this.refresh();
    await onUpdated;

    this.emit("reloaded");
  }

  


  onPanelVisibilityChange() {
    this.#opening.then(() => this.refresh());
  }

  refresh() {
    this.cancelPicker();

    if (!this.isVisible) {
      
      return;
    }

    
    if (!this.shouldRefresh) {
      return;
    }
    
    this.shouldRefresh = false;
    const {
      supports,
      getAccessibilityTreeRoot,
      startListeningForAccessibilityEvents,
      stopListeningForAccessibilityEvents,
      audit,
      simulate,
      toggleDisplayTabbingOrder,
      enableAccessibility,
      resetAccessiblity,
      startListeningForLifecycleEvents,
      stopListeningForLifecycleEvents,
      startListeningForParentLifecycleEvents,
      stopListeningForParentLifecycleEvents,
      highlightAccessible,
      unhighlightAccessible,
    } = this.accessibilityProxy;
    this.postContentMessage("initialize", {
      fluentBundles: this.fluentBundles,
      toolbox: this.#toolbox,
      supports,
      getAccessibilityTreeRoot,
      startListeningForAccessibilityEvents,
      stopListeningForAccessibilityEvents,
      audit,
      simulate,
      toggleDisplayTabbingOrder,
      enableAccessibility,
      resetAccessiblity,
      startListeningForLifecycleEvents,
      stopListeningForLifecycleEvents,
      startListeningForParentLifecycleEvents,
      stopListeningForParentLifecycleEvents,
      highlightAccessible,
      unhighlightAccessible,
    });
  }

  updateA11YServiceDurationTimer() {
    if (this.accessibilityProxy.enabled) {
      this.#timerID = Glean.devtools.accessibilityServiceTimeActive.start();
    } else if (this.#timerID) {
      Glean.devtools.accessibilityServiceTimeActive.stopAndAccumulate(
        this.#timerID
      );
      this.#timerID = null;
    }
  }

  selectAccessible(accessibleFront) {
    this.postContentMessage("selectAccessible", accessibleFront);
  }

  selectAccessibleForNode(nodeFront, reason) {
    if (reason) {
      Glean.devtoolsAccessibility.selectAccessibleForNode[reason].add(1);
    }

    this.postContentMessage("selectNodeAccessible", nodeFront);
  }

  highlightAccessible(accessibleFront) {
    this.postContentMessage("highlightAccessible", accessibleFront);
  }

  postContentMessage(type, ...args) {
    const event = new this.panelWin.MessageEvent("devtools/chrome/message", {
      bubbles: true,
      cancelable: true,
      data: { type, args },
    });

    this.panelWin.dispatchEvent(event);
  }

  updatePickerButton() {
    this.picker && this.picker.updateButton();
  }

  forceUpdatePickerButton() {
    
    if (!this.isVisible) {
      return;
    }

    this.updatePickerButton();
    
    this.#toolbox.component.setToolboxButtons(this.#toolbox.toolbarButtons);
  }

  togglePicker() {
    this.picker && this.picker.toggle();
  }

  cancelPicker() {
    this.picker && this.picker.cancel();
  }

  stopPicker() {
    this.picker && this.picker.stop();
  }

  


  get isVisible() {
    return this.#toolbox.currentToolId === "accessibility";
  }

  get toolbox() {
    return this.#toolbox;
  }

  destroy() {
    if (this.#destroyed) {
      return;
    }
    this.#destroyed = true;

    this.postContentMessage("destroy");

    if (this.accessibilityProxy) {
      this.accessibilityProxy.stopListeningForLifecycleEvents({
        init: this.onLifecycleEvent,
        shutdown: this.onLifecycleEvent,
      });
      this.accessibilityProxy.destroy();
      this.accessibilityProxy = null;
      this.initializedPromise = null;
    }

    this.#toolbox.off("select", this.onPanelVisibilityChange);

    this.panelWin.off(
      EVENTS.NEW_ACCESSIBLE_FRONT_SELECTED,
      this.onNewAccessibleFrontSelected
    );
    this.panelWin.off(
      EVENTS.ACCESSIBILITY_INSPECTOR_UPDATED,
      this.onAccessibilityInspectorUpdated
    );

    
    if (this.picker) {
      this.picker.release();
      this.picker = null;
    }

    this.#telemetry = null;
    this.panelWin.gTelemetry = null;

    this.emit("destroyed");
  }
}


exports.AccessibilityPanel = AccessibilityPanel;
