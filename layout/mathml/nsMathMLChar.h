





#ifndef nsMathMLChar_h_
#define nsMathMLChar_h_

#include "gfxTextRun.h"
#include "mozilla/EnumSet.h"
#include "nsBoundingMetrics.h"
#include "nsColor.h"
#include "nsMathMLOperators.h"
#include "nsPoint.h"
#include "nsRect.h"
#include "nsString.h"

class gfxContext;
class nsGlyphTable;
class nsIFrame;
class nsPresContext;
struct nsBoundingMetrics;
struct nsFont;

namespace mozilla {
class nsDisplayListBuilder;
class nsDisplayListSet;
class ComputedStyle;
}  


enum class MathMLStretchFlag : uint8_t {
  Normal,         
  Nearer,         
  Smaller,        
  Larger,         
  LargeOperator,  
  MaxWidth,       
};
using MathMLStretchFlags = mozilla::EnumSet<MathMLStretchFlag>;
constexpr MathMLStretchFlags kMathMLStretchVariableSet(
    MathMLStretchFlag::Normal, MathMLStretchFlag::Nearer,
    MathMLStretchFlag::Smaller, MathMLStretchFlag::Larger);
constexpr MathMLStretchFlags kMathMLStretchSet =
    kMathMLStretchVariableSet + MathMLStretchFlag::LargeOperator;





struct nsGlyphCode {
  union {
    char16_t code;
    uint32_t glyphID;
  };
  bool isGlyphID = true;

  bool Exists() const { return isGlyphID ? glyphID != 0 : code != 0; }
  bool operator==(const nsGlyphCode& other) const {
    return (other.isGlyphID == isGlyphID &&
            (isGlyphID ? other.glyphID == glyphID : other.code == code));
  }
  bool operator!=(const nsGlyphCode&) const = default;
};



class nsMathMLChar {
 public:
  typedef gfxTextRun::Range Range;
  typedef mozilla::gfx::DrawTarget DrawTarget;

  
  nsMathMLChar() : mDirection(StretchDirection::Default) {
    MOZ_COUNT_CTOR(nsMathMLChar);
    mComputedStyle = nullptr;
    mUnscaledAscent = 0;
    mScaleX = mScaleY = 1.0;
    mDrawingMethod = DrawingMethod::Normal;
    mMirroringMethod = MirroringMethod::None;
  }

  
  ~nsMathMLChar();

  void Display(mozilla::nsDisplayListBuilder* aBuilder, nsIFrame* aForFrame,
               const mozilla::nsDisplayListSet& aLists, uint32_t aIndex,
               const nsRect* aSelectedRect = nullptr);

  void PaintForeground(nsIFrame* aForFrame, gfxContext& aRenderingContext,
                       nsPoint aPt, bool aIsSelected);

  
  
  
  nsresult Stretch(nsIFrame* aForFrame, DrawTarget* aDrawTarget,
                   float aFontSizeInflation, StretchDirection aStretchDirection,
                   const nsBoundingMetrics& aContainerSize,
                   nsBoundingMetrics& aDesiredStretchSize,
                   MathMLStretchFlags aStretchFlags, bool aRTL);

  void SetData(nsString& aData);

  void GetData(nsString& aData) { aData = mData; }

  int32_t Length() { return mData.Length(); }

  StretchDirection GetStretchDirection() { return mDirection; }

  
  
  const char16_t* get() { return mData.get(); }

  void GetRect(nsRect& aRect) { aRect = mRect; }

  void SetRect(const nsRect& aRect) { mRect = aRect; }

  
  
  
  
  
  nscoord GetMaxWidth(
      nsIFrame* aForFrame, DrawTarget* aDrawTarget, float aFontSizeInflation,
      MathMLStretchFlags aStretchFlags = MathMLStretchFlag::Normal);

  
  
  
  
  
  void GetBoundingMetrics(nsBoundingMetrics& aBoundingMetrics) {
    aBoundingMetrics = mBoundingMetrics;
  }

  void SetBoundingMetrics(nsBoundingMetrics& aBoundingMetrics) {
    mBoundingMetrics = aBoundingMetrics;
  }

  
  
  
  
  mozilla::ComputedStyle* GetComputedStyle() const;

  void SetComputedStyle(mozilla::ComputedStyle* aComputedStyle);

  nscoord ItalicCorrection() const { return mItalicCorrection; }

 protected:
  friend class nsGlyphTable;
  friend class nsPropertiesTable;
  friend class nsOpenTypeTable;
  nsString mData;

 private:
  nsRect mRect;
  StretchDirection mDirection;
  nsBoundingMetrics mBoundingMetrics;
  RefPtr<mozilla::ComputedStyle> mComputedStyle;
  
  
  RefPtr<gfxTextRun> mGlyphs[4];
  nsBoundingMetrics mBmData[4];
  
  nscoord mUnscaledAscent;
  
  float mScaleX, mScaleY;

  
  
  
  
  
  enum class DrawingMethod : uint8_t { Normal, Variant, Parts };
  DrawingMethod mDrawingMethod;

  
  
  
  
  
  
  
  enum class MirroringMethod : uint8_t {
    None,
    Character,
    Glyph,
    ScaleFallback,
  };
  MirroringMethod mMirroringMethod;

  nscoord mItalicCorrection = 0;

  class StretchEnumContext;
  friend class StretchEnumContext;

  
  bool SetFontFamily(nsPresContext* aPresContext,
                     const nsGlyphTable* aGlyphTable,
                     const nsGlyphCode& aGlyphCode,
                     const mozilla::StyleFontFamilyList& aDefaultFamily,
                     nsFont& aFont, RefPtr<gfxFontGroup>* aFontGroup);

  nsresult StretchInternal(nsIFrame* aForFrame, DrawTarget* aDrawTarget,
                           float aFontSizeInflation,
                           StretchDirection& aStretchDirection,
                           const nsBoundingMetrics& aContainerSize,
                           nsBoundingMetrics& aDesiredStretchSize,
                           MathMLStretchFlags aStretchFlags,
                           float aMaxSize = NS_MATHML_OPERATOR_SIZE_INFINITY,
                           bool aMaxSizeIsAbsolute = false);

  nsresult PaintVertically(nsPresContext* aPresContext,
                           gfxContext* aThebesContext, nsRect& aRect,
                           nscolor aColor);

  nsresult PaintHorizontally(nsPresContext* aPresContext,
                             gfxContext* aThebesContext, nsRect& aRect,
                             nscolor aColor);

  void ApplyTransforms(gfxContext* aThebesContext, int32_t aAppUnitsPerGfxUnit,
                       nsRect& r);
};

#endif 
