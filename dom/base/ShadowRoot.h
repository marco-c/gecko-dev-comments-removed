





#ifndef mozilla_dom_shadowroot_h_
#define mozilla_dom_shadowroot_h_

#include "mozilla/BindgenUniquePtr.h"
#include "mozilla/DOMEventTargetHelper.h"
#include "mozilla/ServoBindingTypes.h"
#include "mozilla/dom/DocumentBinding.h"
#include "mozilla/dom/DocumentFragment.h"
#include "mozilla/dom/DocumentOrShadowRoot.h"
#include "mozilla/dom/NameSpaceConstants.h"
#include "mozilla/dom/ShadowRootBinding.h"
#include "nsCOMPtr.h"
#include "nsCycleCollectionParticipant.h"
#include "nsStubMutationObserver.h"
#include "nsTHashtable.h"

class nsAtom;
class nsIContent;
class nsIPrincipal;

namespace mozilla {

struct StyleAuthorStyles;
struct StyleRuleChange;

class EventChainPreVisitor;
class ServoStyleRuleMap;

enum class StyleRuleChangeKind : uint32_t;
enum class BuiltInStyleSheet : uint8_t;

namespace css {
class Rule;
}

namespace dom {

class CSSImportRule;
class Element;
class HTMLInputElement;
class OwningTrustedHTMLOrNullIsEmptyString;
class TrustedHTMLOrString;
class TrustedHTMLOrNullIsEmptyString;

#define SHADOW_ROOT_FLAG_BIT(n_) \
  NODE_FLAG_BIT(NODE_TYPE_SPECIFIC_BITS_OFFSET + (n_))


enum : uint32_t {
  
  SHADOW_ROOT_MODE_CLOSED = SHADOW_ROOT_FLAG_BIT(0),

  
  SHADOW_ROOT_DELEGATES_FOCUS = SHADOW_ROOT_FLAG_BIT(1),

  
  SHADOW_ROOT_SLOT_ASSIGNMENT_MANUAL = SHADOW_ROOT_FLAG_BIT(2),

  
  SHADOW_ROOT_IS_DECLARATIVE = SHADOW_ROOT_FLAG_BIT(3),

  
  SHADOW_ROOT_IS_CLONABLE = SHADOW_ROOT_FLAG_BIT(4),

  
  SHADOW_ROOT_IS_SERIALIZABLE = SHADOW_ROOT_FLAG_BIT(5),

  
  SHADOW_ROOT_IS_AVAILABLE_TO_ELEMENT_INTERNALS = SHADOW_ROOT_FLAG_BIT(6),

  
  SHADOW_ROOT_IS_DETAILS_SHADOW_TREE = SHADOW_ROOT_FLAG_BIT(7),

  
  SHADOW_ROOT_FLAGS_BITS_USED = 8
};

#undef SHADOW_ROOT_FLAG_BIT


ASSERT_NODE_FLAGS_SPACE(NODE_TYPE_SPECIFIC_BITS_OFFSET +
                        SHADOW_ROOT_FLAGS_BITS_USED);

class ShadowRoot final : public DocumentFragment, public DocumentOrShadowRoot {
  friend class DocumentOrShadowRoot;

  using Declarative = Element::ShadowRootDeclarative;
  using IsClonable = Element::ShadowRootClonable;
  using IsSerializable = Element::ShadowRootSerializable;

 public:
  NS_IMPL_FROMNODE_HELPER(ShadowRoot, IsShadowRoot());

  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(ShadowRoot, DocumentFragment)
  NS_DECL_ISUPPORTS_INHERITED

  ShadowRoot(Element* aElement, ShadowRootMode aMode,
             Element::DelegatesFocus aDelegatesFocus,
             SlotAssignmentMode aSlotAssignment, IsClonable aClonable,
             IsSerializable aIsSerializable, Declarative aDeclarative,
             already_AddRefed<mozilla::dom::NodeInfo>&& aNodeInfo);

  void AddSizeOfExcludingThis(nsWindowSizes&, size_t* aNodeSize) const final;

  
  void MaybeReassignContent(nsIContent& aElementOrText);
  
  
  void MaybeSlotHostChild(nsIContent&);
  
  
  void MaybeUnslotHostChild(nsIContent&);

  
  Element* Host() const {
    MOZ_ASSERT(GetHost(),
               "ShadowRoot always has a host, how did we create "
               "this ShadowRoot?");
    return GetHost();
  }

  ShadowRootMode Mode() const {
    return HasFlag(SHADOW_ROOT_MODE_CLOSED) ? ShadowRootMode::Closed
                                            : ShadowRootMode::Open;
  }
  bool DelegatesFocus() const { return HasFlag(SHADOW_ROOT_DELEGATES_FOCUS); }
  SlotAssignmentMode SlotAssignment() const {
    return HasFlag(SHADOW_ROOT_SLOT_ASSIGNMENT_MANUAL)
               ? SlotAssignmentMode::Manual
               : SlotAssignmentMode::Named;
  }
  bool Clonable() const { return HasFlag(SHADOW_ROOT_IS_CLONABLE); }
  bool IsClosed() const { return HasFlag(SHADOW_ROOT_MODE_CLOSED); }
  bool Serializable() const { return HasFlag(SHADOW_ROOT_IS_SERIALIZABLE); }

  void RemoveSheetFromStyles(StyleSheet&);
  void RuleAdded(StyleSheet&, css::Rule&);
  void RuleRemoved(StyleSheet&, css::Rule&);
  void RuleChanged(StyleSheet&, css::Rule*, const StyleRuleChange&);
  void ImportRuleLoaded(StyleSheet&);
  void SheetCloned(StyleSheet&);
  void StyleSheetApplicableStateChanged(StyleSheet&);

  
  void AppendBuiltInStyleSheet(BuiltInStyleSheet);

  


  void CloneInternalDataFrom(ShadowRoot* aOther);
  void InsertSheetAt(size_t aIndex, StyleSheet&);

  
  
  void Unbind();

  
  
  
  
  void Unattach();

  
  
  nsresult Bind();

  













  void InvalidateStyleAndLayoutOnSubtree(Element*);

 private:
  void InsertSheetIntoAuthorData(size_t aIndex, StyleSheet&,
                                 const nsTArray<RefPtr<StyleSheet>>&);

  void AppendStyleSheet(StyleSheet& aSheet) {
    InsertSheetAt(SheetCount(), aSheet);
  }

  bool IsDetailsShadowTree() const {
    return HasFlag(SHADOW_ROOT_IS_DETAILS_SHADOW_TREE);
  }

  


  struct SlotInsertionPoint {
    HTMLSlotElement* mSlot = nullptr;
    Maybe<uint32_t> mIndex;

    SlotInsertionPoint() = default;
    SlotInsertionPoint(HTMLSlotElement* aSlot, const Maybe<uint32_t>& aIndex)
        : mSlot(aSlot), mIndex(aIndex) {}
  };

  






  SlotInsertionPoint SlotInsertionPointFor(nsIContent&);

  




  void GetSlotNameFor(const nsIContent&, nsAString&) const;

  




  enum class SummaryChangeReason { Deletion, Insertion };
  void MaybeReassignMainSummary(SummaryChangeReason);

 public:
  void AddSlot(HTMLSlotElement* aSlot);
  void RemoveSlot(HTMLSlotElement* aSlot);
  bool HasSlots() const { return !mSlotMap.IsEmpty(); };
  HTMLSlotElement* GetDefaultSlot() const {
    SlotArray* list = mSlotMap.Get(u""_ns);
    return list ? (*list).AsSpan()[0] : nullptr;
  }

  void PartAdded(const Element&);
  void PartRemoved(const Element&);

  IMPL_EVENT_HANDLER(slotchange);

  const nsTArray<const Element*>& Parts() const { return mParts; }

  const StyleAuthorStyles* GetServoStyles() const { return mServoStyles.get(); }

  StyleAuthorStyles* GetServoStyles() { return mServoStyles.get(); }

  mozilla::ServoStyleRuleMap& ServoStyleRuleMap();

  JSObject* WrapNode(JSContext*, JS::Handle<JSObject*> aGivenProto) final;

  void NodeInfoChanged(Document* aOldDoc) override;

  void AddToIdTable(Element* aElement, nsAtom* aId);
  void RemoveFromIdTable(Element* aElement, nsAtom* aId);

  
  using mozilla::dom::DocumentOrShadowRoot::GetElementById;

  Element* GetActiveElement();

  




  nsINode* ImportNodeAndAppendChildAt(nsINode& aParentNode, nsINode& aNode,
                                      bool aDeep, mozilla::ErrorResult& rv);

  nsINode* CreateElementAndAppendChildAt(nsINode& aParentNode,
                                         const nsAString& aTagName,
                                         mozilla::ErrorResult& rv);

  bool IsUAWidget() const { return HasBeenInUAWidget(); }

  void SetIsUAWidget() {
    MOZ_ASSERT(!HasChildren());
    SetIsNativeAnonymousRoot();
    SetFlags(NODE_HAS_BEEN_IN_UA_WIDGET);
  }

  bool IsAvailableToElementInternals() const {
    return HasFlag(SHADOW_ROOT_IS_AVAILABLE_TO_ELEMENT_INTERNALS);
  }

  void SetAvailableToElementInternals() {
    SetFlags(SHADOW_ROOT_IS_AVAILABLE_TO_ELEMENT_INTERNALS);
  }

  void GetEventTargetParent(EventChainPreVisitor& aVisitor) override;

  bool IsDeclarative() const { return HasFlag(SHADOW_ROOT_IS_DECLARATIVE); }
  void SetIsDeclarative(Declarative aIsDeclarative) {
    SetIsDeclarative(aIsDeclarative == Declarative::Yes);
  }
  void SetIsDeclarative(bool aIsDeclarative) {
    if (aIsDeclarative) {
      SetFlags(SHADOW_ROOT_IS_DECLARATIVE);
    } else {
      UnsetFlags(SHADOW_ROOT_IS_DECLARATIVE);
    }
  }

  void SetHTML(const nsAString& aInnerHTML, const SetHTMLOptions& aOptions,
               ErrorResult& aError);

  MOZ_CAN_RUN_SCRIPT
  void SetHTMLUnsafe(const TrustedHTMLOrString& aHTML,
                     const SetHTMLUnsafeOptions& aOptions,
                     nsIPrincipal* aSubjectPrincipal, ErrorResult& aError);

  
  void GetInnerHTML(OwningTrustedHTMLOrNullIsEmptyString& aInnerHTML);

  MOZ_CAN_RUN_SCRIPT void SetInnerHTML(
      const TrustedHTMLOrNullIsEmptyString& aInnerHTML,
      nsIPrincipal* aSubjectPrincipal, ErrorResult& aError);

  void GetHTML(const GetHTMLOptions& aOptions, nsAString& aResult);

  bool HasReferenceTarget() const { return mReferenceTarget; }
  void GetReferenceTarget(nsAString& aResult) const {
    if (!mReferenceTarget) {
      aResult.SetIsVoid(true);
      return;
    }
    mReferenceTarget->ToString(aResult);
  }
  nsAtom* ReferenceTarget() const { return mReferenceTarget; }
  void SetReferenceTarget(const nsAString& aValue) {
    if (aValue.IsVoid()) {
      return SetReferenceTarget(nullptr);
    }
    SetReferenceTarget(NS_Atomize(aValue));
  }
  void SetReferenceTarget(RefPtr<nsAtom> aTarget);
  Element* GetReferenceTargetElement() const {
    return mReferenceTarget ? GetElementById(mReferenceTarget) : nullptr;
  }

 protected:
  
  void ApplicableRulesChanged();

  virtual ~ShadowRoot();

  
  
  
  

  
  BindgenUniquePtr<StyleAuthorStyles> mServoStyles;
  UniquePtr<mozilla::ServoStyleRuleMap> mStyleRuleMap;

  using SlotArray = TreeOrderedArray<HTMLSlotElement*>;
  
  
  
  nsClassHashtable<nsStringHashKey, SlotArray> mSlotMap;

  
  
  nsTArray<const Element*> mParts;

  RefPtr<nsAtom> mReferenceTarget;

  static bool ReferenceTargetIDTargetChanged(Element* aOldElement,
                                             Element* aNewElement, void* aData);
  static bool RecursiveReferenceTargetChanged(void* aData);

  void NotifyReferenceTargetChangedObservers();

  nsresult Clone(dom::NodeInfo*, nsINode** aResult) const override;
};

}  
}  

#endif  
