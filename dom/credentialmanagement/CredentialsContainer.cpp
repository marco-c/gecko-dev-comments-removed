





#include "mozilla/dom/CredentialsContainer.h"

#include "mozilla/StaticPrefs_dom.h"
#include "mozilla/StaticPrefs_security.h"
#include "mozilla/dom/Credential.h"
#include "mozilla/dom/FeaturePolicyUtils.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/dom/WebAuthnHandler.h"
#include "mozilla/dom/WebIdentityHandler.h"
#include "mozilla/dom/WindowContext.h"
#include "mozilla/dom/WindowGlobalChild.h"
#include "nsContentUtils.h"
#include "nsIDocShell.h"

namespace mozilla::dom {

NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(CredentialsContainer, mParent,
                                      mWebAuthnHandler)
NS_IMPL_CYCLE_COLLECTING_ADDREF(CredentialsContainer)
NS_IMPL_CYCLE_COLLECTING_RELEASE(CredentialsContainer)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(CredentialsContainer)
  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
  NS_INTERFACE_MAP_ENTRY(nsISupports)
NS_INTERFACE_MAP_END

static bool IsInActiveTab(nsPIDOMWindowInner* aParent) {
  
  
  MOZ_ASSERT(aParent);

  RefPtr<Document> doc = aParent->GetExtantDoc();
  if (NS_WARN_IF(!doc)) {
    return false;
  }

  return IsInActiveTab(doc);
}

static bool ConsumeUserActivation(nsPIDOMWindowInner* aParent) {
  
  
  MOZ_ASSERT(aParent);

  RefPtr<Document> doc = aParent->GetExtantDoc();
  if (NS_WARN_IF(!doc)) {
    return false;
  }

  return doc->ConsumeTransientUserGestureActivation();
}


bool CredentialsContainer::IsSameOriginWithAncestors(
    nsPIDOMWindowInner* aParent) {
  
  
  
  
  MOZ_ASSERT(aParent);

  WindowGlobalChild* wgc = aParent->GetWindowGlobalChild();

  
  
  if (!wgc) {
    return false;
  }

  
  
  for (WindowContext* parentContext =
           wgc->WindowContext()->GetParentWindowContext();
       parentContext; parentContext = parentContext->GetParentWindowContext()) {
    if (!wgc->IsSameOriginWith(parentContext)) {
      
      return false;
    }
  }

  return true;
}

CredentialsContainer::CredentialsContainer(nsPIDOMWindowInner* aParent)
    : mParent(aParent) {
  MOZ_ASSERT(aParent);
}

CredentialsContainer::~CredentialsContainer() = default;

void CredentialsContainer::EnsureWebAuthnHandler() {
  MOZ_ASSERT(NS_IsMainThread());

  if (!mWebAuthnHandler) {
    mWebAuthnHandler = new WebAuthnHandler(mParent);
  }
}

already_AddRefed<WebAuthnHandler> CredentialsContainer::GetWebAuthnHandler() {
  MOZ_ASSERT(NS_IsMainThread());

  EnsureWebAuthnHandler();
  RefPtr<WebAuthnHandler> ref = mWebAuthnHandler;
  return ref.forget();
}

JSObject* CredentialsContainer::WrapObject(JSContext* aCx,
                                           JS::Handle<JSObject*> aGivenProto) {
  return CredentialsContainer_Binding::Wrap(aCx, this, aGivenProto);
}

already_AddRefed<Promise> CredentialsContainer::Get(
    const CredentialRequestOptions& aOptions, ErrorResult& aRv) {
  RefPtr<Promise> promise = Promise::Create(mParent->AsGlobal(), aRv);
  if (aRv.Failed()) {
    return nullptr;
  }

  uint64_t totalOptions = 0;
  if (aOptions.mPublicKey.WasPassed() &&
      StaticPrefs::security_webauth_webauthn()) {
    totalOptions += 1;
  }
  if (aOptions.mIdentity.WasPassed() &&
      StaticPrefs::dom_security_credentialmanagement_identity_enabled()) {
    totalOptions += 1;
  }
  if (totalOptions > 1) {
    promise->MaybeRejectWithNotSupportedError(
        "CredentialsContainer request is not supported."_ns);
    return promise.forget();
  }

  if (aOptions.mSignal.WasPassed() && aOptions.mSignal.Value().Aborted()) {
    JS::Rooted<JS::Value> reason(aCx);
    aOptions.mSignal.Value().GetReason(aCx, &reason);
    promise->MaybeReject(reason);
    return promise.forget();
  }

  bool conditionallyMediated =
      aOptions.mMediation == CredentialMediationRequirement::Conditional;
  if (aOptions.mPublicKey.WasPassed() &&
      StaticPrefs::security_webauth_webauthn()) {
    MOZ_ASSERT(mParent);
    if (!FeaturePolicyUtils::IsFeatureAllowed(
            mParent->GetExtantDoc(), u"publickey-credentials-get"_ns) ||
        !(IsInActiveTab(mParent) || conditionallyMediated)) {
      promise->MaybeRejectWithNotAllowedError(
          "CredentialsContainer request is not allowed."_ns);
      return promise.forget();
    }

    if (conditionallyMediated &&
        !StaticPrefs::security_webauthn_enable_conditional_mediation()) {
      promise->MaybeRejectWithTypeError<MSG_INVALID_ENUM_VALUE>(
          "mediation", "conditional", "CredentialMediationRequirement");
      return promise.forget();
    }

    EnsureWebAuthnHandler();
    mWebAuthnHandler->GetAssertion(aOptions.mPublicKey.Value(),
                                   conditionallyMediated, aOptions.mSignal,
                                   promise);
    return promise.forget();
  }

  if (aOptions.mIdentity.WasPassed() &&
      StaticPrefs::dom_security_credentialmanagement_identity_enabled()) {
    if (conditionallyMediated) {
      promise->MaybeRejectWithTypeError<MSG_INVALID_ENUM_VALUE>(
          "mediation", "conditional", "CredentialMediationRequirement");
      return promise.forget();
    }

    WebIdentityHandler* identityHandler =
        mParent->GetOrCreateWebIdentityHandler();
    if (!identityHandler) {
      promise->MaybeRejectWithOperationError("");
      return promise.forget();
    }
    if (aOptions.mSignal.WasPassed()) {
      identityHandler->Follow(&aOptions.mSignal.Value());
    }
    identityHandler->GetCredential(aOptions, IsSameOriginWithAncestors(mParent),
                                   promise);

    return promise.forget();
  }

  promise->MaybeRejectWithNotSupportedError(
      "CredentialsContainer request is not supported."_ns);
  return promise.forget();
}

already_AddRefed<Promise> CredentialsContainer::Create(
    const CredentialCreationOptions& aOptions, ErrorResult& aRv) {
  RefPtr<Promise> promise = Promise::Create(mParent->AsGlobal(), aRv);
  if (aRv.Failed()) {
    return nullptr;
  }

  
  uint64_t totalOptions = 0;
  if (aOptions.mPublicKey.WasPassed() &&
      StaticPrefs::security_webauth_webauthn()) {
    totalOptions += 1;
  }
  if (totalOptions > 1) {
    promise->MaybeRejectWithNotSupportedError(
        "CredentialsContainer request is not supported."_ns);
    return promise.forget();
  }

  if (aOptions.mSignal.WasPassed() && aOptions.mSignal.Value().Aborted()) {
    JS::Rooted<JS::Value> reason(aCx);
    aOptions.mSignal.Value().GetReason(aCx, &reason);
    promise->MaybeReject(reason);
    return promise.forget();
  }

  if (aOptions.mPublicKey.WasPassed() &&
      StaticPrefs::security_webauth_webauthn()) {
    MOZ_ASSERT(mParent);
    
    
    
    bool hasRequiredActivation =
        IsInActiveTab(mParent) &&
        (IsSameOriginWithAncestors(mParent) || ConsumeUserActivation(mParent));
    if (!FeaturePolicyUtils::IsFeatureAllowed(
            mParent->GetExtantDoc(), u"publickey-credentials-create"_ns) ||
        !hasRequiredActivation) {
      promise->MaybeRejectWithNotAllowedError(
          "CredentialsContainer request is not allowed."_ns);
      return promise.forget();
    }

    EnsureWebAuthnHandler();
    mWebAuthnHandler->MakeCredential(aOptions.mPublicKey.Value(),
                                     aOptions.mSignal, promise);
    return promise.forget();
  }

  promise->MaybeRejectWithNotSupportedError(
      "CredentialsContainer request is not supported."_ns);
  return promise.forget();
}

already_AddRefed<Promise> CredentialsContainer::Store(
    const Credential& aCredential, ErrorResult& aRv) {
  RefPtr<Promise> promise = Promise::Create(mParent->AsGlobal(), aRv);
  if (aRv.Failed()) {
    return nullptr;
  }

  nsString type;
  aCredential.GetType(type);
  if (type.EqualsLiteral("public-key") &&
      StaticPrefs::security_webauth_webauthn()) {
    if (!IsSameOriginWithAncestors(mParent) || !IsInActiveTab(mParent)) {
      promise->MaybeRejectWithNotAllowedError(
          "CredentialsContainer request is not allowed."_ns);
      return promise.forget();
    }

    EnsureWebAuthnHandler();
    mWebAuthnHandler->Store(aCredential, promise);
    return promise.forget();
  }

  promise->MaybeRejectWithNotSupportedError(
      "CredentialsContainer request is not supported."_ns);
  return promise.forget();
}

already_AddRefed<Promise> CredentialsContainer::PreventSilentAccess(
    ErrorResult& aRv) {
  nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(mParent);
  if (NS_WARN_IF(!global)) {
    aRv.Throw(NS_ERROR_FAILURE);
    return nullptr;
  }

  RefPtr<Promise> promise = Promise::Create(global, aRv);
  if (NS_WARN_IF(aRv.Failed())) {
    return nullptr;
  }

  WebIdentityHandler* identityHandler =
      mParent->GetOrCreateWebIdentityHandler();
  if (!identityHandler) {
    promise->MaybeRejectWithOperationError("");
    return promise.forget();
  }

  identityHandler->PreventSilentAccess(promise);
  return promise.forget();
}

}  
