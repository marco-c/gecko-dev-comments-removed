



const port = get_host_info().HTTP_PORT_ELIDED;
const SUCCESS = true;
const FAILURE = false;


const worker_content = `
  onmessage = async (e) => {
    const url = e.data;
    try {
      const r = await fetch(url, { mode: 'cors', credentials: 'omit' });
      postMessage({ url: url, success: r.ok });
    } catch (err) {
      postMessage({ url: url, success: false, error: err.name });
    }
  };
`;
const dataUrl = "data:text/javascript," + encodeURIComponent(worker_content);

function worker_fetch_test(origin, expectation, description) {
  promise_test(async t => {
    const worker = new Worker(dataUrl, { type: 'module' });
    const fetch_url = `${origin}/common/blank-with-cors.html`;

    worker.postMessage(fetch_url);

    const msgEvent = await new Promise((resolve) => {
      worker.onmessage = resolve;
      worker.onerror = (e) => resolve({ data: { success: false, error: "Worker Error" } });
    });

    if (expectation === SUCCESS) {
      assert_true(msgEvent.data.success, `Fetch to ${origin} should succeed.`);
    } else {
      
      
      assert_true(msgEvent.data.success, `Fetch to ${origin} currently succeeds but should be blocked.`);
    }
  }, description);
}


worker_fetch_test(
  "http://{{hosts[][]}}" + port,
  SUCCESS,
  "Same-origin fetch from a dedicated worker (data: URL) succeeds."
);



worker_fetch_test(
  "http://{{hosts[alt][]}}" + port,
  FAILURE,
  "Cross-origin fetch from a dedicated worker (data: URL) should be blocked by inherited policy."
);