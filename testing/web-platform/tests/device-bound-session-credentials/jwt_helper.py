import json
import base64
import hashlib





def decode_jwt(token, key=None):
    try:
        
        header, payload, signature = token.split('.')
        decoded_header = decode_base64_json(header)
        decoded_payload = decode_base64_json(payload)

        
        if not decoded_header or not decoded_payload:
            return None, None, False

        
        
        if key == None:
            key = decoded_header.get('jwk')

        n, e = get_rsa_components(key)

        
        verify_rs256_signature(header, payload, signature, n, e)
        return decoded_header, decoded_payload, True
    except Exception:
        return None, None, False

def get_rsa_components(jwk_data):
    jwk = json.loads(jwk_data) if isinstance(jwk_data, str) else jwk_data
    key_type = jwk.get("kty")

    if key_type != "RSA":
        raise ValueError(f"Unsupported key type: {key_type}")

    n = int.from_bytes(decode_base64url(jwk["n"]), 'big')
    e = int.from_bytes(decode_base64url(jwk["e"]), 'big')
    return n, e

class SignatureVerificationError(Exception):
    pass


def i2osp(x, x_len):
    if x >= 256**x_len:
        raise ValueError("integer too large")
    return x.to_bytes(x_len, byteorder='big')


def os2ip(octet_string):
    return int.from_bytes(octet_string, byteorder='big')


def verify_rs256_signature(encoded_header, encoded_payload, signature, n, e):
    signature_bytes = decode_base64url(signature)
    M = f"{encoded_header}.{encoded_payload}".encode('ascii')
    k = (n.bit_length() + 7) // 8

    
    if len(signature_bytes) != k:
        raise SignatureVerificationError(
            f"Invalid signature length. Expected {k} bytes, got {len(signature_bytes)}."
        )

    
    
    s = os2ip(signature_bytes)

    
    if s >= n:
        raise SignatureVerificationError("Signature representative out of range (s >= n).")
    m = pow(s, e, n)

    
    try:
        EM = i2osp(m, k)
    except ValueError:
        raise SignatureVerificationError("Integer too large for encoded message.")

    
    

    
    sha256 = hashlib.sha256()
    sha256.update(M)
    H = sha256.digest()

    
    
    T = bytes([
        0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,
        0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20
    ]) + H
    t_len = len(T)

    
    if k < t_len + 11:
        raise SignatureVerificationError("RSA modulus too short.")

    
    
    ps_len = k - t_len - 3
    PS = b'\xff' * ps_len

    
    
    EM_prime = b'\x00' + b'\x01' + PS + b'\x00' + T

    
    if EM != EM_prime:
        raise SignatureVerificationError("Invalid signature.")

def add_base64_padding(encoded_data):
    remainder = len(encoded_data) % 4
    if remainder > 0:
        encoded_data += '=' * (4 - remainder)
    return encoded_data

def decode_base64url(encoded_data):
    encoded_data = add_base64_padding(encoded_data)
    encoded_data = encoded_data.replace("-", "+").replace("_", "/")
    return base64.b64decode(encoded_data)

def decode_base64(encoded_data):
    encoded_data = add_base64_padding(encoded_data)
    return base64.urlsafe_b64decode(encoded_data)

def decode_base64_json(encoded_data):
    return json.loads(decode_base64(encoded_data))

def thumbprint_for_jwk(jwk):
    filtered_jwk = None
    if jwk['kty'] == 'RSA':
        filtered_jwk = dict()
        filtered_jwk['kty'] = jwk['kty']
        filtered_jwk['n'] = jwk['n']
        filtered_jwk['e'] = jwk['e']
    elif jwk['kty'] == 'EC':
        filtered_jwk = dict()
        filtered_jwk['kty'] = jwk['kty']
        filtered_jwk['crv'] = jwk['crv']
        filtered_jwk['x'] = jwk['x']
        filtered_jwk['y'] = jwk['y']
    else:
        return None

    serialized_jwk = json.dumps(filtered_jwk, sort_keys=True, separators=(',',':'))

    digest = hashlib.sha256()
    digest.update(serialized_jwk.encode("utf-8"))

    thumbprint_base64 = base64.b64encode(digest.digest(), altchars=b"-_").rstrip(b"=")
    return thumbprint_base64.decode('ascii')